{"version":3,"sources":["components/Sidebar.js","components/Details.js","leetcode/bitwise/476-number-complement.js","leetcode/bitwise/power/231-power-of-two.js","ds/bitwise/common-bit-tasks.js","components/concepts/Bitwise.js","ds/number/power.js","ds/number/swap.js","leetcode/math/1103-distribute-candies-to-people.js","components/concepts/Number.js","ds/string-manipulation/reverse-a-string.js","ds/string-manipulation/define-anagrams.js","ds/string-manipulation/making-anagrams.js","ds/string-manipulation/tasks/alternating-characters.js","ds/string-manipulation/tasks/sherlock-valid-string.js","leetcode/string-manipulation/771-number-jewels-in-stones.js","leetcode/string-manipulation/387-first-unique-character-in-string.js","leetcode/string-manipulation/438-find-all-anagrams.js","leetcode/backtracking/60-permutation-sequence.js","leetcode/string-manipulation/383-ransom-note.js","components/concepts/StringManipulation.js","ds/arrays/merge-sorted-arrays.js","ds/arrays/clone.js","ds/arrays/tasks/jump-on-clouds.js","leetcode/array/majority/169-majority-element.js","leetcode/array/997-find-judge.js","leetcode/array/53-max-contiguous-subarray-sum.js","leetcode/array/540-single-element-in-sorted-array.js","leetcode/array/duplicates/26-remove-duplicates-from-sorted-array.js","components/concepts/ArrayAlgorithms.js","ds/stack/stack-use-string.js","ds/stack/stack-use-array.js","ds/stack/stack-use-linked-list.js","ds/stack/stack-using-objects.js","leetcode/stack/155-min-stack.js","leetcode/stack/716-max-stack.js","components/concepts/Stack.js","ds/queue/queue-use-array.js","ds/queue/queue-use-linked-list.js","leetcode/queue/232-queue-with-2-stacks.js","components/concepts/Queue.js","ds/linked-list/singly/singly-linked-list.js","components/concepts/LinkedLists.js","ds/hash/hashMap/hashMap-use-array.js","ds/hash/hashSet/hashSet-use-object.js","leetcode/array/sum-problems/two-sum.js","leetcode/hash/274-h-index.js","components/concepts/Hash.js","leetcode/graph/dfs/733-flood-fill.js","components/concepts/Graph.js","ds/tree/bt/bt.js","ds/tree/bst/binary-search-tree.js","leetcode/tree/binary-tree/226-invert-binary-tree.js","ds/tree/bt/traversal/preorder.js","ds/tree/bt/traversal/level-order-traversal.js","leetcode/tree/binary-tree/traversal/987-vertical-order-traversal.js","leetcode/tree/binary-tree/path-sum/112-path-sum.js","leetcode/tree/binary-tree/traversal/106-construct-bt-from-postorder-inorder-traversal.js","leetcode/tree/binary-tree/max-width-bt.js","components/concepts/Tree.js","ds/heap/max-binary-heap.js","components/concepts/Heap.js","ds/trie/implementation-Trie.js","ds/trie/trie.js","leetcode/trie/add-search-word.js","components/concepts/Trie.js","ds/sorting/bubble-sort.js","ds/sorting/quick-sort.js","ds/sorting/selection-sort.js","ds/sorting/merge-sort.js","ds/sorting/insertion-sort.js","ds/sorting/heap-sort.js","ds/sorting/problems/find-median.js","components/concepts/Sorting.js","ds/search/linear/find-index.js","ds/search/binary/binary-search.js","ds/search/problems/balanced-sum.js","leetcode/search/binary-search/278-first-bad-version.js","components/concepts/Searching.js","leetcode/recursion/index.js","leetcode/recursion/factorial.js","leetcode/recursion/fibonacci.js","leetcode/divide-conquer/215-k-th-largest-element.js","components/concepts/Recursion.js","leetcode/greedy/hack/min-abs-difference.js","leetcode/greedy/hack/luck-balance.js","leetcode/greedy/1029-two-city-scheduling.js","components/concepts/GreedyAlgorithms.js","leetcode/dp/518-coin-change-2.js","leetcode/dp/96-unique-binary-search-trees.js","leetcode/dp/62-unique-paths.js","leetcode/dp/121-best-time-to-buy-sell-stock.js","leetcode/dp/70-climbing-stairs.js","components/concepts/DP.js","eloquent-tasks/tasks/looping-triangle.js","eloquent-tasks/tasks/fizz-buzz.js","eloquent-tasks/tasks/chessboard.js","eloquent-tasks/tasks/3-chapter-functions/is-even.js","eloquent-tasks/tasks/4-chapter-data-structures/reverse-array.js","eloquent-tasks/CodeSandboxTasks.js","components/Main.js","components/SplitSidebarView.js","config/constants.js","App.js","serviceWorker.js","index.js"],"names":["Sidebar","className","href","Details","props","id","question","solution","complexity","time","omega","space","code","secondCode","thirdSolution","aria-expanded","role","aria-controls","aria-hidden","language","style","docco","dark","flipBitByBit","num","bit","todo","decimalToBinary","N","rem","remStack","binaryString","Math","floor","push","length","pop","toString","complementString","i","Number","parseInt","isPowerOfTwo","n","count","isPowerOfTwoIterative","isPowerOfTwoBitManipulation","getBit","index","setBit","clearBit","BitManipulation","power","base","exponent","undefined","result","swap","a","b","swapUseTemp","temp","distributeCandiesUseLoop","candies","num_people","output","Array","fill","loop","currentCandy","console","log","j","distributeCandies","reverseVariant2","s","helper","left","right","reverseStringRecursion","reverseStringTwoPointersUseTemp","defineAnagrams","str1","str2","Error","len1","len2","obj","normalizedStr1","replace","toLowerCase","normalizedStr2","charCodeAt","Object","values","every","val","makingAnagrams","obj1","obj2","hasOwnProperty","arr1","arr2","reduce","alternatingCharacters","arr","split","len","deletions","list","value","filter","x","isValid","letters","element","valMax","max","valMin","min","countMax","countMin","Set","numJewelsInStonesBruteForce","J","S","charAt","numJewelsInStones","jewels","stones","hash","stone","jewel","firstUniqueChar","frequencies","char","compareDict","dictA","dictB","keyA","keyB","findAnagramsUseTwoHash","p","pCounter","sCounter","k","factorial","nums","sum","res","splice","getPermutation","coordinates","x1","y1","x2","checkStraightLine","StringManipulation","aria-labelledby","mergeSortedArrays","slice","clone","cloneIterative","cloneUseLoopFixedSize","data","copy","jumpOnClouds","c","jumps","nextStep","next2Step","majorityElement","key","majorityMooreVoting","candidate","findJudge","trust","trustScores","relation","findJudgeTwoArrays","outdegree","indegree","maxSubArrayBruteForceCubicTime","maxSubArraySum","Infinity","windowSum","maxSubArrayBruteForce","maximumSubArraySum","runningWindowSum","singleNonDuplicateBruteForce","singleNonDuplicateBinarySearch","lowest","highest","mid","halvesAreEven","singleNonDuplicateBinarySearchOnEvenIndexes","lo","hi","removeDuplicates","uniqueArr","ArrayAlgorithms","Stack","this","storage","item","concat","lastEliminate","lastIndexOf","lastStr","substr","stack","isEmpty","ListNode","next","head","newNode","StackObj","capacity","prototype","myStack","MinStack","minStack","MinStackMinPairs","elements","getMin","MaxStack","maxStack","peekMax","top","unshift","StackArr","StackLinkedList","StackUseString","StackUseObj","popMax","Queue","queue","shift","enqueue","dequeue","traverseNode","current","QueueUse2Pointers","tail","stackNewest","stackOldest","shiftStacks","QueueArray","QueueLinkedList","QueueUse2Stacks","LinkedList","size","counter","node","addAtHead","addAtTail","previous","getAt","nodes","join","LinkedLists","HashTable","keys","lookupKey","HashSet","contains","HashSetVariant1","twoSumBruteForce","twoSumTwoPassHashes","target","map","Map","set","complement","has","get","twoSum","index2","add","remove","hIndexSort","citations","sort","hIndex","total","Hash","HashMap","floodFill","image","row","col","newColor","startingColor","floodFillUseHelper","img","sr","sc","color","originalColor","rows","cols","Graph","TreeNode","BT","root","Node","BinarySearchTree","check","y","currentNode","height","leftHeight","rightHeight","q","lowestCommonAncestor","tree","insert","invertTree","tree4","searchTree","JSON","parse","stringify","preorderTraversal","nodeStack","levelOrder","levelOrderForLeetcode","verticalTraversalWithoutOrder","hasPathSum","build","inorder","postorder","recur","inStart","inEnd","posStart","posEnd","buildTree","getHeight","level","getWidth","maxWidth","width","insertNode","position","first","currentWidth","widthOfBinaryTreeVariant1","Tree","MaxBinaryHeap","parentIndex","bubbleUp","swim","parent","leftChildIndex","rightChildIndex","leftChild","rightChild","indexToSwap","poppedVal","bubbleDown","index1","heap","Heap","deleteMax","Trie","children","word","curNode","curChar","d","trie","search","isWord","traverse","startsWith","prefix","TrieNode","isEnd","WordDictionary","cur","trie1","ImplementationTrie","DesignTrie1","DesignTrie","bubbleSort","quickSort","pivot","leftArr","rightArr","el","selectionSort","merger","singleSorted","mergeSort","insertionSort","heapify","largest","heapSort","addWord","findMedian","median","sortedArr","grid","perimeter","square","islandPerimeter","Sorting","findIndex","searchQuery","binarySearch","start","end","binarySearchRecursive","stop","balancedSum","solutionBinarySearch","isBadVersion","Searching","spaceComplexity","loopNTimes","countDown","sumUseLoop","countDownFrom","fib","fibIterative","findKthLargest","partitionLomuto","Recursion","third","minimumAbsoluteDifference","diff","abs","luckBalance","contests","luck","lost","twoCitySchedCost","costs","midIndex","twoCitySchedCostSortAbs","counterA","counterB","costCityA","costCityB","GreedyAlgorithms","change","amount","coins","combinations","coin","numTrees","T","uniquePaths","m","path","_","maxProfit","prices","minPrice","profit","maxProfitUseBruteForce","climbStairsBruteForce","DP","loopingTriangle","symbol","line","fizzBuzz","chessboard","board","isEven","reverseArray","reverse","reverseArrayInPlace","old","reverseUseRecursion","reversedArr","addItems","orderedArr","Main","SplitSidebarView","window","innerWidth","state","sideBarSize","getSize","sideBarGrowing","handleDrag","bind","onDragFinished","onResizerDoubleClick","windowWidth","setState","event","onChange","resizerStyle","minSize","maxSize","Component","openTarget","location","substring","detail","document","getElementById","tagName","open","App","addEventListener","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.2ea459b0.chunk.js","sourcesContent":["import React from 'react';\n\nimport './sidebar.css';\n\nfunction Sidebar() {\n  return (\n    <div className=\"sidebar\">\n      <a href=\"/\" className=\"logo\">Topics</a>\n      <nav>\n        <ul className=\"list\">\n          <li className=\"item\"><header className=\"title\"><a href=\"#bit\">Bit Manipulation</a></header></li>\n          <li className=\"item\"><header className=\"title\"><a href=\"#number\">Number</a></header></li>\n          <li className=\"item\">\n            <header className=\"title\">String Manipulation</header>\n            <ul className=\"subList\">\n              <li><a href=\"#define-anagrams\">Define anagrams</a></li>\n              <li><a href=\"#making-anagrams\">Making anagrams</a></li>\n            </ul>\n          </li>\n          <li className=\"item\"><header className=\"title\"><a href=\"#array\">Array</a></header></li>\n          <li className=\"item\"><header className=\"title\"><a href=\"#hash\">Hash</a></header></li>\n\n          <li className=\"item\">\n            <header className=\"title\">Sorting</header>\n            <ul className=\"subList\">\n              <li><a href=\"#bubble-sort\">Bubble sort</a></li>\n              <li><a href=\"#selection-sort\">Selection sort</a></li>\n              <li><a href=\"#insertion-sort\">Insertion sort</a></li>\n              <li><a href=\"#merge-sort\">Merge sort</a></li>\n              <li><a href=\"#quick-sort\">Quick sort</a></li>\n            </ul>\n          </li>\n          <li className=\"item\">\n            <header className=\"title\">Search</header>\n            <ul className=\"subList\">\n              <li><a href=\"#is-find-index\">Linear search</a></li>\n              <li><a href=\"#binary-search\">Binary search</a></li>\n\n              {/* other tasks */}\n              <li><a href=\"#search-balanced-sum\">Balanced Sum</a></li>\n              <li><a href=\"#search-two-sum\">Two Sum</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\">Linked Lists</header>\n            <ul className=\"subList\">\n              <li><a href=\"#singly-linked-list\">Singly-linked List</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\"><a href=\"#stack\">Stack</a></header>\n            <ul className=\"subList\">\n              <li><a href=\"#stack-use-array\">Stack use Array</a></li>\n              <li><a href=\"#stack-use-linked-list\">Stack use Linked List</a></li>\n              <li><a href=\"#stack-using-string\">Stack use Strings</a></li>\n              {/* <li><a href=\"#stack-using-object\">Stack implementation using object</a></li> */}\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\"><a href=\"#queue\">Queue</a></header>\n            <ul className=\"subList\">\n              <li><a href=\"#queue-use-array\">Queue via Array</a></li>\n              <li><a href=\"#queue-use-linked-lost\">Queue via Linked list</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\"><a href=\"#binary-search-tree\">Tree</a></header>\n            <ul className=\"subList\">\n              <li><a href=\"#binary-search-tree-operations\">Binary Search Tree</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\">Graph</header>\n            <ul className=\"subList\">\n              <li><header className=\"title\"><a href=\"#graph-dfs-flood-fill\">Flood fill</a></header></li>\n            </ul>\n          </li>\n\n          <li className=\"item\"><header className=\"title\"><a href=\"#recursion\">Recursion</a></header></li>\n          <li className=\"item\"><header className=\"title\"><a href=\"#greedy\">Greedy Algorithms</a></header></li>\n          <li className=\"item\"><header className=\"title\"><a href=\"#dp\">DP</a></header></li>\n\n\n          <li className=\"item\">\n            <header className=\"title\">\n              Tasks from Eloquent JavaScript\n            </header>\n            <ul className=\"subList\">\n              <li><a href=\"#eloquent-looping-triangle\">Looping a triangle</a></li>\n              <li><a href=\"#eloquent-fizz-buzz\">Fizz buzz</a></li>\n              <li><a href=\"#eloquent-chessboard\">Chessboard</a></li>\n              <li><a href=\"#eloquent-is-even\">Recursion</a></li>\n            </ul>\n          </li>\n\n        </ul>\n      </nav>\n    </div>\n  );\n}\n\nexport default Sidebar;\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco, dark } from 'react-syntax-highlighter/dist/esm/styles/hljs';\n\n// function createMarkup(markup) {\n//   return {__html: markup};\n// }\n\nexport default function Details(props) {\n  const {\n    id,\n    question,\n    solution,\n    complexity,\n    time,\n    omega,\n    space,\n    code,\n    secondCode,\n    thirdSolution\n  } = props;\n\n  return (\n    <details\n      className=\"details\"\n      id={id}\n      aria-expanded=\"false\">\n      <summary\n        role=\"button\"\n        aria-controls=\"content\"\n      >\n        <span className=\"question\">\n          Question:&nbsp;\n          <strong>{question}</strong>\n        </span>\n      </summary>\n\n      <div aria-hidden=\"true\">\n        <h3 className=\"title\">Solution:</h3>\n        <p className=\"solutionDesc\">{solution}</p>\n        <div className=\"complexity\">\n          {/* {complexityDesc && <div dangerouslySetInnerHTML={createMarkup(complexityDesc)} />} */}\n          {complexity && <div className=\"complexityDesc\">{complexity}</div> }\n          {time && <p className=\"runtime\">Time is {time}</p>}\n          {omega && <p className=\"runtime\">Best time is {omega}</p>}\n          {space && <p>Space is {space}</p>}\n        </div>\n\n        {code &&\n          <SyntaxHighlighter\n            language=\"javascript\"\n            style={docco}\n          >\n            {code}\n          </SyntaxHighlighter>\n        }\n\n        {secondCode &&\n          <SyntaxHighlighter\n            language=\"javascript\"\n            style={dark}\n          >\n            {secondCode}\n          </SyntaxHighlighter>\n        }\n\n        {thirdSolution &&\n          <SyntaxHighlighter\n            language=\"javascript\"\n            style={docco}\n          >\n            {thirdSolution}\n          </SyntaxHighlighter>\n        }\n\n      </div>\n    </details>\n  )\n}\n","/*\nLeetcode\n476. Number complement / 1009. Complement of Base 10 Integer\neasy\n\nGiven a positive integer, output its complement number.\nThe complement strategy is to flip the bits of its binary representation.\n5 -> 101\n11 -> 1011\n\nNote that except for N = 0, there are no leading zeroes in any binary representation\n\nExample 1:\nInput: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits),\nand its complement is 010. So you need to output 2.\n\nExample 2:\nInput: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits),\nand its complement is 0. So you need to output 0.\n*/\n\n/*\nApproach 1 Flip Bit by bit\n\nflip current bit using XOR operator\n\nTo move along the number and flip bit by bit.\n\nInitiate 1-bit variable which will be used to flip bits one by one.\nSet it to the smallest register bit = 1.\nInitiate the marker variable which will be used to stop the loop over the bits\ntodo = num.\n\nLoop over the bits. While todo != 0:\nFlip the current bit: num = num ^ bit.\nPrepare for the next run. Shift flip variable to the left and todo variable to\nthe right. Return num\n\nTime Complexity: O(1), since we're doing not more than 32 iterations here\nSpace complexity O(1)\n*/\n\nvar flipBitByBit = function(num) {\n  if (num === 1) return 0;\n  if (num === 0) return 1;\n\n  let bit = 1;\n  let todo = num;\n\n  while (todo) {\n    //console.log('line 1', num.toString(2))\n    // flip current bit\n    num = num ^ bit; // X ^ 1s = ~ X\n    //console.log('line 2', num.toString(2))\n\n    // prepare for next run\n    //console.log('line 3', bit.toString(2))\n    bit = bit << 1; // Shift flip variable to the left\n    //console.log('line 4', bit.toString(2))\n\n    todo = todo >> 1; // todo variable to the right\n    //console.log('line 5', todo.toString(2))\n  }\n  return num;\n}\n//console.log('flipBitByBit', flipBitByBit(10))\n\nfunction findComplementUsePow(num) {\n  let n = 0;\n  while (n < num) {\n    n = (n << 1) | 1;\n  }\n  return n - num\n}\n\nfunction findComplementUsePowVariant1(N) {\n  let i = 1; // i = pow(2, x)  1; c is the smallest number >= N\n\n  while (i < N) {\n    i = (i << 1) | 1;\n    //i = i*2 + 1;  same as above\n  }\n\n  //return i - N; // also ok\n  return N ^ i;\n}\n//console.log('findComplementUsePow', findComplementUsePow(5))\n\n/*\n  Approach 2 use toString and parseInt\n\n  Time complexity is O(1), because toString operates from 2 through 36 bits.\n*/\nvar bitwiseComplement = function(N) {\n  const mask = N.toString(2);\n  let flip = [];\n  for (let i = 0; i < mask.length; i++) {\n    let bit = 1;\n    if (Number(mask[i]) === 1) {\n      bit = 0\n    }\n    flip.push(bit)\n  }\n\n  const complement = flip.join('');\n  return parseInt(complement, 2);\n}\n\n// second variant\nvar findComplement = function(N) {\n  const mask = N.toString(2);\n  let str = '';\n  for (const i of mask) {\n    str += +!(i-0);\n  }\n  return parseInt(str, 2);\n}\n\n/*\n  Approach without toString and parseInt\n*/\nconst power = function(base, exponent) {\n  if (exponent === 0) return 1\n  return base * power(base, exponent - 1)\n}\n\nvar bitwiseComplementUseReduce = function(N) {\n  const num = N.toString(2);\n  let flip = [];\n  for (let i = 0; i < num.length; i++) {\n    let bit = 1;\n    if (Number(num[i]) === 1) {\n      bit = 0\n    }\n    flip.push(bit)\n  }\n\n  const len = flip.length;\n  const complement = flip.map((val, index) => {\n    index = index + 1; // todo explain\n    return power(2, len - index) * val\n  })\n\n  const decimal = complement.reduce((accumulator, currentValue) => {\n    return accumulator + currentValue\n  }, 0)\n\n  return decimal\n}\n\n/*\nApproach Decimal to Binary + use Stack\n\nAlgorithm\n1. Convert Decimal to binary.\n2. Take its compliment\n3. Convert back to equivalent Decimal.\n\nthe math\n(1) 10 / 2 = 5\n(1) 5 / 2 = 2\n(0) 2 / 2 = 1\n(1) 1 / 2 = 0\n\nTime is O(log n)\nspace is O(log n)\n*/\nfunction decimalToBinary(N) {\n  if (N === 0) return 1;\n  if (N === 1) return 0;\n  // decimal to binary using Stack\n  let remStack = [],\n    rem,\n    binaryString = '';\n\n  while (N > 0) {\n    rem = Math.floor(N % 2);\n    remStack.push(rem);\n    N = Math.floor(N / 2);\n  }\n\n  while (remStack.length) {\n    binaryString += remStack.pop().toString();\n  }\n\n  // complement binary string\n  let complementString = '';\n  for (let i = 0; i < binaryString.length; i++) {\n    if (Number(binaryString[i]) === 0) {\n      complementString +='1'\n    } else {\n      complementString +='0'\n    }\n  }\n\n  // Convert back to equivalent Decimal\n  return parseInt(complementString, 2)\n}\n//console.log('decimalToBinary', decimalToBinary(10))\n\nexport {\n  bitwiseComplement, findComplement, bitwiseComplementUseReduce,\n  flipBitByBit,\n  decimalToBinary,\n  findComplementUsePowVariant1, findComplementUsePow\n}\n","/*\nLeetcode\n231 Power of two\n\nGiven an integer, write a function to determine if it is a power of two.\n\nExample 1:\nInput: 1\nOutput: true\nExplanation: 20 = 1\nExample 2:\n\nInput: 16\nOutput: true\nExplanation: 24 = 16\nExample 3:\n\nInput: 218\nOutput: false\n*/\n\n/*\nApproach Math\n\nBinary representation\n2 -> 100\n3 -> 11\n4 -> 100\n5 -> 101\n6 -> 110\n8 -> 1000\n32 -> 100000\n\ntime is O(n)\nspace is O(1)\n*/\n\n/**\n * @param {number} n\n * @return {boolean}\n */\nvar isPowerOfTwo = function(n) {\n  if (n < 0) return false;\n\n  n = n.toString(2);\n  let count = 0;\n\n  for (let i = 0; i < n.length; i++) {\n    if (Number(n[i]) === 1) {\n      count++;\n    }\n  }\n  return (count === 1) ? true : false;\n};\n\n/*\nApproach iterative: Keep dividing by 2\n\nCheck if n can be divided by 2.\nIf yes, divide n by 2 and check it repeatedly.\n\nTime complexity = O(log n)\n*/\nvar isPowerOfTwoIterative = function(n) {\n  if (n <= 0) return false;\n  while (n % 2 === 0) n /= 2;\n  return n === 1;\n};\n\n/*\nApproach iterative 2\n*/\nvar isPowerOfTwoUseWhile = function(n) {\n  let i = 1;\n  while (i < n) i = i*2;\n  return i === n;\n};\n\n/*\nApproach bit manipulation (trick)\n\nThere is a question: explain what the following code does: n & (n-1) === 0.\nWhat does it mean A & B === 0.\nIt means that A and B never have 1 bit in the same place. So if n & (n-1) === 0,\nthen n and n-1 never share 1.\nThe value n is therefore a power of two\n\nPower of two means only one bit of n is 1.\nAnd you can use trick n & (n-1) === 0 to judge\nwhether that is the case.\n\nExample 1\nn = 100000, then n - 1 = 011111 and n & (n-1) = 000000,\nso if it's power of two, result is zero.\n\n2\nn = 101110, then n - 1 = 101101, and n & (n-1) = 101100,\nnumber is not power of two and result is not zero.\n\nTime is O(1), space is O(1)\n*/\nvar isPowerOfTwoBitManipulation = function(n) {\n  return (n > 0 && (n & (n - 1)) === 0);\n};\n\n/*\nApproach use log, ceil, floor\n*/\nvar isPowerOfTwoMath = function(n) {\n  if (n <= 0) return false;\n  return Math.floor(Math.log2(n)) ===  Math.ceil(Math.log2(n)) ? true : false;\n};\n\n/*\nApproach bit shift\n\nHow to use bit shift in order to find if its power of two:\nwe will keep shifting unless we hit first set of bit.\n\nif you remove all less significant bits then you value should be\nequals to 1\n\nhow to find is bit equal to 1 -\nyou will take bitwise and operator: number & x where x=1\n*/\nvar isPowerOfTwoShiftBit = function(n) {\n  if ( n === 0 ) return false;\n\n  while (n > 1 && (n & 1) === 0)  {\n    n >>= 1\n  }\n\n  return n === 1\n};\n\n/*\nApproach counting set bits\ntodo\n*/\n\n/*\nApproach binary search\ntodo\n*/\n\nexport {\n  isPowerOfTwo,\n  isPowerOfTwoIterative,\n  isPowerOfTwoMath,\n  isPowerOfTwoBitManipulation,\n  isPowerOfTwoShiftBit,\n  isPowerOfTwoUseWhile\n}\n","/*\ngetBit\n\nThis method shifts 1 over by i bits\n*/\n\n/**\n *\n * @param {*} num\n * @param {*} index\n */\nfunction getBit(num, index) {\n  // creates a value that looks like 00010000\n  const mask = 1 << index;\n  // by performing AND with num we clear all bits other that the bit at bit index\n  // finally we compare that to 0\n  // if that new value is not zero, then bit index must have a 1. Otherwise,\n  // bit is a 0\n  return (num & mask) !== 0;\n}\n\n// tests\n// console.log('getBit', getBit(5,0)); // true\n// console.log('getBit', getBit(5,1)); // false, 5 - 101\n// console.log('getBit', getBit(5,2)); // true\n\n\n/*\nsetBit\nGiven a number, write a function that sets its i-th bit to 1.\n\nsetBit shifts 1 over by i bits, creating a value like 00010000. By performing an\nOR with num, only the value at bit i will change. All other bits of the mack are\nzero and will not affect them.\n\n0|0 = 0 we don't have this case\n1|0 = 1\n0|1 = 1\n1|1 = 1\n*/\nfunction setBit(num, index) {\n  const mask = 1 << index;\n  return num | mask;\n}\n\n// tests\n// console.log('setBit', setBit(5,0)); // 5\n// console.log('setBit', setBit(5,1)); // 7\n// console.log('setBit', setBit(5,2)); // 5\n\n/*\nClear bit\n\nGiven a number, write a function that clears its ith bit by setting it to 0.\nThis method operates in almost the reverse of setBit.\nFirst, we create a number line 11101111 by creating the reverse of it (00010000)\nand negating it. Then we perform an AND with num. This will clear the i-th bit\nand leave the remainder unchanged\n*/\n\nfunction clearBit(num, index) {\n  const mask = ~(1 << index);\n  return num & mask;\n}\n\n// tests\n// console.log('clearBit', clearBit(2,0)); // is a 0\n// console.log('clearBit', clearBit(2,1));\n// console.log('clearBit', clearBit(5,0)); //\n// console.log('clearBit', clearBit(5,1)); //\n// console.log('clearBit', clearBit(5,2)); //\n\n/*\nTo clear all bits from the most significant bit till i,\nwe create a mask with a 1, 1<<i. Then we subtract 1 from it, i=4,\n00010000 -> 00001111,\nwe left 4 bits untouched. mask = (1<<i)-1, num&mask\nTo clear all bits from i through 0. mask = (-1<<(i+1)) ,-1 is all 1s,\nthen we have a sequence of 1s followed by i 0 bits\n*/\nfunction clearAllBits(num, index) {\n  const mask = (1 << index) - 1;\n  return num & mask\n}\n\n// tests\n// console.log('clearAllBits', clearAllBits(5,0));\n// console.log('clearAllBits', clearAllBits(5,1));\n// console.log('clearAllBits', clearAllBits(5,2));\n\n\n/*\ntoggleBit\n*/\n\nfunction toggleBit(num, index) {\n  const mask = 1 << index;\n  return num ^ mask;\n}\n\n\n/*\ntestBit\nGiven a number, write a method that tests if its i-th bit is set.\n\nWe'll say that the bits are numbered from the least significant bit (on the right)\nto the most significant bit (on the left).\n\nSo, the binary number 0000 0001 has the 0th bit set and all the rest of its bits\nare clear (not set)\n\nAnswer\nWe can test if the value has a specific bit set using a left shift with an and operator.\n\nFirst, we'll create a mask by taking 1 and shifting it left until the set bit\nis at the index we want to test.\n\nValues used in bitwise operations are sometimes called masks.\n(The nickname comes from the fact that the values often hide certain bits\nand reveal others, like a costume mask.)\n\nHere's a mask that can be or'd with a number to set its\nfifth bit: 0010 0000.\nAnd, here's a mask that can be and'd with a number to clear its third\nbit: 1111 0111\n\n1 << 0    0000 0001   // for the 0th bit\n1 << 1    0000 0010   // for the 1st bit\n1 << 2    0000 0100   // for the 2nd bit\n...\n1 << 7    1000 0000   // for the 7th bit\n\nThen, we'll & the shifted 1 with the value we're testing. If the result is zero,\nthen the bit isn't set; otherwise, it is.\n\n& 0101 1101\n  0010 0000\n-----------\n  0000 0000\n\n& 0101 1101\n  0100 0000\n-----------\n  0100 0000\n\n*/\n\n/**\n * Returns True if number has the index'th bit set and False otherwise.\n * @param {*} number\n * @param {*} index\n */\nfunction testBit(number, index) {\n  let mask = 1 << index;\n  // mask !== 0  => true || false => 1 || 0\n  return number & mask !== 0\n}\n\n// console.log(testBit(1, 0))\n// console.log(testBit(1, 1)) ; // start from 0?\n// console.log(testBit(1, 2));\n\n/*\nExamples\n...\n*/\n\nexport {\n  getBit,\n  setBit,\n  clearBit,\n  clearAllBits,\n  toggleBit,\n  testBit\n}\n","import React from 'react';\nimport Details from '../Details';\n\n// problems\nimport { flipBitByBit, decimalToBinary } from '../../leetcode/bitwise/476-number-complement';\nimport { isPowerOfTwoIterative, isPowerOfTwoBitManipulation, isPowerOfTwo } from '../../leetcode/bitwise/power/231-power-of-two';\n// import { isPowerOfFour } from '../../leetcode/bitwise/power/342-power-of-four';\n// import { isPowerOfThree } from '../../leetcode/bitwise/power/326-power-of-three';\n// import { hammingWeight } from '../../leetcode/bitwise/191-number-of-bits';\n// import { reverseBits } from '../../leetcode/bitwise/190-reverse-bits';\n// import { hasAlternatingBits } from '../../leetcode/bitwise/693-alternating-bits';\n// import { singleNumber2 } from '../../leetcode/bitwise/single-number/137-single-number-2';\n// import { singleNumber3 } from '../../leetcode/bitwise/single-number/260-single-number-3';\nimport { getBit, setBit, clearBit } from '../../ds/bitwise/common-bit-tasks';\n\n\nexport default function BitManipulation() {\n  return (\n    <div className=\"bit\">\n      <h2 id=\"bit\">Bit Manipulation</h2>\n\n      <ul>\n        {/* <Details\n          id=\"test\"\n          question=\"test\"\n          code={isPowerOfThree.toString()}\n          //secondCode={singleNumber3.toString()}\n        /> */}\n        <li>\n          <a href=\"https://github.com/julia-dizhak/javascript-algorithms/blob/master/README.md#bitwise-operators\">\n            List of problems with solutions\n          </a>\n        </li>\n        <li>\n          <Details\n            id=\"common-bit-tasks\"\n            question=\"Common bit tasks\"\n            solution=\"Tasks: getBit(n,i), setBit(n,i), clearBit(n,i)\"\n            time=\"\"\n            space=\"\"\n            code={getBit.toString()}\n            secondCode={setBit.toString()}\n            thirdSolution={clearBit.toString()}\n          />\n        </li>\n        <li>\n          <Details\n            id=\"number-complement\"\n            question=\"Complement of Base 10 Integer\"\n            solution=\"The complement strategy is to flip the bits of its binary representation\"\n            time=\"O(1)\"\n            space=\"O(1)\"\n            code={flipBitByBit.toString()}\n            secondCode={decimalToBinary.toString()}\n          />\n        </li>\n        <li>\n          <Details\n            id=\"bit-power-of-two\"\n            question=\"Power of two: Given an integer, write a function to determine if it is a power of two\"\n            solution=\"approach iterative, bit manipulation, math and use toString\"\n            complexity=\"for bit manipulation approach, time and space is O(1)\"\n            time=\"O(log n)\"\n            space=\"is O(1)\"\n            code={isPowerOfTwoIterative.toString()}\n            secondCode={isPowerOfTwoBitManipulation.toString()}\n            thirdSolution={isPowerOfTwo.toString()}\n          />\n        </li>\n\n      </ul>\n\n  </div>\n  );\n}\n","function power(base, exponent) {\n  if (exponent === undefined) exponent = 2;\n\n  let result = 1;\n\n  for (let count = 0; count < exponent; count++) {\n    result *= base;\n  }\n\n  return result\n}\n\n/**\n * Recursion usually ten times slower than loops\n */\nfunction powerUsingRecursion(base, exponent) {\n  if ( exponent === 0) {\n    return 1\n  } else {\n    return base * powerUsingRecursion(base, exponent - 1)\n  }\n}\n\nexport { power, powerUsingRecursion }\n","/**\n * Swap a number\n *\n * @param {number1, number2}\n * @return {number2, number1}\n */\n\n/*\n  Approach 1\n  time complexity O(1)\n*/\nconst swap = function(a,b) {\n  //console.log('before swap: ','a: ', a, 'b: ', b);\n  b = b - a; // b = 4 - 3 = 1\n  a = a + b; // a = 3 + 1 = 4\n  b = a - b; // b = 4 - 1 = 3\n\n  return [a, b];\n}\n\n/*\n  Use temp\n  time complexity O(1)\n*/\nconst swapUseTemp = function(a,b) {\n  let temp = a;\n  a = b;\n  b = temp;\n\n  return [a,b];\n}\n\n/**\n * Bitwise operators treat their operands as a sequence of 32 bits (zeroes and ones),\n * rather than as decimal, hexadecimal, or octal numbers.\n *\n * For example, the decimal number nine has a binary representation of 1001.\n * Bitwise operators perform their operations on such binary representations,\n * but they return standard JavaScript numerical values.\n */\n\nconst swapNumberUseBitwise = (a, b) => {\n  a = a ^ b;\n  b = a ^ b;\n  a = a ^ b;\n\n  return [a, b];\n};\n\nexport { swap, swapUseTemp, swapNumberUseBitwise  }\n","/*\nLeetcode\n1103 Distribute candies to people\neasy\n\nWe distribute some number of candies, to a row of n = num_people people in the\nfollowing way:\nWe then give 1 candy to the first person, 2 candies to the second person,\nand so on until we give n candies to the last person.\n\nThen, we go back to the start of the row, giving n + 1 candies to the first\nperson, n + 2 candies to the second person, and so on until we give 2 * n candies\nto the last person.\n\nThis process repeats (with us giving one more candy each time, and moving to\nthe start of the row after we reach the end) until we run out of candies.\nThe last person will receive all of our remaining candies (not necessarily\none more than the previous gift).\n\nReturn an array (of length num_people and sum candies) that represents the final\ndistribution of candies.\n\nHint 1\nGive candy to everyone each \"turn\" first [until you can't], then give candy\nto one person per turn.\n\nExample 1:\nInput: candies = 7, num_people = 4\nOutput: [1,2,3,1]\n\nExplanation:\nOn the first turn, ans[0] += 1, and the array is [1,0,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3,0].\nOn the fourth turn, ans[3] += 1 (because there is only one candy left), and\nthe final array is [1,2,3,1].\n\nExample 2:\nInput: candies = 10, num_people = 3\nOutput: [5,2,3]\n\nExplanation:\nOn the first turn, ans[0] += 1, and the array is [1,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3].\nOn the fourth turn, ans[0] += 4, and the final array is [5,2,3].\n\n\nConstraints:\n1 <= candies <= 10^9\n1 <= num_people <= 1000\n*/\n\n/*\nApproach iterative (loop)\ntime is O(n)\n*/\n/**\n * @param {number} candies\n * @param {number} num_people\n * @return {number[]}\n */\nvar distributeCandies = function(candies, num_people) {\n  let output = new Array(num_people).fill(0);\n  const n = output.length;\n\n\n  // while (candies > 0) {\n  for (let i = 0; i < n; i++) {\n    //debugger\n    if (candies >= 0 && candies >= i+1) {\n      output[i] = i+1;\n    } else {\n      output[i] = candies;\n      break\n    }\n    candies -= (i+1);\n  }\n\n  let j = 0;\n  while (candies > 0) {\n    //debugger\n    if (j>=n) {\n      j = 0\n    }\n    if (candies >= output[j]+n+1 ) {\n      // n+1\n      output[j] = output[j] + n + 1;\n    } else {\n      output[j] = output[j] + candies;\n      break;\n    }\n    candies -= j + (n + 1);\n    j++;\n  }\n\n  return output;\n};\n\nvar distributeCandiesUseLoop = function(candies, num_people) {\n  let output = new Array(num_people).fill(0);\n  let loop = 0;\n\n  let i = 0;\n  while (candies > 0) {\n    if (i === num_people) {\n      loop++;\n      i = 0;\n    }\n\n    let currentCandy = (loop * num_people) + (i+1);\n    if (candies < currentCandy) {\n      output[i] += candies;\n      break;\n    }\n    output[i] += currentCandy;\n    candies -=currentCandy\n    i++;\n\n  }\n\n  return output;\n}\n\n// tests\n//console.log('distributeCandies', distributeCandies(7, 4)) // [1,2,3,1]\n//console.log('distributeCandies', distributeCandies(10, 3)) // [5,2,3]\nconsole.log('distributeCandies', distributeCandies(28, 3)) // [12,7,9]?\n\nexport {\n  distributeCandies,\n  distributeCandiesUseLoop\n}\n","import React from 'react';\nimport Details from './../Details';\nimport { power } from '../../ds/number/power';\nimport { swap, swapUseTemp } from '../../ds/number/swap';\n\n// problems\n// import { countPrimes } from '../../leetcode/number/204-count-primes';\n// import { isUgly } from '../../leetcode/number/263-ugly-number'\n// import { nthUglyNumber } from '../../leetcode/number/264-ugly-number-2'\n// import { addDigits } from '../../leetcode/math/258-add-digits'\n// import { titleToNumber } from '../../leetcode/math/171-excel-sheet-column-number';\nimport { distributeCandiesUseLoop } from '../../leetcode/math/1103-distribute-candies-to-people';\n\nexport default function Number() {\n  return (\n    <div className=\"number\">\n      <h2>Numbers / Math</h2>\n\n      <Details\n        id=\"number-test\"\n        question=\"test\"\n        code={distributeCandiesUseLoop.toString()}\n        //code={addDigits.toString()}\n      />\n\n      <ul id=\"number\">\n        <li>\n          <Details\n            id=\"number-power\"\n            question=\"Write a power function\"\n            code={power.toString()}\n          />\n\n          <Details\n            id=\"number-swap\"\n            question=\"Swap: 2 variables\"\n            time=\"O(1)\"\n            code={swap.toString()}\n            secondCode={swapUseTemp.toString()}\n          />\n        </li>\n      </ul>\n  </div>\n  );\n}\n","// you can check file reverse an array as well\n\n/*\nLeetcode\n344. Write a function that reverses a string.\neasy\n\nThe input string is given as an array of characters char[].\nDo not allocate extra space for another array, you must do this by modifying\nthe input array in-place with O(1) extra memory.\n\nYou may assume all the characters consist of printable ascii characters.\n\nExample 1:\n\nInput: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\nExample 2:\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\nThe entire logic for reversing a string is based on using the opposite directional two-pointer approach!\n*/\n\n/*\n  Use swap function\n*/\nfunction swap(arr, a, b) {\n  let temp = arr[a];\n  arr[a] = arr[b];\n  arr[b] = temp;\n}\nvar reverse = s => {\n  for (let i = 0; i < s.length/2; i++) {\n    swap(s, i, s.length - i - 1);\n  }\n}\n\n// Time complexity O(N) - as these two pointers touch all the elements in the array\nvar reverseVariant2 = s => {\n  for (let i = 0; i < s.length/2; i++) {\n    let temp = s[i];\n    s[i] = s[s.length - i - 1];\n    s[s.length - i - 1] = temp;\n  }\n}\n\n/*\nApproach Recursion in-place\nDoes in-place mean constant space complexity?\nNo. By definition, an in-place algorithm is an algorithm which transforms input\nusing no auxiliary data structure.\n\nThe tricky part is that space is used by many actors, not only by data structures.\nThe classical example is to use recursive function without any auxiliary data structures.\nIs it in-place? Yes.\nIs it constant space? No, because of recursion stack.\n\nAlgorithm\nLet's implement recursive function helper which receives two pointers,\nleft and right, as arguments.\n\nBase case: if left >= right, do nothing.\nOtherwise, swap s[left] and s[right] and call helper(left + 1, right - 1).\n\nTo solve the problem, call helper function passing the head and tail indexes\nas arguments: return helper(0, len(s) - 1).\n\nComplexity Analysis\nTime complexity: O(N) time to perform N/2 swaps, O(n/2) == O(1/2 * n), get rid from constant\nSpace complexity: O(N) to keep the recursion stack.\n*/\nfunction helper(s, left, right) {\n  if (left >= right) return;\n\n  let temp = s[left];\n  s[left] = s[right];\n  s[right] = temp;\n  helper(s, left + 1, right - 1)\n}\n\nfunction helperVariant1(s, left, right) {\n  if (left >= right) return;\n\n  let temp = s[left];\n  s[left++] = s[right];\n  s[right--] = temp;\n  helper(s, left, right)\n}\n\nvar reverseStringRecursion = s => {\n  helper(s, 0, s.length - 1);\n}\n\n// recursion another variant\nvar reverseStringRecursionVariant2 = s => {\n  if (s.length === 0) return;\n\n  let temp = s[0];\n  s.shift();\n  reverseStringRecursionVariant2(s);\n  s.push(temp);\n}\n\n/*\nTwo pointers approach\n\nIn this approach, two pointers are used to process two array elements at the same time.\nUsual implementation is to set one pointer in the beginning and one at the end\nand then to move them until they both meet.\n\nAlgorithm\nSet pointer left at index 0, and pointer right at index n - 1,\nwhere n is a number of elements in the array.\n\nWhile left < right: Swap s[left] and s[right].\nMove left pointer one step right, and right pointer one step left.\n\nTime complexity: O(N) to swap N/2 element.\nSpace complexity: O(1), it's a constant space solution.\n*/\n\n/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n*/\nvar reverseStringTwoPointersUseTemp = function(s) {\n  if (s.length === 1) return s;\n\n  let left = 0;\n  let right = s.length - 1;\n\n  while (left < right) {\n    let temp = s[left];\n    s[left] = s[right];\n    s[right] = temp;\n    left++;\n    right--;\n  }\n};\n// console.log('reverseStringTwoPointersUseTemp', reverseStringTwoPointersUseTemp(['t','h','e']);\n\n// Using destructuring assignment array matching available in ES6+ though not\n// very efficient.\nvar reverseStringTwoPointers = s => {\n  if (s.length === 1) return s;\n\n  let i = 0;\n  let j = s.length - 1;\n\n  while (i < j) {\n    [s[i], s[j]] = [s[j], s[i]];\n    i++;\n    j--;\n  }\n}\n// const t = reverseStringTwoPointers(['t', 'h', 'e']);\n// console.log('reverseStringTwoPointers', t)\n\nexport {\n  reverse, reverseVariant2,\n  reverseStringRecursion, reverseStringRecursionVariant2, helperVariant1,\n  reverseStringTwoPointersUseTemp, reverseStringTwoPointers\n}\n","/**\n * There are 2 string. Define if they are anagram\n * Two words are anagrams of one another if their letters can be rearranged to form the other word.\n *\n * @param {*} str1\n * @param {*} str2\n * @return {boolean}\n*/\n\nfunction defineAnagrams(str1, str2) {\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\n    throw new Error('defineAnagrams requires two strings to be passed');\n  }\n\n  if ( str1 === '' || str2 === '') return 'empty strings';\n\n  const len1 = str1.length;\n  const len2 = str2.length;\n  let obj = {}; // hash\n\n  if (len1 !== len2) return false;\n\n  if (len1 === len2) {\n    const normalizedStr1 = str1.replace(/[^A-Za-z]+/g, '').toLowerCase();\n    const normalizedStr2 = str2.replace(/[^A-Za-z]+/g, '').toLowerCase();\n\n    for (let i = 0; i < len1; i++) {\n      const index = normalizedStr1.charCodeAt(i)-97;\n      obj[index] = (obj[index] || 0) + 1;\n     }\n\n    for (let j = 0; j < len2; j++) {\n      const index = normalizedStr2.charCodeAt(j)-97;\n      if (!obj[index]) return false;\n      else {\n        obj[index]--;\n      }\n    }\n\n    const isStringAnagram = Object.values(obj).every(val => val === 0);\n    return isStringAnagram;\n  }\n}\n\nexport { defineAnagrams }\n","/**\n * Given two strings, a and b, that may or may not be of the same length,\n * determine the minimum number of character deletions required to make a and b anagrams.\n * Any characters can be deleted from either of the strings.\n * For example, if a = cde and b = dcf, we can delete e from string a and\n * f from string b so that both remaining strings are  and  which are anagrams.\n */\nfunction makingAnagrams(str1, str2) {\n  const len1 = str1.length\n  const len2 = str2.length;\n  const obj1 = {};\n  const obj2 = {};\n\n  for (let i=0; i < len1; i++) {\n    obj1[str1[i]] = obj1[str1[i]] ? obj1[str1[i]] + 1 : 1;\n  }\n\n  for (let j=0; j < len2; j++) {\n    obj2[str2[j]] = obj2[str2[j]] ? obj2[str2[j]] + 1 : 1;\n  }\n\n  for (let i =0; i<len1; i++) {\n    if (obj2.hasOwnProperty(str1[i])) {\n      obj2[str1[i]]--;\n      if (obj2[str1[i]] === 0) {\n        delete obj2[str1[i]]\n      }\n    }\n  }\n\n  for (let j=0; j< len2; j++) {\n    if (obj1.hasOwnProperty(str2[j])) {\n      obj1[str2[j]]--;\n      if (obj1[str2[j]] === 0) {\n        delete obj1[str2[j]];\n      }\n    }\n  }\n\n  const arr1 = Object.values(obj1);\n  const arr2 = Object.values(obj2);\n  const sum1 = ((arr1.length > 0) && arr1.reduce((a,b) => a + b)) || 0;\n  const sum2 = ((arr2.length > 0) && arr2.reduce((a,b) => a+b)) || 0;\n  const sum = sum1 + sum2;\n\n  return sum;\n}\n\nexport { makingAnagrams }\n","/**\n * You are given a string containing characters A and B only.\n * Your task is to change it into a string such that there are no matching adjacent characters.\n *  To do this, you are allowed to delete zero or more characters in the string.\n *\n*/\n\nfunction alternatingCharacters(s) {\n  let arr = s.split('');\n  const len = arr.length - 1;\n  let deletions = 0;\n\n\n  for (let index = 0; index < len; index++) {\n    if (arr[index] === arr[index + 1]) {\n      deletions++;\n    }\n  }\n\n  return deletions;\n}\n\nfunction alternatingCharactersVariant1(s) {\n  let deletions = 0;\n\n  s.split('').map((char, i) => {\n    if (char[i] === char[i+1]) deletions++;\n    return deletions;\n  })\n}\n\nexport { alternatingCharacters, alternatingCharactersVariant1 }\n","/**\n * Sherlock considers a string to be valid if all characters of the string\n * appear the same number of times.\n *\n*/\nexport const count = (list, value) => {\n  return list.filter((x) => x === value).length\n}\n\nfunction isValid(s) {\n  const arr = s.split('');\n  const len = arr.length;\n  let letters = {};\n\n  for (let i = 0; i < len; i++) {\n    const element = arr[i];\n    letters[element] = (letters[element] || 0) + 1;\n  }\n\n  const values = Object.values(letters);\n  const valMax = Math.max(...values)\n  const valMin = Math.min(...values);\n\n  const countMax = count(values, valMax);\n  const countMin = count(values, valMin);\n  let isValid = false;\n\n  if (\n    (valMax === valMin) ||\n    (valMax - valMin === 1 && countMax === 1) ||\n    (valMin === 1 && countMin === 1 && [...new Set(values)].length === 2)\n  ) {\n    isValid = true\n  }\n\n  return isValid === true ? 'Yes' : 'No';\n}\n\nfunction isValidVariant1(s) {\n  let h = {};\n  let res = \"Yes\";\n  let arr = [];\n  let count = 0;\n\n  for (let char of s) {\n    h[char] = h[char]+1 || 1; // if any char appear more than once, value will increment;\n  }\n\n  Object.values(h).map(v => {\n    arr.push(v);\n    // if any value is different than first value;\n    if ( v !== arr[0] ){\n      count++;  // count how many values are different\n      if( (v > arr[0]) && (v-1 !== arr[0]) ){\n        res = \"No\";\n      } else if ( (v < arr[0]) &&  (v !== (arr[0]-1)) ){\n        console.log(v, arr[0])\n        res = \"Yes\"\n      }\n    }\n    return res = \"No\";\n  })\n\n  if (count > 1) res = \"NO\"; // if more than one values are different\n  if (count === 1) res = \"YES\"; // if only one value is different\n  return res;\n}\n\nexport { isValid, isValidVariant1 }\n\n","/**\n * Leetcode\n * 771 Number Jewels in stones\n * Easy\n *\n * You're given strings J representing the types of stones that are jewels,\n * and S representing the stones you have.\n * Each character in S is a type of stone you have.\n * You want to know how many of the stones you have are also jewels.\n *\n * The letters in J are guaranteed distinct,\n * and all characters in J and S are letters.\n * Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n *\n * Hint:\n * For each stone, check if it is a jewel.\n */\n\n/**\n * Approach 1: Brute force\n *\n * Time complexity: O(J.length * S.length)\n * Space complexity O(1) additional space complexity in Python.\n * In Java, this can be O(J.lengthS.length)) because of the creation of new arrays.\n */\nvar numJewelsInStonesBruteForce = function(J,S) {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) { // for each stone\n    for (let j = 0; j < J.length; j++) { // for each jewel\n      if (J.charAt(j) === S.charAt(i)) { // if the stone is a jewel...\n        count++;\n        break; // stop searching whether this stone 's' is a jewel\n      }\n    }\n  }\n  return count;\n}\n\n/**\n * Approach 2 hash set\n *\n * Time Complexity: O(J.length + S.length)).\n * The O(J.length) part comes from creating J.\n * O(S.length) part comes from searching S.\n *\n * Space Complexity: O(S.length)\n */\n var numJewelsInStones = function(J, S) {\n  let count = 0;\n  if ((S.length || J.length) === 0) {\n    count = 0\n  }\n\n  const jewels = J.split('');\n  const stones = S.split('');\n  const hash = {}\n\n  for (let i = 0; i < S.length; i++) {\n    const stone = stones[i];\n    hash[stone] = hash[stone] ? hash[stone] + 1 : 1\n  }\n\n  for (let j = 0; j < J.length; j++) {\n    const jewel = jewels[j];\n    if (hash[jewel]) {\n      count = count + hash[jewel]\n    }\n  }\n\n  return count;\n};\n\nvar numJewelsInStonesUseForIn = function(J, S) {\n  let hash = {};\n  let count = 0;\n\n  for (let j in J) {\n    hash[J[j]] = j\n  }\n\n  for (let i in S) {\n    if (hash[S[i]]) {\n      count++\n    }\n  }\n  return count\n};\n\n// use includes\nvar numJewelsInStonesUseIncludes = function(J, S) {\n  if (!J || !S) {\n    return 0\n  }\n\n  let count = 0;\n  for (const char of S) {\n    if (J.includes(char)) count++\n  }\n\n  return count;\n}\n\n// use indexOf method\n// Actually, due to indexOf being a loop under the hood,\n// this is quadratic (O(n2)) time complexity = O(J.length * S.length), when it could be linear O(n)\nvar numJewelsInStonesUseIndexOf = function(J, S) {\n  if (!J || !S) {\n    return 0\n  }\n\n  let result = 0;\n  for (let i = 0; i < S.length; i++) {\n   if ( J.indexOf(S.charAt(i)) !== -1 ) result++\n  }\n\n  return result;\n}\n\n// use filter\nvar numJewelsInStonesUseFilter = function(J, S) {\n  return [...S].filter((char) => J.indexOf(char) > -1 ).length\n}\n\n// reduce and set\n// This is O(S) space and time - could be taken down to O(J) space by normal iteration.\nconst numJewelsInStonesUseSet = (J, S) => {\n  const jewels = new Set(J);\n  return S.split('').reduce((res, s) => res + jewels.has(s), 0);\n};\n\nconst numJewelsInStonesUseReduce = (J, S) => {\n  const set = new Set(J);\n  return S.split('').reduce(\n    (count, curr) => (set.has(curr) ? ++count : count),\n    0\n  );\n};\n\nexport {\n  numJewelsInStones,\n  numJewelsInStonesBruteForce,\n  numJewelsInStonesUseForIn,\n  numJewelsInStonesUseIncludes,\n  numJewelsInStonesUseIndexOf,\n  numJewelsInStonesUseFilter,\n  numJewelsInStonesUseSet,\n  numJewelsInStonesUseReduce\n}\n","/**\n * Leetcode\n * 387 First Unique Character in a String\n * easy\n *\n * Given a string, find the first non-repeating character in it and return it's index.\n * If it doesn't exist, return -1.\n *\n * Note: You may assume the string contain only lowercase letters.\n *\n * Approach linear time solution\n * The best possible solution here could be of a linear time\n * because to ensure that the character is unique you have to check the whole string anyway.\n *\n * Time complexity : O(N) since we go through the string of length N two times.\n * Space complexity : O(N) since we have to keep a hash map with N elements.\n */\nvar firstUniqueChar = function(s) {\n  const frequencies = {};\n\n  for (const char of s) {\n    frequencies[char] = (frequencies[char] || 0) + 1;\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    // first non-repeating character\n    if (frequencies[char] === 1) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Calculate unique symbols in string\n *\n * time O(n)\n * space O(n)\n*/\nvar countSymbols = function(str) {\n  let map = new Map();\n  let keys = [];\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    let newValue = 1;\n\n    if (map.has(char)) {\n      newValue += map.get(char)\n    }\n    map.set(char, newValue)\n  }\n\n  for (let key of map) {\n    keys.push(key[0]);\n  }\n\n  return keys;\n}\n\n\nexport { firstUniqueChar, countSymbols }\n","/**\n * Leetcode\n * medium\n * 438. Find All Anagrams in a String\n *\n * Given a string s and a non-empty string p,\n * find all the start indices of p's anagrams in s.\n *\n * Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n * The order of output does not matter.\n *\n * Example 1:\n * Input: s: \"cbaebabacd\" p: \"abc\"\n * Output: [0, 6]\n *\n * Explanation:\n * The substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\n * The substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\n *\n * Example 2:\n * Input: s: \"abab\" p: \"ab\"\n * Output: [0, 1, 2]\n *\n * Explanation:\n * The substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\n * The substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\n * The substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\n *\n * Explanation:\n * it's not about anagrams, but permutation\n * sliding window approach.\n *\n * This is a problem of multiple pattern search in a string.\n * All such problems usually could be solved by sliding window approach in a linear time.\n * The challenge here is how to implement constant-time slice to fit into this linear time.\n *\n * If the patterns are not known in advance, i.e. it's \"find duplicates\" problem,\n * one could use one of two ways to implement constant-time slice: Bitmasks or Rabin-Karp.\n * Please check article Repeated DNA Sequences for the detailed comparison of these two algorithms.\n *\n * Here the situation is more simple: patterns are known in advance, and the set of characters in the patterns\n * is very limited as well: 26 lowercase English letters.\n * Hence one could allocate array or hashmap with 26 elements\n * and use it as a letter counter in the sliding window.\n *\n*/\n\n\n/*\n  Approach Sliding Window + 2 counter HashMaps\n\n  Let's start from the simplest approach: sliding window + two counter hashmaps\n  letter -> its count.\n  The first hashmap is a reference counter pCount for string p,\n  and the second one is a counter sCount for string in the sliding window.\n\n  The idea is to move sliding window along the string s,\n  recompute the second hashmap sCount in a constant time\n  and compare it with the first hashmap pCount.\n\n  If sCount == pCount, then the string in the sliding window is a permutation\n  of string p, and one could add its start position in the output list.\n\n  Algorithm\n  - Initialize 2 hashes: build reference counter pCount for string p, counter sCount for string s\n\n  - Move sliding window along the string s:\n  Recompute sliding window counter sCount at each step by adding one letter on the right\n  and removing one letter on the left.\n\n  - If sCount == pCount, update the output list.\n  - Return output list.\n\n  Complexity analysis\n\n  Time complexity: O(N_s + N_p) since it's one pass along both strings.\n  Space complexity: O(1), because pCount and sCount contain 26 elements each.\n*/\n\n\n\n/**\n * @param {{}} s\n * @param {{}} p\n * @return {boolean}\n*/\nconst compareDict = (dictA, dictB) => {\n  for (let keyA in dictA) {\n    if (dictA[keyA] && dictA[keyA] !== dictB[keyA]) {\n      return false;\n    }\n  }\n\n  for (let keyB in dictB) {\n    if (dictB[keyB] && dictB[keyB] !== dictA[keyB]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n*/\nvar findAnagramsUseTwoHash = function(s, p) {\n  let result = [];\n\n  if (p == null || s == null || s.length === 0 || p.length > s.length) {\n    return result;\n  }\n\n  // init 2 maps\n  let pCounter = {};\n  let sCounter = {};\n  for (let i = 0; i < p.length; i++) {\n    pCounter[p[i]] = (pCounter[p[i]] || 0) + 1; // java pCounter[p.charAt(i) - 'a']++;\n    sCounter[s[i]] = (sCounter[s[i]] || 0) + 1; // sCounter[s.charAt(i) - 'a']++;\n  }\n\n  let left = 0;\n  let right = p.length;\n\n  // move 2 pointers\n  // <= is necessary, check case ('ab', 'ba')\n  while (right <= s.length) {\n    if (compareDict(pCounter, sCounter)) {\n      result.push(left)\n    }\n\n    // adding one letter on the right\n    sCounter[s.charAt(right)] = (sCounter[s.charAt(right)] || 0) + 1;\n    right++;\n\n    // removing one letter on the left\n    sCounter[s.charAt(left)]--;\n    left++;\n  }\n\n  return result;\n}\n\n// The same approach but using a map\nvar findAnagramsUseMap = function(s, p) {\n  let anagrams = [];\n  if (p == null || s == null || s.length === 0 || p.length > s.length) {\n    return anagrams;\n  }\n\n  const map = new Map();\n\n  for (let i = 0; i < p.length; i++) {\n    if (map.has(p.charAt(i))) {\n      map.set(p.charAt(i), map.getChart(i) + 1);\n    } else {\n      map.set(p.charAt(i), 1);\n    }\n  }\n\n  let left = 0;\n  let right = 0;\n  let counter = map.size;\n\n  while (right < s.length) {\n    const endChar = s.charAt(right);\n    if (map.has(endChar)) {\n      map.set(endChar, map.get(endChar) - 1);\n      if (map.get(endChar) === 0) counter--;\n    }\n    right++;\n\n    while (counter === 0) {\n      if (right - left === p.length) {\n        anagrams.push(left)\n      }\n\n      const startChar = s.charAt(left);\n      if (map.has(startChar)) {\n        map.set(startChar, map.get(startChar) + 1);\n        if (map.get(startChar) > 0) counter++;\n      }\n      left++\n    }\n\n  }\n\n  return anagrams;\n};\n\n\n// todo it seems it's not an approach 1\nvar findAnagramsUseWhileLoop = function(s, p) {\n  let anagrams = [];\n  if (s === null || s === undefined || s.length === 0) {\n    return []\n  }\n\n  let pCounter = {};\n\n  // populate pCounter - frequency letter\n  for (let i = 0; i < p.length; i++) {\n    pCounter[p[i]] = (pCounter[p[i]] || 0) + 1;\n  }\n\n  // sliding window approach, we gonna have 2 bounds\n  let left = 0;\n  let right = 0;\n  let count = p.length;\n\n  // right hit the boundary first\n  while (right < s.length) {\n    if ( pCounter[s.charAt(right++)]-- >= 1 ) count--;\n\n    // found index\n    if (count === 0) anagrams.push(left);\n\n    // don't understand this string\n    if (right - left === p.length && pCounter[s.charAt(left++)]++ >= 0) count++;\n  }\n\n  return anagrams;\n}\n\n// todo\nvar findAnagrams = function(s, p) {\n  let pCounter = {};\n  let anagrams = [];\n\n  if (s === null || s === undefined || s.length === 0) {\n    return []\n  }\n\n  for (let i = 0; i < p.length; i++) {\n    pCounter[p[i]] = (pCounter[p[i]] || 0) + 1;\n  }\n\n  //console.log('p', pCounter);\n\n  let left = 0,\n    right = 0,\n    count = p.length;\n\n  while (right < s.length) {\n    if (pCounter[s[right]] !== undefined) {\n      pCounter[s[right]]--;\n      if (pCounter[s[right]] === 0) {\n        count--;\n      }\n    }\n    right++;\n\n    while (count === 0) {\n      if (pCounter[s[left]] !== undefined) {\n        pCounter[s[left]]++;\n        if (pCounter[s[left]] > 0) {\n          count++;\n        }\n      }\n      if (right - left === p.length) {\n        anagrams.push(left);\n      }\n      left++;\n    }\n  }\n  return anagrams;\n};\n\n\n// public IList<int> FindAnagrams(string s, string p)\n// {\n\n//     List<int> res = new List<int>();\n//     if (s.Length < p.Length)\n//         return res;\n\n//     // chars needed to form an anagram\n//     Dictionary<char, int> need = new Dictionary<char, int>();\n//     foreach (char c in p)\n//     {\n//         if (need.ContainsKey(c))\n//             need[c]++;\n//         else\n//             need.Add(c, 1);\n//     }\n\n//     int left = 0, right = 0; // left and right boundary of the sliding window\n//     int counter = need.Count; // number of unique char needed to form an anagram\n//     while (right < s.Length)\n//     {\n//         char currChar = s[right];\n//         if (need.ContainsKey(currChar))\n//         {\n//             // decrease needed currChar when it is included in the sliding window\n//             need[currChar]--;\n\n//             // need[currChar] = 0, sliding window has the exact number of [currChar] needed to form an anagram\n//             // need[currChar] > 0, sliding window has less [currChar] than needed to form an anagram\n//             // need[currChar] < 0, sliding window has more [currChar] than needed to form an anagram\n//             if (need[currChar] == 0)\n//                 counter--;\n//         }\n//         right++;\n\n//         // counter == 0 means all the needed chars to form an anagram are within the sliding window\n//         // since the silding window may or may not have unnecessary chars, we need the shrink it.\n//         while (counter == 0)\n//         {\n//             // when the size of the sliding window == p.Length, an anagram is founded\n//             if (right - left == p.Length)\n//                 res.Add(left);\n\n//             // move the left boundary to shrink the sliding window\n//             // before moving the left boundary, we need to update need<char, int>\n//             char charLeft = s[left];\n//             if (need.ContainsKey(charLeft))\n//             {\n//                 need[charLeft]++; // incrase the needed charLeft since it will be removed from the sliding window\n//                 if (need[charLeft] > 0) // sliding window has less [charLeft] than needed to form an anagram\n//                     counter++;\n//             }\n//             left++;\n//         }\n//     }\n\n//     return res;\n// }\n\n\n\n//console.log(findAnagrams('cbaebabacd', 'abc'));\n//console.log(findAnagrams('abc', 'abc'));\n\n\n// /**\n//  * @param {string} str\n//  * @param {string} pattern\n//  * @return {number[]}\n//  */\n// var findAnagrams = function(str, pattern) {\n//   // Convert pattern string to hash-map.\n//   const patternMap = wordToMap(pattern);\n\n//   // Array that will hold our anagram start indices.\n//   const patternIndices = [];\n\n//   // Clone the pattern string map for further modifications.\n//   let currentPatternMap = {...patternMap};\n\n//   // We'll be using sliding frame to find anagrams.\n//   let frameStart = 0;\n//   let frameLength = 0;\n//   let wordIndex = 0;\n\n//   // Go through all letters in a string.\n//   while (wordIndex < str.length) {\n//     // Get current letter.\n//     const letter = str[wordIndex];\n\n//     // Depending on the current letter we may have several cases.\n//     if (!currentPatternMap.hasOwnProperty(letter)) {\n//       // No such letter in the pattern.\n\n//       // Reset letters counter.\n//       currentPatternMap = {...patternMap};\n//       // Reset and shift the frame to the next letter.\n//       frameStart = wordIndex + 1;\n//       frameLength = 0;\n//     } else if (currentPatternMap[letter] === 0) {\n//       // There is no unused letter instances left.\n\n//       // Add the first letter of the found anagram back to the map.\n//       const letterToRelease = str[frameStart];\n//       currentPatternMap[letterToRelease] += 1;\n\n//       // Shift frame right and reduce it.\n//       frameLength -= 1;\n//       frameStart += 1;\n//     } else {\n//       // The letter is in the pattern and we may use it.\n\n//       // Reduce the number of used letter instances and expand the frame.\n//       currentPatternMap[letter] -= 1;\n//       frameLength += 1;\n\n//       // If we've found an anagram...\n//       if (frameLength === pattern.length) {\n//         // Remember the start of the anagram.\n//         patternIndices.push(frameStart);\n\n//         // Add the first letter of the found anagram back to the map.\n//         const letterToRelease = str[frameStart];\n//         currentPatternMap[letterToRelease] += 1;\n\n//         // Shift frame right and reduce it.\n//         frameLength -= 1;\n//         frameStart += 1;\n//       }\n//     }\n\n//     // Go to the next letter.\n//     wordIndex = frameStart + frameLength;\n//   }\n\n//   // Return anagram indices that we've found.\n//   return patternIndices;\n// };\n\n// // Function that converts string to string map (counts the number of letters).\n// function wordToMap(str) {\n//   return Array.from(str).reduce((stringMap, letter) => {\n//     if (!stringMap.hasOwnProperty(letter)) {\n//       stringMap[letter] = 1;\n//     } else {\n//       stringMap[letter]++;\n//     }\n\n//     return stringMap;\n//   }, {});\n// }\n\nexport {\n  compareDict,\n\n  findAnagramsUseTwoHash,\n  findAnagramsUseMap,\n\n  findAnagramsUseWhileLoop,\n  findAnagrams\n}\n","/*\nLeetcode\n60 Permutation sequence\nmedium\n\nThe set [1,2,3,...,n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the\nfollowing sequence for n = 3:\n\"123\"\n\"132\"\n\"213\" k = 3 // 2 + perm(1,3)\n\"231\"\n\"312\" // 3 + perm(1,2)\n\"321\" // 3 + perm(1,2)\n\nGiven n and k, return the kth permutation sequence.\n\nNote:\nGiven n will be between 1 and 9 inclusive.\nGiven k will be between 1 and n! inclusive.\n\nExample 1:\nInput: n = 3, k = 3\nOutput: \"213\"\n\n\nExample 2:\nInput: n = 4, k = 9\nOutput: \"2314\"\n*/\n\n/*\nApproach brute force\n\nwe can calculate every single permutations,\nit's not too hard\nand just return kth sequence in the list\nBut that's can take n! time complexity\n*/\n\n\n/*\nApproach Math\n\nwe now it's sorted.\n\nsay n = 4, you have {1, 2, 3, 4}, k = 14\n\nstep 1\nIf you were to list out all the permutations you have\n\n1 + (permutations of 2, 3, 4)\n\n2 + (permutations of 1, 3, 4)\n\n3 + (permutations of 1, 2, 4)\n\n4 + (permutations of 1, 2, 3)\n\nWe know how to calculate the number of permutations of n numbers ... n!\nSo each of those with permutations of 3 numbers means there are 6 (3!) possible permutations.\nMeaning there would be a total of 24 permutations in this particular one.\n\nfirst block (all )\n1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\n1 4 2 3\n1 4 3 2\n...\n\nSo if you were to look for the (k = 14) 14th permutation, it would be in the\n3 + (permutations of 1, 2, 4) subset.\n\nTo programmatically get that, you take k = 13 (subtract 1 because of things always\nstarting at 0) and divide that by the 6 we got from the factorial, which would give\nyou the index of the number you want.\nIn the array {1, 2, 3, 4}, (k-1)/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2 (= index).\nThe array {1, 2, 3, 4} has a value of 3 at index 2. So the first number is a 3.\n\nstep 2\nThen the problem repeats with less numbers.\nThe permutations of {1, 2, 4} would be:\n\n1 + (permutations of 2, 4)\n\n2 + (permutations of 1, 4)\n\n4 + (permutations of 1, 2)\n\nBut our k is no longer the 14th, because in the previous step, we've already\neliminated the 12 4-number permutations starting with 1 and 2.\nSo you subtract 12 from k.. which gives you 1.\nProgrammatically that would be...\nk = k - (index from previous) * (n-1)! = k - 2*(n-1)! = 13 - 2*(3)! = 1\n\nIn this second step, permutations of 2 numbers has only 2 possibilities,\nmeaning each of the three permutations listed above a has two possibilities,\ngiving a total of 6. We're looking for the first one, so that would be in the\n1 + (permutations of 2, 4) subset.\n\nMeaning: index to get number from is k / (n - 2)! = 1 / (4-2)! = 1 / 2! = 0..\nfrom {1, 2, 4}, index 0 is 1\n\nso the numbers we have so far is 3, 1... and then repeating without explanations.\n\nstep 3\n{2, 4}\nk = k - (index from pervious) * (n-2)! = k - 0 * (n - 2)! = 1 - 0 = 1;\nthird number's index = k / (n - 3)! = 1 / (4-3)! = 1/ 1! = 1... from {2, 4},\nindex 1 has 4\nThird number is 4\n\nstep 4\n{2}\nk = k - (index from pervious) * (n - 3)! = k - 1 * (4 - 3)! = 1 - 1 = 0;\nthird number's index = k / (n - 4)! = 0 / (4-4)! = 0/ 1 = 0... from {2}, index 0 has 2\nFourth number is 2\n\nGiving us 3142. If you manually list out the permutations using DFS method,\nit would be 3142.\nDone! It really was all about pattern finding.\n\n...\nk = 5\nindex = 5 - 1 = 4\nfactorial = 3! = 6\nindex / factorial\n\nTime is O(n)\nThe complexity is actually O(n^2), since remove in an arrayList will take O(n) complexity.\n*/\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar getPermutation = function(n, k) {\n  let factorial = new Array(n+1);\n  let nums = [];\n  // create an array of factorial lookup\n  let sum = 1;\n\n  factorial[0] = 1;\n  for (let i = 1; i <= n; i++) {\n    sum *= i;\n    factorial[i] = sum;\n  }\n  // factorial[] = {1, 1, 2, 6, 24, ... n!} n = 4\n  // factorial[] = {1, 1, 2, 6} if n = 3\n\n  // alternative\n  // let nums = Array.from({length: n}, (v, i) => i+1);\n  for (let i = 1; i <= n; i++) {\n    nums.push(i)\n  }\n  // numbers = {1, 2, 3, 4} if n =4\n  // numbers = {1, 2, 3} if n =3\n\n  // because starts from 0\n  k--;\n\n  let res = '';\n  for (let i = 1; i <= n; i++) {\n    let index = Math.floor(k / factorial[n-i]); // decide to use which permutation set\n    res += nums[index];\n    // remove index\n    // The splice() method changes the contents of an array by removing or\n    // replacing existing elements and/or adding new elements in place.\n    if (index > -1) {\n      nums.splice(index, 1);\n    }\n\n    k -= index * factorial[n-i]; //\n  }\n\n  // for (let i = n; i>0; i--) {\n  //   let index = Math.ceil(k / factorial[i - 1]); // decide to use which permutation set\n  //   //debugger;\n  //   // index 2, index 2, index 1, index 1\n  //   res += nums[index - 1];\n  //   nums.splice(index - 1, 1);\n  //   k -= (factorial[i-1] * (index - 1)); // k = 3, k = 1, k = 1, k = 1\n  // }\n\n\n  return res;\n};\n\n// todo\n// var getPermutation = function(n, k) {\n//   var fact=[];\n//   var l=[];\n//   fact[0]=1;\n//   for(var i=1;i<n;i++)\n//   {\n//     fact[i]=i*fact[i-1];\n//   }\n//   for(var i=1;i<=n;i++) {\n//     l.push(i);\n//   }\n//   k--;\n//   var s=\"\";\n//   for(i=n-1;i>=0;i--)\n//   {\n//     var index=Math.floor(k/fact[i]);\n// \ts=s+\"\"+l.splice(index,1)[0];\n// \tk=k%fact[i];\n//   }\n//   return s;\n// };\n\n\nconsole.log('getPermutation', getPermutation(4, 9))\n\nexport {\n  getPermutation\n}\n","/**\n * Leetcode javascript\n * 383 Ransom note\n * easy\n *\n * Given an arbitrary ransom note string and another string containing letters from all the magazines,\n * write a function that will return true if the ransom note can be constructed from the magazines;\n * otherwise, it will return false.\n *\n * Each letter in the magazine string can only be used once in your ransom note.\n *\n * Note:\n * You may assume that both strings contain only lowercase letters.\n*/\nvar canConstruct = function(ransomNote, magazine) {\n  const len1 = magazine.length;\n  const len2 = ransomNote.length;\n  const hash = {};\n\n  // you don't need to split the strings into an array of characters. Array notation works fine on strings, as Javascript stores strings as a list of characters anyways.\n  for (let i = 0; i < len1; i++) {\n    const char = magazine[i];\n    hash[char] = (hash[char] || 0) + 1;\n  }\n\n  for (let j = 0; j < len2; j++) {\n    hash[ransomNote[j]] = (hash[ransomNote[j]] || 0) - 1;\n    if (hash[ransomNote[j]] < 0) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// to check\nvar canConstruct1 = function(ransomNote, magazine) {\n  if ( ransomNote.length > magazine.length ) return false;\n  const oldMagazineLength = magazine.length;\n  ransomNote.split('').forEach(item => {\n      magazine = magazine.replace(item, '');\n  });\n  return oldMagazineLength == magazine.length + ransomNote;\n};\n\n// Microsoft | OA 2019 | String Without 3 Identical Consecutive Letters\n// microsoft\n//Write a function solution that, given a string S of N lowercase English letters,\n// returns a string with no instances of three identical consecutive letters,\n// obtained from S by deleting the minimum possible number of letters\n// Examples: Given S = eedaaad , the function should return eedaad .\n// One occurrence of letter a is deleted.\n\nvar noThreeIdenticalLetters = function(s) {\n  const letters = {};\n\n  for (const letter of s) {\n    letters[letter] = (letters[letter] || 0) + 1\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (letters[char] >= 3) {\n      const firstIndex = s.indexOf(char);\n      const lastIndex = i;\n      const substr = s.substring(firstIndex, lastIndex+1);\n      const substr1 = substr.slice(0,2);\n      console.log('substr', substr)\n      console.log('substr1', substr1)\n      // return begin str + cutted + end\n      // console.log('index', i);\n      // console.log('char', char);\n\n    }\n  }\n\n  // s.slice(firstIndex, firstIndex + 2)\n  // s.substring(firstIndex, 5+1)\n  console.log('letters', letters)\n\n  return s\n}\n\n//console.log(noThreeIdenticalLetters('eedaaad'))\n//given S=uuuuxaaaaxuuu the function should return uuxaaxuu\n\n/**\n * 1232\n * easy\n * Hint 1 If there're only 2 points, return true.\n * 2 Check if all other points lie on the line defined by the first 2 points.\n * 3 Use cross product to check collinearity.\n */\n\n/**\n * @param {number[][]} coordinates\n * @return {boolean}\n*/\n\n// var onLine = function() {\n\n// }\n\n// Straight line\n// tan\n// The point is if we take points p1(x, y), p2(x1, y1), p3(x3, y3), slopes of any two pairs is same then p1, p2, p3 lies on same line.\n// slope from p1 and p2 is y - y1 / x - x1\n// slope from p2 and p3 is y2 - y1 / x2 - x1\n// if these two slopes equal, then p1, p2, p3 lies on same line.\n\n// IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK\n// IF YOU UNDERSTAND, DON'T FORGET TO UPVOTE\n/**\n *\n * It is very straight forward. Just compute slope from the first points. If all the points are on the same line, their slope from the first point will be the same. Our point is defined by an array in the formate of [x,y].\n */\n\nvar checkStraightLine = function(coordinates) {\n  const len = coordinates.length;\n  // there are only two points\n  if (len === 2) {\n    return true\n  }\n\n  const x1 = coordinates[0][0],\n    y1 = coordinates[0][1],\n    x2 = coordinates[1][0],\n    y2 = coordinates[1][1],\n    k = (y2 - y1) / (x2 - x1);\n\n  for (let i = 2; i < len; i++) {\n    let localK = (coordinates[i][1] - y1) / (coordinates[i][0] - x1);\n    if (localK !== k) {\n      return false\n    }\n  }\n\n  return true\n};\n\n// true case coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]\n//console.log(checkStraightLine([[1,2],[2,3]]))\n//console.log(checkStraightLine([[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]));\n\ncheckStraightLine([[1,2],[2,3]])\n// checkStraightLine([[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]])\n// add for coordiantes 2 solution: with tangens and y = ax+ b, JS, Moore's approach (famous voting algorithm) with comments/explanation\n\n// move to binary search\n// 777\n// perfect square\n/**\n *\n * Given a positive integer num, write a function which returns\n * True if num is a perfect square else False.\n * Note: Do not use any built-in library function such as sqrt.\n *\n *\n*/\n//1 = 1\n//4 = 1 + 3\n//n^{2}=1+1+2+2+...+(n-1)+(n-1)+n\n// 16 = 4^2\n//\n\n// 1 even\n// let n = 25\n// 25 = 5 * 5\n// 100 = 10 * 10 = 2*5 * 2*5\n// time O(sqrt n) brute force\n// 10\nvar isPerfectSquare = function(num) {\n  for (let i = 1; i < num; i++) {\n    if ( i*i < num ) i++\n    else {\n      if (i*i === num) return true\n    }\n  }\n\n  return false\n};\n\n// efficient\n// n = 16\n// binary search\n\n// complexity\n// let N <= 10^10\n// low = 1\n// high = 10\n// mid = 5\n// sqrt n = 10 ^ 2\n// log sqrt n = 5\nvar isPerfectSquareBinarySearch = function(num) {\n  let left = 1;\n  let right = num;\n\n  while (left <= right) {\n    let mid = Math.floor(left + (right - left)/2);\n    let square = mid * mid;\n\n    if (square === num) {\n      return true\n    }\n    else if (square < num) {\n      left = mid + 1\n    } else {\n      right = mid - 1\n    }\n  }\n  return false\n};\n\n\n// console.log('isPerfectSquare1', isPerfectSquare(25))\n// console.log('isPerfectSquare', isPerfectSquare(24))\n// console.log('isPerfectSquareBinarySearch', isPerfectSquareBinarySearch(25))\n// console.log('isPerfectSquareBinarySearch', isPerfectSquareBinarySearch(24))\n\n// babolonien method\n// The babylonian method to check\n\n\n\n/**\n * 402 Remove K Digits\n *Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\n\nNote:\nThe length of num is less than 10002 and will be  k.\nThe given num does not contain any leading zero.\n *\n *\n * Input: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n\n *\n * Greedy algorithm\n *\n * explanation\n * Best possible decision on each step.\n * We gonna loop through if we wanna keep the current number or we want to delete it and go with a different number\n * short time pay off\n *\n * stack\n * linear time : loop through N and deletions\n *\n*/\n\n/*\n  remove first peek\n  peeks from left hand side\n  remove zero from beginning\n  remove previous peeks\n  asending order\n  stack - remove from top\n*/\n/**\n * @param {string} num\n * @param {number} k\n * @return {string}\n */\n// num is str\nvar removeKdigits = function(num, k) {\n  const stack = [];\n  let removed = 0;\n\n  for (const n of num) {\n    while (stack.length && n < stack[stack.length - 1] && removed < k) {\n      stack.pop();\n      removed += 1\n    }\n\n    stack.push(n)\n  }\n\n  // remove all remaining large numbers\n  while (removed < k) {\n    stack.pop()\n    removed += 1\n  }\n\n  // remove all beginning zeros\n  while (stack.length && stack[0] === '0') {\n    stack.shift()\n  }\n\n  console.log(stack.length ? stack.join('') : '0')\n  return stack.length ? stack.join('') : '0';\n}\n\n// 1129\n//console.log(removeKdigits('1432219', 3))\n\n\n// divide and conquer\n/*\nmaxSubArray for array with n numbers:\n\nIf n == 1 : return this single element.\n\nleft_sum = maxSubArray for the left subarray, i.e. for the first n/2 numbers (middle element at index (left + right) / 2 always belongs to the left subarray).\n\nright_sum = maxSubArray for the right subarray, i.e. for the last n/2 numbers.\n\ncross_sum = maximum sum of the subarray containing elements from both left and right subarrays and hence crossing the middle element at index (left + right) / 2.\nMerge the subproblems solutions, i.e. return max(left_sum, right_sum, cross_sum).\n\n*/\nconst maxSub = (nums, left, right) => {\n  if(left === right)\n      return nums[left]\n  else if(left > right)\n      return Number.NEGATIVE_INFINITY\n\n  let mid = Math.floor((left + right) / 2)\n  let lmax = maxSub(nums, left, mid - 1)\n  let rmax = maxSub(nums, mid + 1, right)\n\n  let leftExtendMaxSum = 0,\n    rightExtendMaxSum = 0;\n\n  for(let i = mid - 1, tempTotal = 0; i >= left; --i)\n      leftExtendMaxSum = Math.max(tempTotal += nums[i], leftExtendMaxSum)\n\n  for(let i = mid + 1, tempTotal = 0; i <= right; ++i)\n      rightExtendMaxSum = Math.max(tempTotal += nums[i], rightExtendMaxSum)\n\n  //console.log('max', Math.max(leftExtendMaxSum + nums[mid] + rightExtendMaxSum, lmax, rmax))\n  return Math.max(leftExtendMaxSum + nums[mid] + rightExtendMaxSum, lmax, rmax)\n}\n\nvar maxSubArrayDivide = nums => {\n  //console.log('maxSum', maxSub(nums, 0, nums.length - 1))\n  return maxSub(nums, 0, nums.length - 1);\n}\n\n// todo write a test\n//maxSubArrayDivide([-2,1,-3,4,-1,2,1,-5,4]);\n\n// approach greedy\n/*\nThe problem to find maximum (or minimum) element (or sum) with a single array as the input is a good candidate to be solved by the greedy approach in linear time. One can find the examples of linear time greedy solutions in our articles of\nSuper Washing Machines, and Gas Problem.\nhttps://leetcode.com/articles/super-washing-machines/\nhttps://leetcode.com/articles/gas-station/\n\nPick the locally optimal move at each step, and that will lead to the globally optimal solution.\n\n\n*/\n\n/* Dynamic programming\nKadans Algorithm\nThe problem to find sum or maximum or minimum in an entire array or in a fixed-size sliding window\ncould be solved by the dynamic programming (DP) approach in linear time.\n\n\n*/\n\n\n/*\n\n918 Maximum Sum Circular Subarray\nGiven a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.\n\nHere, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.)\n\nAlso, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)\n\n\n\nto find only one solution\n\n*/\n/**\n * @param {number[]} A\n * @return {number}\n*/\n// Kadane's Algorithm\nfunction maxSubarraySum(arr) {\n  let max = arr[0];\n  let prevBest = 0;\n\n  for (let n of arr) {\n    if (prevBest > 0) prevBest += n\n    else prevBest = n\n\n    if (prevBest > max) max = prevBest\n  }\n  // for (let n of arr) {\n  //   if (prevBest > 0) {\n  //     prevBest += n\n  //   } else if (prevBest > max) {\n  //     max = prevBest\n  //   } else {\n  //     prevBest = n\n  //   }\n  // }\n\n  return max;\n}\nvar maxSubarraySumCircular = function(A) {\n  const linearMax = maxSubarraySum(A);\n  const total = A.reduce((acc, cur) => acc + cur);\n  // the minumum contigious subarray sum\n  const minSubarraySum = maxSubarraySum(A.map(n => n * -1))\n  // deducts(removes) the minumum contigious subarray sum from the total;\n  const circularMax = total + minSubarraySum;\n\n  // if circularMax is 0, all nums in A are negative, thus return linearMax\n  if (circularMax === 0) return linearMax;\n  return Math.max(circularMax, linearMax);\n}\n\n// Subarray [3] has maximum sum 3\n//console.log(maxSubarraySumCircular([2, -1, 2, 0, 1, 3, 4]))\n//console.log(maxSubarraySumCircular([-1, 2, 0, 1, 3, 4]))\n\n// class Bubble {\n//   constructor() {\n//     this.x = 200;\n//     this.y = 150\n//   }\n\n//   move() {\n//     this.x = this.x + random(-5, 5);\n//     this.y = this.y + random(-5, 5);\n//   }\n\n//   show() {\n//     stroke(255);\n//     strokeWeight(4);\n//     noFill();\n//   }\n// }\n\n// const bubble = new Bubble();\n// console.log('bubble', bubble);\n\n// function setup() {\n//   createCanvas(100, 100)\n// }\n// function draw() {\n//   background();\n//   bubble1.move();\n//   bubble.show()\n// }\n\n/**\n *\n * 451\n * medium\n * Given a string, sort it in decreasing order based on the frequency of characters.\n *\n * Example 1:\n\nInput:\n\"tree\"\n\nOutput:\n\"eert\"\n\nExplanation:\n'e' appears twice while 'r' and 't' both appear once.\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\n\nExample 2:\n\nInput:\n\"cccaaa\"\n\nOutput:\n\"cccaaa\"\n\nExplanation:\nBoth 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer.\nNote that \"cacaca\" is incorrect, as the same characters must be together.\n\nExample 3:\n\nInput:\n\"Aabb\"\n\nOutput:\n\"bbAa\"\n\nExplanation:\n\"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\nNote that 'A' and 'a' are treated as two different characters.\n\n *\n * Important\n * Remember strings are immutable\n * Strings in most programming languages are immutable. This means that once a String is created, we cannot modify it. We can only create a new String\n * check case in JS!!!\n *\n */\n\n\n/**\n *\n * @param {*} str\n */\nvar sortCharacterByFrequency = (str) => {\n  // make a hush map\n  const frequency = {};\n\n  for (let i = 0; i < str.length; i++) {\n    frequency[str[i]] = (frequency[str[i]] || 0) + 1\n  }\n\n  for (const key in frequency) {\n    debugger\n  }\n\n  //console.log('frequency', frequency);\n\n}\n\n//console.log(sortCharacterByFrequency('tree')) //'eert'\n\n/**\n * 986. Interval List Intersections\n * https://leetcode.com/problems/interval-list-intersections/discuss/315908/clean-javascript-solution\n */\n\n\n/**\n * Construct Binary Search Tree from Preorder Traversal\n * 1008\n * medium\n */\n\n// var bstFromPreorder = function(preorder) {\n//   let recur = function(lower, upper) {\n//       if (preorder[0] < lower || preorder[0] > upper) return null;\n//       if (preorder.length == 0) return null;\n//       let root = new TreeNode(preorder.shift());\n//       root.left = recur(lower, root.val);\n//       root.right = recur(root.val, upper);\n//       return root;\n//   }\n//   return recur(-Infinity, Infinity);\n// };\n\nexport { canConstruct }\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco, dark } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nimport Details from './../Details';\n\n// problems\nimport { reverseVariant2, reverseStringTwoPointersUseTemp, reverseStringRecursion } from '../../ds/string-manipulation/reverse-a-string';\n// import { reverseWords } from '../../leetcode/string-manipulation/151-reverse-words';\nimport { defineAnagrams } from '../../ds/string-manipulation/define-anagrams';\nimport { makingAnagrams } from '../../ds/string-manipulation/making-anagrams';\nimport { alternatingCharacters } from '../../ds/string-manipulation/tasks/alternating-characters';\nimport { isValid } from '../../ds/string-manipulation/tasks/sherlock-valid-string';\nimport { numJewelsInStones, numJewelsInStonesBruteForce } from '../../leetcode/string-manipulation/771-number-jewels-in-stones';\nimport { firstUniqueChar } from '../../leetcode/string-manipulation/387-first-unique-character-in-string';\nimport { findAnagramsUseTwoHash } from '../../leetcode/string-manipulation/438-find-all-anagrams';\n//import { detectCapitalUse } from '../../leetcode/string-manipulation/520-detect-capital';\n\nimport { getPermutation } from '../../leetcode/backtracking/60-permutation-sequence';\nimport { permute } from '../../leetcode/backtracking/46-print-all-permutations';\n// import { longestPalindromeUseHash } from '../../leetcode/string-manipulation/palindrome/406-longest-palindrome';\nimport { checkStraightLine } from '../../leetcode/string-manipulation/383-ransom-note';\nimport { checkInclusion } from '../../leetcode/string-manipulation/567-permutation-in-string';\n\nexport default function StringManipulation() {\n  return (\n    <div className=\"sorting\">\n      <h2>String Manipulation</h2>\n\n      <ul>\n        <li>\n          <Details\n            id=\"test1\"\n            question=\"test case\"\n            //code={.toString()}\n            //secondCode={detectCapitalUse.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"reverse-a-string\"\n            question=\"Write a function that reverses a string: approach swap, recursion, two pointers\"\n            time=\"Time is O(n) for all approaches\"\n            space=\"two pointers space is O(1), recursion is O(n)\"\n            code={reverseVariant2.toString()}\n            secondCode={reverseStringTwoPointersUseTemp.toString()}\n            thirdSolution={reverseStringRecursion.toString()}\n          />\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"define-anagrams\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n            <summary role=\"button\" aria-controls=\"content\">\n              <span className=\"question\">\n                Question:&nbsp;\n                <strong>define anagrams</strong>\n              </span>\n            </summary>\n\n            <div aria-hidden=\"true\">\n              <h3 className=\"title\">Solution:</h3>\n              <p>\n                Anagrams are 2 words meaning anagrams with the same characters but in different order\n                (same exact characters but order doesnt matter).\n              </p>\n              <ul className=\"unorderedList\">\n                <li>Define hash</li>\n                <li>Increase the count for the first string.</li>\n                <li>Decrease the count for the second string. If a letter in string 2 is not found in the hash then return false.</li>\n                <li>else return true</li>\n              </ul>\n\n              <SyntaxHighlighter\n                language=\"javascript\"\n                style={dark}\n              >\n                {defineAnagrams.toString()}\n              </SyntaxHighlighter>\n            </div>\n          </details>\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"making-anagrams\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n            <summary role=\"button\" aria-controls=\"content\">\n              <span className=\"question\">\n                Question:&nbsp;\n                <strong>making anagrams</strong>\n              </span>\n            </summary>\n\n            <div aria-hidden=\"true\">\n              <h3 className=\"title\">Solution:</h3>\n              <p>\n                Given two strings, a and b, that may or may not be of the same length,\n                determine the minimum number of character deletions required to make a and b anagrams.\n                Any characters can be deleted from either of the strings.\n              </p>\n\n              <SyntaxHighlighter\n                language=\"javascript\"\n                style={docco}\n              >\n                {makingAnagrams.toString()}\n              </SyntaxHighlighter>\n            </div>\n          </details>\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"string-manipulation-tasks\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n              <summary role=\"button\" aria-controls=\"content\">Different tasks related to String Manipulation</summary>\n              <Details\n                id=\"alternating-characters\"\n                question=\"Alternating characters\"\n                solution={`\n                  Given two strings, a and b, that may or may not be of the same length,\n                  determine the minimum number of character deletions required to make a and b anagrams.\n                  Any characters can be deleted from either of the strings.\n                `}\n                code={alternatingCharacters.toString()}\n              />\n\n              <Details\n                id=\"sherlock-valid-string\"\n                question=\"Sherlock valid string\"\n                solution={`\n                  Sherlock considers a string to be valid if all characters of the string\n                  appear the same number of times and one symbol could be deleted.\n                `}\n                code={isValid.toString()}\n              />\n\n              <Details\n                id=\"numJewelsInStones\"\n                question=\"Number Jewels in stones\"\n                code={numJewelsInStones.toString()}\n                secondCode={numJewelsInStonesBruteForce.toString()}\n              />\n\n              <Details\n                id=\"firstUniqueChar\"\n                question=\"First Unique Character in a String\"\n                complexity={`\n                  The best possible solution here could be of a linear time\n                  because to ensure that the character is unique you have to check the whole string anyway.\n                `}\n                time=\"O(n)\"\n                space=\"O(n)\"\n                code={firstUniqueChar.toString()}\n              />\n\n              <Details\n                id=\"find-all-anagrams\"\n                question=\"Find all anagrams in a String: approach sliding window and 2 counter Hashes\"\n                solution={`\n                  Given a string s and a non-empty string p,\n                  find all the start indices of p's anagrams in s.\n                `}\n                time=\"O(N_s + N_p) since it's one pass along both strings\"\n                space=\"O(1) (or O(n)), because pCount and sCount contain 26 elements each\"\n                code={findAnagramsUseTwoHash.toString()}\n              />\n          </details>\n        </li>\n      </ul>\n  </div>\n  );\n}\n","/**\n * Write a function which merges two sorted arrays of integers\n * and prints result\n * runtime O(n log n)\n * Below is just merge sort algorithm\n *\n * @param {array, array}\n * @return {array} - sorted\n */\n\nconst mergeSortedArrays = (arr1, arr2) => {\n  let i = 0, // initial index for the first array\n    j = 0, // initial index for the second array,\n    result = [];\n\n  const len1 = arr1.length,\n    len2 = arr2.length;\n\n  while (i < len1 && j < len2 ) {\n    if (arr1[i] < arr2[j]) {\n      result.push(arr1[i]);\n      i++;\n    } else {\n      result.push((arr2[j]));\n      j++;\n    }\n  }\n\n  if (i < len1) {\n    result = [...result, ...arr1.slice(i)];\n  }\n\n  if (j < len2) {\n    result = [...result, ...arr2.slice(j)];\n  }\n\n  return result;\n};\n\n// other solution but also with a loop\nconst mergeSortedArrays1 = (arr1, arr2) => {\n    let i = 1,\n        j = 1,\n        firstArr1 = arr1[0],\n        firstArr2 = arr2[0],\n        merged = [];\n\n    const len1 = arr1.length,\n        len2 = arr2.length;\n\n    // case if one array is empty\n    if (len1 === 0) {\n        return arr2;\n    }\n    if (len2 === 0) {\n        return arr1;\n    }\n\n    // if firstArr1 or firstArr2 exists we will insert to merged array\n    // will go inside while loop\n    // to insert: firstArr1 exists and firstArr2 doesn't exists\n    // or both exists and firstArr1 < firstArr2\n    // this is the critical part of the example\n    while(firstArr1 || firstArr2) {\n        if ( (firstArr1 && !firstArr2) || firstArr1 < firstArr2 ) {\n            merged.push(firstArr1);\n            firstArr1 = arr1[i++];\n        } else {\n            merged.push(firstArr2);\n            firstArr2 = arr2[j++];\n        }\n    }\n\n    return merged;\n};\n\nexport { mergeSortedArrays, mergeSortedArrays1  };\n","/**\n * Clone arrays\n *\n * Approaches:\n * loop for and while (var i = a.length; while(i--) { b[i] = a[i]; })\n * slice\n * map a.map(e => e)?\n * array.from()\n * concat\n * spread operator arr2 = [...arr1];\n *\n * @param {[array]}\n * @return {[array]}\n */\n\n// runtime O(1)\n// one from fastest solutions\nconst clone = (arr) => {\n  let clone = arr.slice(0); // faster then arr.slice()\n\n  return clone;\n};\n\n\n// to add clone as a native method to arrays\n// Array.prototype.clone = function() {\n//   return this.slice(0);\n// };\n\n// don't iterate over arrays to clone them if all you need is a native clone\n// runtime O(n)\nconst cloneIterative = (arr) => {\n  let clone = [],\n    len = arr.length;\n\n  for (let index = 0; index < len; index++) {\n    // index could be any types, so you should check and if it's references type make additional manipulation\n    clone.push(arr[index]);\n  }\n\n  return clone;\n};\n\n// loop fixed size\n// runtime O(n)\nconst cloneUseLoopFixedSize = (data) => {\n  let copy = new Array(data.length),\n    len = data.length;\n\n  for (let j = 0; j < len; j++) {\n    copy[j] = data[j];\n  }\n\n  return copy;\n};\n\n// deep clone array spread\nconst cloneDeep = (clone) => {\n  return [...clone];\n};\n\nconst cloneDeepJson = (clone) => {\n  return JSON.parse(JSON.stringify(clone));\n};\n\nexport {\n  clone,\n  cloneIterative,\n  cloneUseLoopFixedSize,\n  cloneDeep,\n  cloneDeepJson\n};\n","/**\n * The girl jumps from one cloud to another, but wants to avoid the thunder clouds:\n * jumps types available = 1 space jump or 2 spaces jump\n * c = array of clouds container 1 or 0\n * 0 = regular cloud\n * 1 = thunder cloud\n */\nfunction jumpOnClouds(c) {\n  const len = c.length;\n  let jumps = 0;\n\n  for (let i = 0; i < len; i++) {\n    let nextStep = c[i+1];\n    let next2Step = c[i+2];\n\n    if (c[i] === 1) {\n      i += 1\n    } else {\n      if (nextStep === 0 && next2Step === 0) {\n        jumps += 2;\n        i = i + 2;\n      } else {\n        jumps += 1;\n        i += 1\n      }\n    }\n  }\n\n  return jumps;\n}\n\nexport { jumpOnClouds }\n","/*\nLeetcode\n169 Majority element\nmedium\n\nGiven an array of size n, find the majority element.\nThe majority element is the element that appears more than  n/2  times.\nYou may assume that the array is non-empty and the majority element always\nexist in the array.\n\nExample 1:\nInput: [3,2,3]\n\nOutput: 3\n\nExample 2:\nInput: [2,2,1,1,1,2,2]\nOutput: 2\n*/\n\n/*\nApproach 1 Brute force\n\nThe brute force algorithm iterates over the array, and then iterates again for\neach number to count its occurrences. As soon as a number is found to have\nappeared more than any other can possibly have appeared, return it.\n\nTime complexity: O(n^2)\nThe brute force algorithm contains two nested for loops that each run for n\niterations, adding up to quadratic time complexity.\n\nSpace complexity: O(1)\nThe brute force solution does not allocate additional space proportional to the\ninput size.\n*/\nvar majorityElementBruteForce = function(arr) {\n  const majorityCount = arr.length/2;\n\n  for (const num of arr) {\n    let count = 0;\n\n    for (const elem of arr) {\n      if (elem === num) {\n        count += 1\n      }\n    }\n\n    if (count > majorityCount) {\n      return num\n    }\n  }\n\n  return -1\n}\n\n\n/*\nApproach 2 Hash Map\n\nTime complexity: O(n)\nWe iterate over arr once and make a constant time HashMap insertion on each iteration.\nTherefore, the algorithm runs in O(n) time.\n\nSpace complexity: O(n)\nAt most, the HashMap can contain n - n/2 associations, so it occupies O(n) space.\nThis is because an arbitrary array of length n can contain n distinct values,\nbut arr is guaranteed to contain a majority element, which will occupy (at minimum) n/2 + 1 array indices.\n*/\nvar majorityElement = function(arr) {\n  const len = arr.length;\n\n  if (len === 0) {\n    return [];\n  }\n\n  if (len  === 1) {\n    return arr[0]\n  }\n\n  const hash = {};\n\n  for (const num of arr) {\n    hash[num] = (hash[num] || 0) + 1\n  }\n\n  for (const key in hash) {\n    if (hash[key] > len/2)  {\n      return Number(key)\n    }\n  }\n}\n\n/*\nApproach 3 Sorting\n\nIntuition\nIf the elements are sorted in monotonically increasing (or decreasing) order,\nthe majority element can be found at index n/2 or n/2 + 1 incidentally, if n is even.\n\nTime complexity: O(nlogn)\nSorting the array costs O(nlogn) time in Python and Java, so it dominates the overall runtime.\n\nSpace complexity : O(1) or O(n)\nWe sorted arr in place here - if that is not allowed, then we must spend linear additional space on a copy of nums and sort the copy instead.\n*/\nvar majorityElementSorting = function(arr) {\n  arr = arr.sort((a, b)=> a - b);\n  return arr[Math.floor(arr.length/2)]\n}\n\n/*\nApproach 6 Boyer-Moore Voting algorithm\n\nIntuition\nIf we had some way of counting instances of the majority element as +1 and\ninstances of any other element as 1, summing them would make it obvious that\nthe majority element is indeed the majority element.\n\nTo do this, we maintain a count, which is incremented whenever we see an instance\nof our current candidate and decremented whenever we see anything else.\nWhenever count equals 0, we effectively forget about everything in nums up to\nthe current index\nand consider the current number as the candidate for majority element.\n\nTime complexity: O(n)\nBoyer-Moore performs constant work exactly n times, so the algorithm runs in\nlinear time.\n\nSpace complexity: O(1)\nBoyer-Moore allocates only constant additional memory.\n*/\nvar majorityMooreVoting = function(nums) {\n  let count = 0;\n  let candidate;\n\n  for (const num of nums) {\n    if (count === 0) {\n      candidate = num\n    }\n    count += (num === candidate) ? 1 : -1\n  }\n\n  return candidate\n}\n\n// voting second solution\nconst majorityMooreVotingVariant2 = nums => {\n  if (nums.length === 0) {\n    return [];\n  }\n\n  let candidateA,\n    candidateB,\n    countA = 0,\n    countB = 0;\n  for (let index = 0; index < nums.length; index++) {\n    if (candidateA === nums[index]) {\n      countA++;\n    } else if (candidateB === nums[index]) {\n      countB++;\n    } else if (countA === 0) {\n      candidateA = nums[index];\n      countA = 1;\n    } else if (countB === 0) {\n      candidateB = nums[index];\n      countB = 1;\n    } else {\n      countA--;\n      countB--;\n    }\n  }\n\n  const elementCount = search => {\n    return nums.reduce((accumulator, currentValue) => {\n      return currentValue === search ? accumulator + 1 : accumulator;\n    }, 0);\n  };\n\n  const candidate =  candidateA === candidateB\n    ? [candidateA]\n    : [candidateA, candidateB].filter(\n      (element, index) => elementCount(element) > Math.floor(nums.length / 3)\n    );\n\n  return candidate;\n};\n\n\nexport {\n  majorityElement,\n  majorityElementBruteForce,\n  majorityMooreVoting,\n  majorityElementSorting,\n  majorityMooreVotingVariant2\n}\n","/**\n * Leetcode\n * 997 Find the Town Judge\n * easy\n *\n * In a town, there are N people labelled from 1 to N.\n * There is a rumor that one of these people is secretly the town judge.\n * If the town judge exists, then:\n * 1 The town judge trusts nobody.\n * 2 Everybody (except for the town judge) trusts the town judge.\n * 3 There is exactly one person that satisfies properties 1 and 2.\n *\n * You are given trust, an array of pairs trust[i] = [a, b] representing\n * that the person labelled a trusts the person labelled b.\n * If the town judge exists and can be identified, return the label of the town judge.\n * Otherwise, return -1.\n *\n * Example 1:\n * Input: N = 2, trust = [[1,2]]\n * Output: 2\n *\n * Example 2:\n * Input: N = 3, trust = [[1,3],[2,3]]\n * Output: 3\n *\n * Note\n * 1 <= N <= 1000\n * trust.length <= 10000\n * trust[i] are all different\n * trust[i][0] != trust[i][1]\n * 1 <= trust[i][0], trust[i][1] <= N\n *\n * Can There Be More Than One Town Judge?\n * In the problem description, we're told that iff there is a town judge, there'll only be one town judge.\n * It's likely that not all interviewers would tell you directly that there can only be one town judge.\n * If you asked them whether or not there could be more than one town judge, they might ask you if there could be.\n *\n * And the answer is... it's impossible!\n * If there were two town judges, then they would have to trust each other,\n * otherwise we'd have a town judge not trusted by everybody.\n * But this doesn't work, because town judges aren't supposed to trust anybody.\n * Therefore, we know there can be at most one town judge.\n *\n**/\n\n\n/*\n  Approach: One array\n\n  We can build a single Array with the result of indegree - outdegree for each person.\n  In other words, we'll +1 to their \"score\" for each person they are trusted by,\n  and -1 from their \"score\" for each person they trust.\n  Therefore, fpr a person to maximize their \"score\", they should be trusted by as many people as possible,\n  and trust as few people as possible.\n\n  The maximum indegree in N-1. This represents everybody trusting the person (except for themselves, they cannot trust themselves).\n  The minimum indegree is 0. This represents not trusting anybody.\n  Therefore, the maximum value for indegree - outdegree is (N - 1) - 0 = N - 1.\n  These values also happen to be definition of the town judge.\n\n  The town judge is the only person who could possible have indegree - outdegree equal to N - 1\n\n  Complexity analysis\n  Recall that N is number of people, and E is the number of edges (trusts relationships)\n  We loop over the trust list once. The cost of doing this is O(E).\n  We then loop over the people. The cost of doing this is O(N).\n  O(max(N, E) = O(N+E). After all, we don't know whether E or N is the bigger one, right?\n  However, remember how we terminate early if E < N - 1?\n  Tis means that in the best case, the time complexity is O(1).\n  And in the worst case, we know that E  N - 1. For the purpose of big-oh notation, we ignore the constant of 1.\n  Therefore, in the worst case, E has to be bigger, and so we can simply drop the N, leaving O(E).\n\n  So time complexity is O(E).\n\n  Space complexity: O(N) - allocating an array of length N\n*/\n\n/**\n * @param {number} N\n * @param {number[][]} trust\n * @return {number}\n*/\nvar findJudge = function(N, trust) {\n  if (trust.length < N-1) {\n    return -1\n  }\n\n  // initialize array with 1..N\n  // N + 1, so count is easier\n  let trustScores = Array(N+1).fill(0);\n\n  // iterate trough N people\n  for (const relation of trust) {\n    const [i, j] = relation;\n\n    // if the person trusts somebody, then it does not meet requirement 1 => once you trust someone you basically out\n    // each person loses 1 point for each person the y trust\n    trustScores[i] -= 1;\n\n    // count how much people trust you\n    // each person gains 1 point for each person they are trusted by\n    trustScores[j] += 1;\n  }\n\n  // if N-1 exists, then its the judge since the judge trusts no one except themselves\n  // and everyone else trusts the judge, then its N-1\n  for (let i = 1; i < trustScores.length; i++) {\n    if (trustScores[i] === N -1) {\n      return i\n    }\n  }\n\n  return -1;\n}\n\n/*\n  Approach: Two arrays\n\n  Intuition\n  The trust relationships form a graph. Each trust pair, [a, b] represents a directed edge going from a to b.\n\n  We can define the town judge in terms of indegree and outdegree.\n\n  In graph theory, we say the outdegree of a vertex (person) is the number of directed edges going out of it.\n  For this graph, the outdegree of the vertex represents the number of other people that person trusts.\n\n  Likewise, we say that the indegree of a vertex (person) is the number of directed edges going into it.\n  So here, it represents the number of people trusted by that person.\n\n  The town judge has an outdegree of 0 and an indegree of N - 1 because they trust nobody, and everybody trusts them (except themselves).\n\n  Therefore, this problem simplifies to calculating the indegree and outdegree for each person\n  and then checking whether or not any of them meet the criteria of the town judge.\n  We can calculate the indegrees and outdegrees for everybody, using a single loop over the input trust array.\n  We'll write the results into two arrays.\n\n  Complexity analysis\n    Time complexity is O(E) and the argument about relationship between N and E still applies.\n\n  Space complexity is O(N)\n    We allocated 2 arrays; one for the indegrees and the other for the outdegrees.\n    Each was of length N + 1. Because in big-oh notation we drop constants, this leaves us with O(N).\n*/\nvar findJudgeTwoArrays = function(N, trust) {\n  if (trust.length < N - 1) {\n    return -1;\n  }\n\n  let outdegree = Array(N+1).fill(0);\n  let indegree = Array(N+1).fill(0);\n\n  for (const [i,j] of trust) {\n    outdegree[i]++;\n    indegree[j]++;\n  }\n\n  for (let i = 1; i <=N; i++) {\n    // The town judge has an outdegree of 0 and an indegree of N - 1 because they trust nobody, and everybody trusts them (except themselves).\n    if (outdegree[i] === 0 && indegree[i] === N-1) {\n      return i\n    }\n  }\n\n  return -1;\n}\n\n\nexport { findJudge, findJudgeTwoArrays }\n","/**\n * Leetcode\n * 53 Maximum subarray\n * easy (I think medium)\n *\n * Given an integer array nums, find the contiguous subarray\n * (containing at least one number) which has the largest sum\n * and return its sum.\n *\n * Example:\n * Input: [-2,1,-3,4,-1,2,1,-5,4],\n * Output: 6\n * Explanation: [4,-1,2,1] has the largest sum = 6.\n *\n * If you have figured out the O(n) solution,\n * try coding another solution using the divide and conquer approach,\n * which is more subtle.\n *\n * Explanation:\n * input: Each number in the input array A could be positive, negative, or zero.[1]\n *\n * Some properties of this problem are:\n * 1 If the array contains all non-negative numbers, then the problem is trivial; a maximum subarray is the entire array.\n * 2 If the array contains all non-positive numbers, then a solution is any subarray of size 1 containing the maximal value of the array (or the empty subarray, if it is permitted)\n * 3 Several different sub-arrays may have the same maximum sum\n */\n\n/*\n  Approach Brute Force cubic time\n\n  We will use these outer 2 for loops to investigate all\n  windows of the array.\n\n  We plant at each 'left' value and explore every\n  'right' value from that 'left' planting.\n  These are our bounds for the window we will investigate.\n\n  Cubic solution will calculate sum of first subarray and\n  then going all way back to the left bound and calculate the sum of second subarray.\n\n  Do you see a problem here?\n  Whenever yo wanna optimize an algorithm think about BUD =\n  Bottlenecks\n  Unnecessary Work\n  Duplicate Work\n\n  We are doing duplicate work here and we can optimize it with eliminate inner most loop,\n  because we already know the subarray of previous window and we don't need\n  to calculate it again. See below.\n\n  time is O(n^3)\n  space O(1)\n*/\n\n/**\n * @param {number[]} nums\n * @return {number}\n*/\nvar maxSubArrayBruteForceCubicTime = function(nums) {\n  const len = nums.length;\n  let maxSubArraySum = -Infinity;\n\n  for (let left = 0; left < len; left++) {\n    for (let right = left; right < len; right++) {\n      // let's investigate this window\n      let windowSum = 0;\n\n      // add all items in the window\n      for (let k = left; k <= right; k++) {\n        windowSum += nums[k]\n\n      }\n      // Did we beat the best sum seen so far?\n      if (windowSum > maxSubArraySum) maxSubArraySum = windowSum;\n      // or maximumSubArraySum = Math.max(maximumSubArraySum, windowSum);\n    }\n  }\n\n  return maxSubArraySum;\n};\n\n/*\n  Approach Brute Force quadratic time\n\n  The optimization is next, we don't need to make a duplicate work,\n  we already know the sum of previous window.\n  So we just need to add next element to previous sum = just add one item.\n\n  complexity time is O(n^2) because we eliminate inner most loop\n*/\nvar maxSubArrayBruteForce = function(nums) {\n  const len = nums.length;\n  if (len === 1) return nums[0];\n\n  let maximumSubArraySum = -Infinity;\n\n\n  for (let left = 0; left < len; left++) {\n    /*\n      Reset our running window sum once we choose a new\n      left bound to plant at. We then keep a new running\n      window sum.\n    */\n    let runningWindowSum = 0;\n\n    /*\n      We improve by noticing we are performing duplicate\n      work. When we know the sum of the subarray from\n      0 to right - 1... why would we recompute the sum\n      for the subarray from 0 to right?\n      This is unnecessary. We just add on the item at\n      nums[right].\n    */\n    for (let right = left; right < len; right++) {\n      // We factor in the item at the right bound\n      runningWindowSum += nums[right];\n\n      // Does this window beat the best sum we have seen so far?\n      maximumSubArraySum = Math.max(maximumSubArraySum, runningWindowSum);\n    }\n  }\n\n  return maximumSubArraySum\n}\n\n/*\n  Approach 3 Dynamic programming (Kadane's algorithm)\n\n  linear time O(n)\n*/\n//console.log(maxSubArrayBruteForce([-2,1,-3,4,-1,2,1,-5,4]))\n//console.log(maxSubArrayBruteForce([-2,1,-3]))\n\nexport {\n  maxSubArrayBruteForceCubicTime,\n  maxSubArrayBruteForce\n}\n","/*\n  Leetcode\n  540 Single element in sorted array\n  medium\n\n  You are given a sorted array consisting of only integers where every element\n  appears exactly twice,\n  except for one element which appears exactly once.\n  Find this single element that appears only once.\n\n  Example 1:\n  Input: nums = [1,1,2,3,3,4,4,8,8]\n  Output: 2\n\n  Example 2:\n  Input: nums = [3,3,7,7,10,11,11]\n  Output: 10\n\n  Note: Your solution should run in O(log n) time and O(1) space.\n\n  Constraints:\n  1 <= nums.length <= 10^5\n  0 <= nums[i] <= 10^5\n*/\n\n\n/*\n  Approach Brute force\n\n  Intuition\n\n  We can use a linear search to check every element in the array\n  until we find the single element.\n\n  Algorithm\n  Starting with the first element, we iterate over every 2nd element,\n  checking whether or not the next element is the same as the current.\n  If it's not, then we know this must be the single element.\n\n  If we get as far as the last element, we know that it must be the single element.\n  We need to treat it as a special case after the loop,\n  because otherwise we'll be going over the end of the array.\n\n  Complexity Analysis\n  Time complexity: O(n). For linear search, we are looking at every element\n  in the array once.\n\n  Space complexity: O(1). We are only using constant extra space.\n\n  While this approach will work, the question tells us we need a O(logn) solution.\n  Therefore, this solution isn't good enough.\n*/\nvar singleNonDuplicateBruteForce = function(nums) {\n  for (let i = 0; i < nums.length - 1; i += 2) {\n    if (nums[i] !== nums[i+1]) return nums[i];\n  }\n  return nums[nums.length - 1]\n};\n\n\nvar singleNonDuplicateBruteForceVariant2 = function(nums) {\n  for (let i = 1; i <= nums.length; i += 2) {\n    if (nums[i] !== nums[i - 1]) return nums[i - 1];\n  }\n};\n\n/*\n  Approach binary search\n\n  It makes sense to try and convert the linear search into a binary search.\n  In order to use binary search, we need to be able to look at the middle item and\n  then determine whether the solution is the middle item, or to the left, or to\n  the right.\n  The key observation to make is that the starting array must always have\n  an odd number of elements (be odd-lengthed), because it has one element\n  appearing once, and all the other elements appearing twice.\n\n  An array with the elements 1, 1, 4, 4, 5, 5, 6, 6, 8, 9, 9\n\n  Here is what happens when we remove a pair from the center.\n  We are left with a left subarray and a right subarray.\n  An array with the elements 1, 1, 4, 4, 5, 5, 6, 6, 8, 9, 9. The 5's are crossed out.\n  left array: 1, 1, 4, 4\n  right array: 6, 6, 8, 9, 9\n\n  Like the original array, the subarray containing the single element must be odd-lengthed.\n  The subarray not containing it must be even-lengthed.\n  So by taking a pair out of the middle and then calculating which side is now odd-lengthed,\n  we have the information needed for binary search.\n\n  Algorithm\n  We start by setting lo and hi to be the lowest and highest index (inclusive) of the array,\n  and then iteratively halve the array until we find the single element\n  or until there is only one element left.\n  We know that if there is only one element in the search space,\n  it must be the single element, so should terminate the search.\n\n  On each loop iteration, we find mid, and determine the odd/ evenness of the sides\n  and save it in a variable called halvesAreEven.\n  By then looking at which half the middle element's partner is in\n  (either last element in the left subarray or first element in the right subarray),\n  we can decide which side is now (or remained) odd-lengthed\n  and set lo and hi to cover the part of the array we now know the single element must be in.\n\n  The trickiest part is ensuring we update lo and hi correctly based on the values of mid and halvesAreEven.\n  These diagrams should help you understand the cases.\n  When solving problems like this, it's often good to draw a diagram and think really carefully\n  about it to avoid off-by-one errors. Avoid using a guess and check approach.\n\n  Case 1: Mids partner is to the right, and the halves were originally even.\n  The right side becomes odd-lengthed because we removed mid's partner from it.\n  We need to set lo to mid + 2 so that the remaining array is the part above mid's partner.\n\n  Case 2: Mids partner is to the right, and the halves were originally odd.\n  The left side remains odd-lengthed. We need to set hi to mid - 1\n  so that the remaining array is the part below mid.\n\n  Case 3: Mids partner is to the left, and the halves were originally even.\n  The left side becomes odd-lengthed because we removed mid's partner from it.\n  We need to set hi to mid - 2 so that the remaining array is the part below mid's partner.\n\n  Case 4: Mids partner is to the left, and the halves were originally odd.\n  The right side remains odd-lengthed. We need to set lo to mid + 1\n  so that the remaining array is the part above mid.\n\n  Another interesting observation you might have made is that this algorithm\n  will still work even if the array isn't fully sorted.\n  As long as pairs are always grouped together in the array\n  (for example, [10, 10, 4, 4, 7, 11, 11, 12, 12, 2, 2]),\n  it doesn't matter what order they're in. Binary search worked for this problem\n  because we knew the subarray with the single number is always odd-lengthed,\n  not because the array was fully sorted numerically.\n  We commonly call this an invariant, something that is always true\n  (i.e. \"The array containing the single element is always odd-lengthed\").\n  Be on the lookout for invariants like this when solving array problems,\n  as binary search is very flexibile!\n\n  Complexity Analysis\n  Time complexity: O(log n). On each iteration of the loop,\n  we're halving the number of items we still need to search.\n\n  Space complexity: O(1). We are only using constant space to keep track of where we are in the search.\n*/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNonDuplicateBinarySearch = function(nums) {\n  const len = nums.length;\n  let lowest = 0;\n  let highest = len - 1; // last index\n\n  while (lowest < highest) {\n    let mid = Math.floor(lowest + (highest - lowest)/2);\n    let halvesAreEven = (highest - mid) % 2 === 0;\n\n    if (nums[mid + 1] === nums[mid]) {\n      if (halvesAreEven) {\n        lowest = mid + 2;\n      } else {\n        highest = mid - 1;\n      }\n    } else if ( nums[mid - 1] === nums[mid]) {\n      if (halvesAreEven) {\n        highest = mid - 2;\n      } else {\n        lowest = mid + 1;\n      }\n    } else return nums[mid];\n  }\n\n  return nums[lowest];\n}\n\n\n/*\n  Approach 3 Binary search on Even indexes only\n  It turns out that we only need to binary search on the even indexes.\n  This approach is more elegant than the last, although both are good solutions.\n\n  Intuition\n  The single element is at the first even index not followed by its pair.\n  We used this property in the linear search algorithm, where we iterated over all of the even indexes\n  until we encountered the first one not followed by its pair.\n\n  Instead of linear searching for this index though, we can binary search for it.\n  After the single element, the pattern changes to being odd indexes followed by their pair.\n  This means that the single element (an even index) and all elements after it\n  are even indexes not followed by their pair.\n  Therefore, given any even index in the array,\n  we can easily determine whether the single element is to the left or to the right.\n\n  Algorithm\n  We need to set up the binary search variables\n  and loop so that we are only considering even indexes.\n  The last index of an odd-lengthed array is always even,\n  so we can set lo and hi to be the start and end of the array.\n\n  We need to make sure our mid index is even.\n  We can do this by dividing lo and hi in the usual way,\n  but then decrementing it by 1 if it is odd.\n  This also ensures that if we have an even number of even indexes to search,\n  that we are getting the lower middle\n  (incrementing by 1 here would not work,\n  it'd lead to an infinite loop as the search space would not be reduced in some cases).\n\n  Then we check whether or not the mid index is the same as the one after it.\n\n  If it is, then we know that mid is not the single element,\n  and that the single element must be at an even index after mid.\n  Therefore, we set lo to be mid + 2.\n  It is +2 rather than the usual +1 because we want it to point at an even index.\n\n  If it is not, then we know that the single element is either at mid,\n  or at some index before mid. Therefore, we set hi to be mid.\n\n  Once lo == hi, the search space is down to 1 element, and this must be the single element, so we return it.\n\n  Complexity Analysis\n  ime complexity : O(log(n/2)) = =O(log n). Same as the binary search above,\n  except we are only binary searching half the elements, rather than all of them.\n\n  Space complexity : O(1). Same as the other approaches.\n  We are only using constant space to keep track of where we are in the search.\n*/\nfunction singleNonDuplicateBinarySearchOnEvenIndexes(nums) {\n  let lo = 0;\n  let hi = nums.length - 1;\n\n  while (lo < hi) {\n    let mid = Math.floor(lo + (hi - lo)/2);\n    if (mid % 2 === 1) mid--;\n    if (nums[mid] === nums[mid+1]) lo = mid + 2;\n    else hi = mid\n  }\n  return nums[lo];\n}\n\nexport {\n  singleNonDuplicateBruteForce, singleNonDuplicateBruteForceVariant2,\n  singleNonDuplicateBinarySearch, singleNonDuplicateBinarySearchOnEvenIndexes\n}\n","/*\nLeetcode\n26 Remove duplicates from sorted array\neasy\n\nGiven a sorted array nums, remove the duplicates in-place\nsuch that each element appear only once and return the new length.\n\nDo not allocate extra space for another array,\nyou must do this by modifying the input array in-place with O(1) extra memory.\n\nExample 1:\nGiven nums = [1,1,2],\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\nIt doesn't matter what you leave beyond the returned length.\n\nExample 2:\nGiven nums = [0,0,1,1,1,2,2,3,3,4],\n\nYour function should return length = 5, with the first five elements of nums being modified\nto 0, 1, 2, 3, and 4 respectively.\nIt doesn't matter what values are set beyond the returned length.\n\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference,\nwhich means modification to the input array will be known to the caller as well.\n\nInternally you can think of this:\n// nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\nHint 1\nIn this problem, the key point to focus on is the input array being sorted.\nAs far as duplicate elements are concerned, what is their positioning in the array\nwhen the given array is sorted? Look at the image above for the answer.\n1 1 2 3 4 4 4\nIf we know the position of one of the elements,\ndo we also know the positioning of all the duplicate elements?\n\nHint 2\nWe need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array.\nSo, we ought to use a two-pointer approach here.\nOne, that would keep track of the current element in the original array\nand another one for just the unique elements.\n\nHint 3\nEssentially, once an element is encountered, you simply need to bypass its duplicates\nand move on to the next unique element.\n*/\n\n/*\nApproach Brute force\n\nEasy solution but doesn't required condition with space\nThere is extra space?\n*/\nvar removeDuplicates = function(nums) {\n  let uniqueArr = [];\n\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] !== nums[i+1]) {\n      uniqueArr.push(nums[i])\n    }\n  }\n\n  return uniqueArr.length\n};\n\n/*\nApproach 2 Pointers: slow and fast runner\n\nAlgorithm\nSince the array is already sorted, we can keep two pointers i and j,\nwhere i is the slow-runner while j is the fast-runner.\nAs long as nums[i] = nums[j], we increment j to skip the duplicate.\n\nWhen we encounter nums[j] is not equal nums[i]\nthe duplicate run has ended so we must copy its value to nums[i+1].\ni is then incremented and we repeat the same process again until j reaches the end of array.\n\nComplexity analysis\nTime complexity: O(n). Assume that nn is the length of array.\nEach of i and j traverses at most n steps.\n\nSpace complexity: O(1).\n*/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicatesTwoPointers = function(nums) {\n  if (nums === undefined || nums.length === 0) {\n    return -1;\n  }\n\n  if (nums.length === 1) {\n    return nums.length;\n  }\n\n  // 2 pointers approach\n  let slow = 0;\n\n  for (let fast = 1; fast < nums.length; fast++) {\n    // if current element is not duplicate,\n    // slow runner grows one step and copies the current value\n    if (nums[slow] !== nums[fast]) {\n      slow += 1;\n      nums[slow] = nums[fast]\n    }\n  }\n\n  return slow + 1;\n};\n\n// tests\n// console.log('removeDuplicatesTwoPointers', removeDuplicatesTwoPointers([0,0,1,1,1,2,2,3,3,4]))\n\nexport {\n  removeDuplicates,\n  removeDuplicatesTwoPointers\n}\n","import React from 'react';\nimport Details from './../Details';\n\nimport { mergeSortedArrays } from '../../ds/arrays/merge-sorted-arrays';\nimport { clone, cloneIterative, cloneUseLoopFixedSize } from '../../ds/arrays/clone';\n\n// problems\nimport { jumpOnClouds } from '../../ds/arrays/tasks/jump-on-clouds';\nimport { majorityElement, majorityMooreVoting } from '../../leetcode/array/majority/169-majority-element';\nimport { findJudge, findJudgeTwoArrays } from '../../leetcode/array/997-find-judge';\nimport { maxSubArrayBruteForceCubicTime, maxSubArrayBruteForce } from '../../leetcode/array/53-max-contiguous-subarray-sum';\nimport { singleNonDuplicateBruteForce, singleNonDuplicateBinarySearch, singleNonDuplicateBinarySearchOnEvenIndexes } from '../../leetcode/array/540-single-element-in-sorted-array';\n//import { generate } from '../../leetcode/array/pascals-triangle/118-pascals-triangle';\n//import { plusOne } from '../../leetcode/array/66-plus-one';\n\n// duplicates\nimport { removeDuplicates } from '../../leetcode/array/duplicates/26-remove-duplicates-from-sorted-array';\n//import { findDuplicate } from '../../leetcode/array/duplicates/287-find-duplicate-number';\n//import { findAllDuplicates } from '../../leetcode/array/duplicates/442-find-all-duplicates';\n\n// todo import { QuickUnion } from '../../algorithms/union-find/quick-union';\n// todo import { RandomizedSet } from '../../leetcode/hash/380-insert-delete-getrandom-constant-time';\n\nexport default function ArrayAlgorithms() {\n  return (\n    <div className=\"sorting\">\n      <h2>Array</h2>\n\n      <Details\n        id=\"test-array\"\n        //code={generate.toString()}\n        //code={findDuplicate.toString()}\n        //secondCode={findAllDuplicates.toString()}\n      />\n\n      <ul id=\"array\">\n        <li>\n          <Details\n            id=\"remove-duplicates-in-sorted-array\"\n            question=\"Remove duplicates from sorted array: approach 2 pointers, slow and fast runner\"\n            time=\"O(n)\"\n            space=\"O(1)\"\n            code={removeDuplicates.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"array-clone\"\n            question=\"Clone arrays\"\n            code={clone.toString()}\n            secondCode={cloneIterative.toString()}\n            thirdSolution={cloneUseLoopFixedSize.toString()}\n          />\n        </li>\n\n        {/* different task */}\n        <li>\n          <Details\n            id=\"array-jump-on-clouds\"\n            question=\"Jump on clouds\"\n            solution=\"\"\n            code={jumpOnClouds.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"merge-two-arrays\"\n            question=\"merge two sorted arrays (mergeSort algorithm)\"\n            solution=\"Below is just an implementation of mergeSort algorithm\"\n            time=\"runtime is O(n log n)\"\n            space=\"\"\n            code={mergeSortedArrays.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"sinlgle-element-in-sorted-array\"\n            question=\"Single element in sorted array: approach brute force, binary search, BS only on even indexes\"\n            solution=\"for brute force time is O(n), space is O(1)\"\n            time=\"binary search approach O(log n)\"\n            space=\"binary search approachO(1)\"\n            code={singleNonDuplicateBruteForce.toString()}\n            secondCode={singleNonDuplicateBinarySearch.toString()}\n            thirdSolution={singleNonDuplicateBinarySearchOnEvenIndexes.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"majority-element\"\n            question=\"Majority elements: using hash, sort, Voting Moore algorithm\"\n            solution=\"\"\n            time=\"Moore O(n)\"\n            space=\"Moore O(1)\"\n            code={majorityElement.toString()}\n            secondCode={majorityMooreVoting.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"find-judge\"\n            question=\"Find judge in the town, approach with one and two arrays\"\n            solution={\n              `\n                In a town, there are N people labelled from 1 to N.\n                There is a rumor that one of these people is secretly the town judge.\n                If the town judge exists, then:\n                1 The town judge trusts nobody.\n                2 Everybody (except for the town judge) trusts the town judge.\n                3 There is exactly one person that satisfies properties 1 and 2.\n\n                You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.\n                If the town judge exists and can be identified, return the label of the town judge.\n                Otherwise, return -1.\n              `\n            }\n            complexity={`\n              Recall that N is number of people, and E is the number of edges (trusts relationships)\n              Time complexity is O(E). We need to loop through the E edges in trust,\n              and the argument about relationship between N and E still applies.\n              Space complexity: O(N) - allocating an array of length N\n            `}\n            time=\"O(max(N, E) = O(N+E), because is E >= N-1 => O(E) number of trusts relationship\"\n            space=\"O(N) allocating an array of length N\"\n            code={findJudge.toString()}\n            secondCode={findJudgeTwoArrays.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"max-contiguous-subarray-sum\"\n            question=\"Max contiguous subarray sum: brute force cubic and quadratic time\"\n            solution={\n              `\n                test\n              `\n            }\n            complexity={`\n              test\n            `}\n            time=\"\"\n            space=\"\"\n            code={maxSubArrayBruteForceCubicTime.toString()}\n            secondCode={maxSubArrayBruteForce.toString()}\n          />\n        </li>\n\n      </ul>\n  </div>\n  );\n}\n","// implement stack using string as storage\nclass Stack {\n  constructor() {\n    this.storage = '';\n  }\n\n  isEmpty() {\n    if (this.storage.length === 0) return true;\n    return false;\n  }\n\n  push(item) {\n    this.storage = this.storage.concat('***', item);\n  }\n\n  pop() {\n    let lastEliminate = this.storage.lastIndexOf('***');\n    // slice off the last characters up until ***\n    const lastStr = this.storage.slice(lastEliminate + 3);\n    // updating a new stack without last item\n    this.storage = this.storage.substr(0, lastEliminate);\n    // return the last item\n    return lastStr;\n  }\n\n  peek() {\n    return this.storage[this.storage.length - 1]\n  }\n}\n\nexport { Stack }\n","/*\nApproach implementation of Stack via Array\n\ntime: every operation takes constant time\nspace: less wasted time in comparison with Linked list\n*/\nclass Stack {\n  constructor() {\n    this.stack = [];\n  }\n\n  get length() {\n    return this.stack.length;\n  }\n\n  isEmpty() {\n    // helper method\n    // returns true if the stack is empty\n    return this.length === 0;\n  }\n\n  push(item) {\n    // inserts the element into the top of the stack\n    this.stack.push(item);\n  }\n\n  pop() {\n    // removes the element from the top of the stack and return that element\n    if (this.isEmpty()) {\n      throw new Error('stack is empty');\n    }\n    return this.stack.pop();\n  }\n\n  peek() {\n    // get the top element from the stack\n    return this.stack[this.stack.length - 1];\n  }\n\n  clear() {\n    return []\n  }\n\n  print() {\n    console.log('stack', this.stack.toString())\n  }\n}\n\n/*\nImplementation of Stack use Array\nvariant 2\n*/\n\nclass StackVariant2 {\n  constructor() {\n    this.stack = [];\n    this.top = 0;\n  }\n\n  length() {\n    return this.top;\n  }\n\n  push(element) {\n    this.stack[this.top++] = element;\n  }\n\n  pop() {\n    return this.stack[--this.top];\n  }\n\n  peek() {\n    return this.stack[this.top - 1];\n  }\n\n  clear() {\n    this.top = 0;\n  }\n}\n\n// tests\n// const stack = new Stack();\n// //const stack2 = new StackVariant2();\n// stack.push(1);\n// stack.push(2);\n// stack.push(3);\n// stack.push(1);\n// stack.pop();\n// stack.pop();\n// stack.peek()\n// stack.print();\n\nexport {\n  Stack,\n  StackVariant2\n}\n","class ListNode {\n  constructor(val, next) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n/*\nApproach implementation of Stack via Linked List\n\npush(item) - As in the stack new item are added on the top,\nIf the head is empty then the new node will be the first element,\nelse we will make all the new node of the linked list to be\nthe first node by assigning all the old nodes to the new node.\n\npop() - To remove an item from the stack we can just make the head to point\nthe very next element.\n\ntime: every operation takes constant time\nspace: depends on machine, extra space to deal with links\n*/\nclass Stack {\n  constructor() {\n    this.head = null;\n    this.length = 0;\n  }\n\n  isEmpty() {\n    return this.length === 0\n  }\n\n  // push data into the stack\n  // insert a new node at the beginning of Linked list\n  push(item) {\n    // create a new node\n    let newNode = new ListNode(item, null);\n\n    // 2 cases if list is empty\n    // or head is not empty\n    if (!this.head) {\n      this.head = newNode;\n    } else {\n      newNode.next = this.head;\n      this.head = newNode;\n    }\n    this.length++;\n  }\n\n  // remove first node from the beginning of Linked list\n  // that's most recently added item\n  pop() {\n    if (!this.head) return null;\n    this.head = this.head.next;\n    this.length--;\n    return this.head.val;\n  }\n\n  peek() {\n    if (!this.head) return null;\n    return this.head.val;\n  }\n\n  // todo\n  // Convert the stack to an array\n  // toArray = function(){\n  //   let arr = [];\n  //   let current = head;\n  //   while(current){\n  //     arr.push(current.element);\n  //     current = current.next;\n  //   }\n\n  //   return arr;\n  // }\n\n  clear() {\n    this.head = null;\n    this.length = 0;\n  }\n}\n\nconst stack = new Stack();\nstack.push(1)\nstack.push(2);\nstack.pop();\n//console.log('stack via Linked List', stack)\n\nexport {\n  Stack,\n  // StackUsingLinkedList\n}\n","/**\n * Stack using objects\n * The problem that hash doesn't have last element\n * Idea have a loop for prop in k which is an object\n *  for prop in k\n *    if !k[x-i]\n *      k[x-i] = a\n *      break;\n * @param {*} capacity\n */\nfunction StackObj(capacity) {\n  this.capacity = capacity || Infinity;\n  this.storage = {};\n  this.count = 0;\n}\n\n// O(1)\nStackObj.prototype.push = function(value) {\n  if (this.count < this.capacity) {\n    this.storage[this.count++] = value;\n    return this.count;\n  }\n  return 'Max capacity already reached. Remove element before adding a new one.'\n}\n\n// O(1)\nStackObj.prototype.pop = function() {\n  if (this.count === 0) {\n    return 'No element inside the stack. Add element before popping.'\n  }\n\n  const value = this.storage[this.count--];\n  delete this.storage[this.count];\n  if (this.count < 0) {\n    this.count = 0;\n  }\n  return value;\n}\n\n// O(1)\nStackObj.prototype.count = function() {\n  return this.count;\n}\n\nconst myStack = new StackObj();\nmyStack.push('a');\nmyStack.push('b');\nmyStack.push('c');\n// myStack.pop();\n// console.log('my stack pop', myStack.pop());\n// console.log('my stack', myStack);\n\n// todo\n// add and remove from top\n// isEmpty\n// peek\n// push\n// pop\n\nexport { StackObj }\n","/*\nLeetcode\neasy\n155 Implement a min Stack\n\nDesign a stack that supports push, pop, top,\nand retrieving the minimum element in constant time.\npush(x) - Push element x onto stack.\npop() - Removes the element on top of the stack.\ntop() - Get the top element.\ngetMin() - Retrieve the minimum element in the stack.\n\nExample 1:\nInput\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\nConstraints:\nMethods pop, top and getMin operations will always be called on non-empty stacks\n\nOverview\nFew things to keep in mind before we get started:\n\nMake sure that you read the question carefully.\n- The getMin(...) operation only needs to return the value of the minimum,\nit does not remove items from the MinStack.\n\n- We're told that all the MinStack operations must run in constant time, i.e. O(1) time\n\n- What if you are told to pop(...), getMin(...), or top(...)\nwhile there are no values on your MinStack?\nIn constraints, the question say that methods pop, top and getMin operations\nwill always be called on non-empty stacks.\nSo you can assume these cases won't happen, or that you should return -1\nor throw an exception if they do.\n*/\n\n\n/*\nApproach 2 Stacks\n\nWe could have two Stacks inside our MinStack.\n\nThe main Stack should keep track of the order numbers arrived (a standard Stack),\nand the second Stack should keep track of the current minimum.\nWe'll call this second Stack the \"min-tracker\" Stack for clarity.\n\nThe push(...) method: items should always be pushed onto the main Stack,\nbut they should only be pushed onto the min-tracker Stack if they are smaller\nthan the current top of it.\n\nThere's one potential pitfall.\nInstead of only pushing numbers to the min-tracker Stack if they are less than\nthe current minimum, we should push them if they are less than or equal to it.\nWhile this means that some duplicates are added to the min-tracker Stack.\n\ntop(...) returns (but doesn't remove) the top value of the main Stack,\nwhereas getMin(...) returns (but doesn't remove) the top of the min-tracker Stack.\n\nThis leaves us still needing to implement MinStack's pop(...) method.\nThe value we actually need to pop is always on the top of the main underlying Stack.\nHowever, if we simply popped it from there, the min-tracker Stack would become\nincorrect once its top value had been removed from the main Stack.\n\nComplexity analysis\n\ntime complexity\nO(1) for all operations\npush(...): Checking the top of a Stack, comparing numbers, and pushing to the top of a Stack (or adding to the end of an Array or List) are all O(1) operations.\n\npop(...): Popping from a Stack (or removing from the end of an Array, or List)\nis an O(1) operation.\n\ntop(...): Looking at the top of a Stack is an O(1) operation.\n\ngetMin(...): Same as above. This operation is O(1) because we do not need to compare values to find it.\nIf we had not kept track of it on the Stack,\nand instead had to search for it each time, the overall time complexity would have been O(n).\n\nspace complexity\nWorst case is that all the operations are push.\nIn this case, there will be O(2n) = O(n) space used.\n*/\nclass MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n\n  /**\n  * @param {number} item\n  * @returns {void}\n  */\n  push(item) {\n    // The push(...) method: items should always be pushed onto the main Stack,\n    // but they should only be pushed onto the min-tracker Stack if they are smaller than the current top of it.\n    this.stack.push(item);\n\n    // we need to have <= to solve a problem with duplicates if they have\n    if (this.minStack.length === 0 || item <= this.minStack[this.minStack.length - 1]) {\n      this.minStack.push(item);\n    }\n  }\n\n  /**\n * @returns {void}\n */\n  pop() {\n    const item = this.stack.pop();\n    if (item === this.minStack[this.minStack.length - 1]) {\n      this.minStack.pop()\n    }\n  }\n\n  /**\n  * @returns {number}\n  */\n  top() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  /**\n  * @returns {number}\n  */\n  getMin() {\n    return this.minStack[this.minStack.length - 1];\n  }\n}\n\n/*\nApproach: use one stack only: stack of value / Minimum pairs\n\nThis approach required storing two values in each slot of the underlying Stack.\nSometimes though, the minimum values are very repetitive.\nDo we actually need to store the same minimum value over and over again?\nWe can solve it by using 2 Stack (see solution above)\n\ntime is O(1)\nspace is O(n)\n*/\n\nclass MinStackMinPairs {\n  constructor() {\n    this.elements = [];\n  }\n\n  /**\n    @param {number} item\n    @return {void}\n */\n  push(item) {\n    this.elements.push({\n      value: item,\n      min: this.elements.length === 0 ? item : Math.min(item, this.getMin())\n    })\n  }\n\n  pop() {\n    this.elements.pop();\n  }\n\n  top() {\n    return this.elements[this.elements.length - 1].value;\n  }\n\n  getMin() {\n    return this.elements[this.elements.length - 1].min\n  }\n}\n\n/*\nApproach 3: Improved 2 Stacks\n\nIn the first approach, we pushed a new number onto the min-tracker Stack if,\nand only if, it was less than or equal to the current minimum.\nOne downside of this solution is that if the same number is pushed repeatedly\ninto MinStack,\nand that number also happens to be the current minimum,\nthere'll be a lot of needless repetition on the min-tracker Stack.\nRecall that we put this repetition in to prevent a bug from occurring\n(refer to Approach 1).\n\nAn improvement is to put pairs onto the min-tracker Stack.\nThe first value of the pair would be the same as before,\nand the second value would be how many times that minimum was repeated.\n*/\n\nclass MinStackUseTwoStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n\n  }\n\n  push(item) {\n    // We always put the number onto the main stack.\n    this.stack.push(item);\n\n    // If the min stack is empty, or this number is smaller than\n    // the top of the min stack, put it on with a count of 1.\n    if (this.minStack.length === 0 || item < this.minStack[this.minStack.length - 1][0]) {\n      this.minStack.push([item, 1])\n    }\n\n    // Else if this number is equal to what's currently at the top\n    // of the min stack, then increment the count at the top by 1.\n    else if (item === this.minStack[this.minStack.length - 1][0]) {\n      this.minStack[this.minStack.length - 1][1]++;\n    }\n  }\n\n  pop() {\n    if (this.stack.length === 0 || this.minStack.length === 0) {\n      throw new Error('stack is empty');\n    }\n\n    // If the top of min stack is the same as the top of stack\n    // then we need to decrement the count at the top by 1.\n    if (this.stack[this.stack.length - 1] === this.minStack[this.minStack.length - 1][0]) {\n      this.minStack[this.minStack.length - 1][1]--;\n\n      // it's better approach nested loop\n      if (this.minStack[this.minStack.length - 1][1] === 0) {\n        this.minStack.pop();\n      }\n    }\n\n    // If the count at the top of min stack is now 0, then remove\n    // that value as we're done with it.\n    // if (this.minStack[this.minStack.length - 1][1] === 0) {\n    //   this.minStack.pop();\n    // }\n\n    // and like before, pop the top of the main stack.\n    this.stack.pop();\n  }\n\n  top() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  getMin() {\n    return this.minStack[this.minStack.length - 1][0];\n  }\n}\n\n/*\n  todo\n  Min stack using object\n\n  class MinStack {\n    constructor(capacity) {\n      this.capacity = capacity;\n      this.storage = {};\n      this.count = 0;\n      this.min = new Stack();\n    }\n    ...\n  }\n*/\n\n// tests\n// let minStack = new MinStackUseTwoStack();\n// minStack.push(-2);\n// minStack.push(0);\n// minStack.push(-2);\n// minStack.pop();\n// minStack.pop();\n// minStack.pop();\n// minStack.pop();\n// console.log('minStack', minStack)\n// console.log('minStack', minStack.top())\n\nexport {\n  MinStack,\n  MinStackMinPairs,\n  MinStackUseTwoStack\n}\n","/*\nLeetcode\n716 Max Stack\neasy\n\nDesign a max stack that supports push, pop, top, peekMax and popMax.\n\npush(x) - Push element x onto stack.\npop() - Remove the element on top of the stack and return it.\ntop() - Get the element on the top.\npeekMax() - Retrieve the maximum element in the stack.\npopMax() - Retrieve the maximum element in the stack, and remove it.\nIf you find more than one maximum elements, only remove the top-most one.\n\nExample 1:\n\nMaxStack stack = new MaxStack();\nstack.push(5);\nstack.push(1);\nstack.push(5);\nstack.top(); -> 5\nstack.popMax(); -> 5\nstack.top(); -> 1\nstack.peekMax(); -> 5\nstack.pop(); -> 1\nstack.top(); -> 5\n\nNote:\n-1e7 <= x <= 1e7\nNumber of operations won't exceed 10000.\nThe last four operations won't be called when stack is empty.\n\nCan we design operations in O(1) like the min stack problem? No.\nBecause if it were, you could use this data structure to sort an array of numbers in O(n) time.\nSo, at the very least, either push(x) or popMax() must be O(log n)\n\nHint: Use two stacks, one to store all of the items and a second stack to\nstore the maximums.\n*/\n\n/*\nApproach Two Stacks\n\nFor peekMax, we remember the largest value we've seen on the side.\nFor example if we add [2, 1, 5, 3, 9, 7], we'll remember [2, 2, 5, 5, 9, 9].\n\nThis works seamlessly with pop operations, and also it's easy to compute:\nit's just the maximum of the element we are adding and the previous maximum.\n\nFor popMax, we know what the current maximum (peekMax) is.\nWe can pop until we find that maximum, then push the popped elements back on\nthe stack.\n\nComplexity Analysis\nTime Complexity: O(N) for the popMax operation, and O(1) for the other operations,\nwhere N is the number of operations performed.\n\nSpace Complexity: O(N), the maximum size of the stack.\n*/\n\nclass MaxStack {\n  constructor() {\n    this.stack = [];\n    this.maxStack = []\n  }\n\n  push(item) {\n    this.stack.push(item);\n\n    const max = this.maxStack.length === 0 ? item : this.peekMax();\n    this.maxStack.push(max > item ? max : item);\n  }\n\n  pop() {\n    this.maxStack.pop();\n    return this.stack.pop();\n  }\n\n  /**\n  * @return {number}\n  * popMax() - Retrieve the maximum element in the stack, and remove it.\n  */\n  popMax() {\n    // for popMax, we know what the current maximum (peekMax) is.\n    // We can pop in original stack until we find that maximum,\n    // then push the popped elements back on the stack.\n    const temp = [];\n    while (this.top() !== this.peekMax()) {\n      temp.unshift(this.stack.pop());\n      this.maxStack.pop();\n    }\n\n    const output = this.pop();\n    for (const val of temp) {\n      this.push(val)\n    }\n\n    return output;\n  }\n\n  top() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  peekMax() {\n    return this.maxStack[this.maxStack.length - 1];\n  }\n}\n\nconst max = new MaxStack();\nmax.push(5);\nmax.push(3);\nmax.push(6);\nmax.push(5);\nmax.push(3);\nmax.popMax()\n//console.log('max', max)\n\n/*\n  Todo\n  There is an approach\n  Approach #2: Double Linked List + TreeMap [Accepted]\n*/\n\nexport { MaxStack }\n","import React from 'react';\nimport Details from '../Details';\n\nimport { Stack as StackUseString } from '../../ds/stack/stack-use-string';\nimport { Stack as StackArr } from '../../ds/stack/stack-use-array';\nimport { Stack as StackLinkedList } from '../../ds/stack/stack-use-linked-list';\nimport { StackObj as StackUseObj } from '../../ds/stack/stack-using-objects';\n\nimport { MinStack, MinStackMinPairs } from '../../leetcode/stack/155-min-stack';\nimport { MaxStack } from '../../leetcode/stack/716-max-stack';\n\n// problems\n// ...\n\nexport default function Stack() {\n  return (\n    <div className=\"stack\" id=\"stack\">\n      <h2>Stack</h2>\n\n      <ul>\n        {/* <li>\n          <Details\n            id=\"\"\n            question=\"test\"\n            code={?.toString()}\n          />\n        </li> */}\n        <li>\n          <Details\n            id=\"stack-use-array\"\n            question=\"Stack via Array\"\n            code={StackArr.toString()}\n            time='every operation takes constant time'\n            space='less wasted space'\n          />\n        </li>\n        <li>\n          <Details\n            id=\"stack-use-linked-list\"\n            question=\"Stack via Linked List\"\n            code={StackLinkedList.toString()}\n            time='for .push and pop() takes constant time'\n            space='need space for pointers'\n          />\n        </li>\n        <li>\n          <Details\n            id=\"stack-using-string\"\n            question=\"Stack via String\"\n            code={StackUseString.toString()}\n          />\n        </li>\n        <li>\n          <Details\n            id=\"stack-using-object\"\n            question=\"Stack via Object\"\n            code={StackUseObj.toString()}\n          />\n        </li>\n      </ul>\n\n      <ul>\n        <li>\n          <details\n            className=\"details\"\n            id=\"stack-different-tasks\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n              <summary role=\"button\" aria-controls=\"content\">\n                Different problems related to Stacks\n              </summary>\n\n              <Details\n                id=\"min-stack\"\n                question=\"Min Stack: approach 2 Stacks, approach minimum pairs\"\n                time=\"O(1) for all operation\"\n                space=\"O(n)\"\n                code={MinStack.toString()}\n                secondCode={MinStackMinPairs.toString()}\n              />\n\n              <Details\n                id=\"max-stack\"\n                question=\"Max Stack: approach 2 Stacks\"\n                solution=\"Design a max stack that supports push, pop, top, peekMax and popMax.\"\n                complexity={\n                  `\n                  Can we design operations in O(1) like the min stack problem? No\n                  Because if it were, you could use this data structure to sort an array of numbers in O(n) time.\n                  So, at the very least, either push(x) or popMax() must be O(log n)\n                  `\n                }\n                time=\"O(N) for the popMax operation, and O(1) for the other operations\"\n                space=\"O(N), the maximum size of the stack.\"\n                code={MaxStack.toString()}\n                secondCode={MaxStack.toString()}\n              />\n          </details>\n        </li>\n      </ul>\n  </div>\n  );\n}\n","/*\n\ntime complexity\nspace complexity\n*/\nclass Queue {\n  constructor() {\n    this.queue = [];\n  }\n\n  get length() {\n    return this.queue.length;\n  }\n\n  isEmpty() {\n    return this.length === 0;\n  }\n\n  // insert - add to the end\n  enqueue(item) {\n    this.queue.push(item);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.queue.shift();\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      throw new Error('queue is empty');\n    }\n    return this.queue[0];\n  }\n}\n\n// tests\nconst queue = new Queue();\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.enqueue(3);\nqueue.dequeue();\n// console.log('queue', queue)\n\nexport {\n  Queue\n}\n","class ListNode {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n/*\nImplementation with one pointer\n\ntime complexity:\nenqueue - O(n)\ndequeue - O(1)\n*/\nclass Queue {\n  constructor() {\n    this.head = null;\n    this.length = 0;\n  }\n\n  isEmpty() {\n    return this.length === 0;\n  }\n\n  getHead() {\n    return this.head.val;\n  }\n\n  getLength() {\n    return this.length;\n  }\n\n  // Insert: add to the end of linked list\n  // To add an item in the queue, we will check if the list is empty\n  // then use the new node as the first element else add the new node\n  // to the end of the existing nodes.\n  enqueue(item) {\n    let newNode = new ListNode(item);\n    if (!this.head) {\n      this.head = newNode\n    } else {\n      let traverseNode = this.head;\n      while (traverseNode.next) {\n        traverseNode = traverseNode.next\n      }\n      traverseNode.next = newNode;\n    }\n    this.length++;\n  }\n\n  // remove from beginning\n  dequeue() {\n    if (!this.head) return 'Queue is empty!';\n    // saves the link to the head which we need to remove\n    const current = this.head;\n\n    // moves the head link to the second Node in the Queue\n    // this.head is the satisfied customer who has already bought products\n    // this.head.next is the next customer who becomes the head of the queue after\n    // satisfied customer leaving\n    this.head = this.head.next;\n    this.length--;\n    // returns the removed Nodes value\n    return current.val;\n  }\n\n  peek() {\n    if (!this.head) return 'Queue is empty!';\n    return this.head.val;\n  }\n\n  // show all values of all nodes in Queue\n  print() {\n    let current = this.head;\n    while (current) {\n      console.log(current.val);\n      current = current.next;\n    }\n\n  }\n}\n\n/*\nImplementation with 2 pointers\n\ntime complexity:\nenqueue - O(1) because we have tail pointer\ndequeue - O(1)\n*/\n\nclass QueueUse2Pointers {\n  constructor() {\n    this.head = null; // link to the first node\n    this.tail = null; // link to the last node\n    this.length = 0;\n  }\n\n  isEmpty() {\n    return this.length === 0;\n  }\n\n  getHead() {\n    return this.head.val;\n  }\n\n  getLength() {\n    return this.length;\n  }\n\n  enqueue(val) {\n    let newNode = new ListNode(val);\n    if (!this.head) {\n      this.head = newNode; // the created Node is head\n      // also the created Node is a tail in Queue because it is single\n      this.tail = newNode;\n    } else {\n      // inserts the created node after the tail\n      this.tail.next = newNode;\n      // now created Node is a tail\n      this.tail = newNode;\n    }\n    this.length++;\n  }\n\n  dequeue() {\n    if (!this.head) return 'Queue is empty!';\n    const current = this.head;\n    this.head = this.head.next;\n    this.length--;\n    return current.val;\n  }\n\n  peek() {\n    if (!this.head) return 'Queue is empty!';\n    return this.head.val;\n  }\n}\n\n// tests\n// const persons = new Queue();\n// persons.enqueue('first');\n// persons.enqueue('second');\n// persons.enqueue('third');\n// persons.dequeue();\n// persons.dequeue();\n// persons.dequeue();\n// persons.print();\n//console.log('Queue', persons)\n//const personsJson = JSON.parse(JSON.stringify(persons));\n//console.log('personsJson', personsJson);\n\nexport {\n  Queue,\n  QueueUse2Pointers\n}\n","/*\nLeetcode\n232 Implement Queue with 2 stack\neasy\n\nImplement the following operations of a queue using stacks.\n\npush(x) -- Push element x to the back of queue.\npop() -- Removes the element from in front of queue.\npeek() -- Get the front element.\nempty() -- Return whether the queue is empty.\nExample:\n\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);\nqueue.peek();  // returns 1\nqueue.pop();   // returns 1\nqueue.empty(); // returns false\n\nNotes:\nYou must use only standard operations of a stack -- which means only push to top,\npeek/pop from top, size, and is empty operations are valid.\nDepending on your language, stack may not be supported natively.\nYou may simulate a stack by using a list or deque (double-ended queue),\nas long as you use only standard operations of a stack.\nYou may assume that all operations are valid (for example, no pop or peek\noperations will be called on an empty queue).\n\nHint: If you push elements onto a stack and then pop them all, they appear in\nreverse order. If you repeat this process, they're now back in order.\n*/\n\n/*\nApproach 1 Stack by making enqueue operation costly\n\nSince we main difference between Queue and Stack is the order (first-in first-out vs\nlast-in first-out) we know that we need to modify peek() and pop() to go in reverse\norder.\n\npeek of Stack this.stack[stack.length -1]\npeek of Queue this.queue[0]\npop Stack this.stack.pop()\npop Queue this.queue.shift()\n\nWe can use our second stack to reverse the order of elements (by popping s1 and\npushing the elements on to s2). In such an implementation, on each peek() and pop()\noperation, we would pop everything from s1 onto s2, perform the peek / pop operation,\nand then push everything back.\n\nMethod 1 moves all the elements twice in enqueue operation, while below is a method\nmoves the elements once and moves elements only of stack2 empty.\n\nTime complexity\npush is O(n)\nremove is O(1)\n*/\n\nclass QueueUse2Stacks {\n  constructor() {\n    this.stackOldest = [];\n    this.stackNewest = [];\n  }\n\n  size() {\n    return this.stackOldest.length + this.stackNewest.length;\n  }\n\n  enqueue(val) {\n    // move all elements from s1 to s2\n    while (this.stackOldest.length) {\n      this.stackNewest.push(this.stackOldest.pop());\n    }\n\n    // push val in stack1\n    this.stackOldest.push(val);\n\n    // push everything back to s1\n    while (this.stackNewest.length) {\n      this.stackOldest.push(this.stackNewest.pop());\n    }\n  }\n\n  dequeue() {\n    if (this.stackOldest.length === 0) return 'Queue is empty';\n    let x = this.stackOldest[this.stackOldest.length - 1];\n    this.stackOldest.pop();\n    return x;\n  }\n\n  peek() {\n    return this.stackOldest[this.stackOldest.length - 1];\n  }\n}\n\n/*\nApproach 2 Stack (push is O(1), remove is O(n))\n\nIn this approach, stackNewest  has the newest elements on top and stackOldest has\nthe oldest elements on top. When we dequeue an element, we want to remove the oldest\nelement first, and so we dequeue from stackOldest. If stackOldest is empty, then\nwe want to transfer all elements from stackNewest into this stack in reverse order.\nTo insert an element, we push onto stackNewest, since it has the newest elements\non top.\n\nTime complexity\npush is O(1)\nremove is O(n)\n*/\n\nclass Queue {\n  constructor() {\n    this.stackNewest = [];\n    this.stackOldest = [];\n  }\n\n  empty() {\n    return !this.stackNewest.length && !this.stackOldest.length;\n  }\n\n  size() {\n    return this.stackNewest.length + this.stackOldest.length;\n  }\n\n  // add or push\n  // push onto stackNewest, which always has the newest elements on top\n  enqueue(val) {\n    this.stackNewest.push(val);\n  }\n\n  // move elements from stackNewest to stackOldest.\n  // This is usually done so that we can do operations on stackOldest\n  shiftStacks() {\n    if (!this.stackOldest.length) {\n      while (this.stackNewest.length) {\n        // reverse order\n        this.stackOldest.push(this.stackNewest.pop());\n      }\n    }\n  }\n\n  peek() {\n    // ensure stackOldest has the current elements\n    this.shiftStacks();\n    // retrieve the oldest item\n    return this.stackOldest[this.stackOldest.length - 1];\n  }\n\n  // remove\n  dequeue() {\n    // ensure stackOldest has the current elements\n    this.shiftStacks();\n    // pop the oldest item\n    return this.stackOldest.pop();\n  }\n}\n\n// tests\n// const queue = new Queue();\n// queue.enqueue(0);\n// queue.enqueue(1);\n// queue.enqueue(2);\n// queue.enqueue(4);\n// queue.dequeue();\n// queue.peek();\n// queue.dequeue();\n// queue.enqueue(3);\n// queue.dequeue();\n// queue.enqueue(4);\n// queue.dequeue();\n\n// queue.enqueue(1);\n// queue.enqueue(2);\n// queue.peek();  // returns 1\n// console.log('peek', queue.peek())\n// console.log('dequeue', queue.dequeue())\n// console.log('empty', queue.empty())\n// queue.dequeue();   // returns 1\n// queue.empty(); // returns false\n\n//console.log('queue use 2 stacks', queue)\n\nexport { Queue, QueueUse2Stacks }\n","import React from 'react';\nimport Details from '../Details';\n\nimport { Queue as QueueArray } from '../../ds/queue/queue-use-array';\nimport { Queue as QueueLinkedList, QueueUse2Pointers } from '../../ds/queue/queue-use-linked-list';\n\n// problems related to Queue\n//import { CircularQueue } from '../../algorithms/queue/circular-queue';\n\nimport { Queue as QueueUse2Stacks } from '../../leetcode/queue/232-queue-with-2-stacks';\n\nexport default function Queue() {\n  return (\n    <div className=\"queue\" id=\"queue\">\n      <h2>Queue</h2>\n\n        {/* <Details\n          id=\"\"\n          question=\"test\"\n          code={CircularQueue.toString()}\n        /> */}\n      <ul>\n        <li>\n          <Details\n            id=\"queue-use-array\"\n            question=\"Queue via array\"\n            code={QueueArray.toString()}\n          />\n        </li>\n        <li>\n          <Details\n            id=\"queue-use-linked-list\"\n            question=\"Queue via linked list (1 pointer and 2 pointers)\"\n            code={QueueLinkedList.toString()}\n            secondCode={QueueUse2Pointers.toString()}\n          />\n        </li>\n      </ul>\n\n      <ul>\n        <li>\n          <details\n            className=\"details\"\n            id=\"queue-problems\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n              <summary role=\"button\" aria-controls=\"content\">\n                Different problems related to Queues\n              </summary>\n\n              <Details\n                id=\"queue-use-2-stacks\"\n                question=\"\"\n                time=\"\"\n                space=\"\"\n                code={QueueUse2Stacks.toString()}\n              />\n          </details>\n        </li>\n      </ul>\n  </div>\n  );\n}\n","/*\nLeetcode\n707 Design linked list\nmedium\n\nYou can choose to use the singly linked list or the doubly linked list.\nA node in a singly linked list should have two attributes: val and next.\nval is the value of the current node, and next is a pointer/reference to the next node.\nIf you want to use the doubly linked list,\nyou will need one more attribute prev to indicate the previous node in the linked list.\nAssume all nodes in the linked list are 0-indexed.\n\nImplement these functions in your linked list class:\n\nget(index): Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n\naddAtHead(val): Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n\naddAtTail(val): Append a node of value val to the last element of the linked list.\n\naddAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n\ndeleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.\n\nConstraints:\n0 <= index,val <= 1000\nPlease do not use the built-in LinkedList library.\nAt most 2000 calls will be made to get, addAtHead, addAtTail,  addAtIndex and deleteAtIndex\n*/\n\n/*\nthe constructor function will be called to initialize\nthe object with two properties, data and a pointer named next.\nThe pointer next is initialized with a default value of null,\nincase no value is passed as an argument.\n*/\nclass ListNode {\n  constructor(val) {\n    this.val = val;\n    this.next = null; // pointer or reference\n  }\n}\n\n/*\nWhen an instance of the LinkedList class is formed,\nthe constructor function will be called to initialize the object\nwith a property, head.\nThe head pointer is assigned a value of null because when a linked list object\nis initially created it does not contain any nodes.\nIt is when we add our first node to the linked list,\nwe will assign it to the head pointer.\n*/\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.size = 0;\n  }\n\n  /**\n  * Get the value of the index-th node in the linked list.\n  * If the index is invalid, return -1.\n  * @param {number} index\n  * @return {number}\n  */\n  get(index) {\n    // index is outside the bounds of the list\n    if (index < 0 || index > this.size - 1 || this.size === 0) {\n      return -1;\n    }\n\n    // we're at the head\n    if (index === 0) {\n      return this.head.val;\n    }\n\n    let counter = 0;\n    let node = this.head;\n    while (node) {\n      if (counter === index) {\n        // return node, in task has to return val\n        return node.val;\n      }\n      counter++;\n      node = node.next\n    }\n    return -1;\n\n    // alternative version\n    // if (index >= this.size) return -1;\n    // let current = this.head;\n    // for (let i = 0; i < index; i++) {\n    //     current = current.next;\n    // }\n    // return current.val;\n  }\n\n  /**\n   * A helper function getAt() is defined to get to the desired position.\n   * This function can also be later used for performing delete operation\n   * from a given position.\n   */\n  getAt(index) {\n    // we're at the head\n    if (index === 0) {\n      return this.head;\n    }\n\n    let counter = 0;\n    let node = this.head;\n    while (node) {\n      if (counter === index) {\n        return node;\n      }\n      counter++;\n      node = node.next\n    }\n    return null\n  }\n\n  /**\n   * insert a node\n   * The easiest place to insert a new node in a linked list is at the beginning\n   * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n   * @param {number} val\n   * @return {void}\n   */\n  addAtHead(val) {\n    // A newNode object is created with property data and next = null\n    let newNode = new ListNode(val);\n\n    if (!this.head) {\n      this.head = newNode;\n    } else {\n      // Link the new node to our original head node\n      // The pointer next is assigned head pointer so that both pointers\n      // now point at the same node.\n      newNode.next = this.head;\n      // As we are inserting at the beginning the head pointer needs\n      // to new point at the newNode.\n      this.head = newNode;\n    }\n    this.size += 1;\n  }\n\n  /**\n  * Append a node of value val to the last element of the linked list.\n  * @param {number} val\n  * @return {void}\n  */\n  addAtTail(val) {\n    let newNode = new ListNode(val);\n\n    if (!this.head) {\n      this.head = newNode;\n    } else {\n      // else, traverse the list to find the tail\n      // (the tail node will initially be pointing at null),\n      // and update the tail's next pointer.\n      let tail = this.head; // or name as lastNode\n      // keep going down until we find the last node in the list\n      while (tail.next) {\n        tail = tail.next\n      }\n      tail.next = newNode;\n    }\n    this.size++;\n  }\n\n  /**\n   * Add a node of value val before the index-th node in the linked list.\n   * If index equals to the length of linked list,\n   * the node will be appended to the end of linked list.\n   * If index is greater than the length, the node will not be inserted.\n   * @param {number} index\n   * @param {number} val\n   * @return {void}\n   */\n  addAtIndex(index, val) {\n    let newNode = new ListNode(val);\n\n    if (index > this.size) return;\n\n    if (!this.head) {\n      this.head = newNode;\n    }\n\n    if (index === 0) {\n      return this.addAtHead(val);\n    }\n\n    if (index === this.size) {\n      return this.addAtTail(val);\n    }\n\n    const previous = this.getAt(index - 1);\n    newNode.next = previous.next;\n    previous.next = newNode;\n    // or alternatively without getAt\n    // let current = this.head;\n    // for (let i = 0; i < index - 1; i++) {\n    //     current = current.next\n    // }\n    // newNode.next = current.next;\n    // current.next = newNode\n\n    this.size++;\n  }\n\n  /**\n  * Delete the index-th node in the linked list, if the index is valid.\n  * @param {number} index\n  * @return {void}\n  */\n  deleteAtIndex(index) {\n    // indexes start from 0\n    if (index >= this.size - 1 || index < 0) return;\n    this.size--;\n\n    // delete first node\n    if (index === 0) {\n      this.head = this.head.next;\n      return;\n    }\n\n    let counter = 0;\n    let node = this.head;\n    while (counter < index - 1) {\n      node = node.next;\n      counter++;\n    }\n\n    node.next = node.next.next;\n  }\n\n  deleteList() {\n    this.head = null;\n  }\n\n  printList() {\n    const nodes = [];\n    let current = this.head;\n    while (current) {\n      nodes.push(current.val);\n      current = current.next;\n    }\n    return nodes.join(' -> ')\n  }\n}\n\n// tests\n// A list object is created with a property head, currently pointing at null\n// let linkedList = new LinkedList();\n// linkedList.addAtHead(7);\n// linkedList.addAtHead(2);\n// linkedList.addAtHead(1);\n// linkedList.addAtIndex(3, 0);\n// linkedList.deleteAtIndex(2);\n// linkedList.addAtHead(6);\n// linkedList.addAtTail(4)\n// linkedList.get(4);\n// console.log(linkedList.get(4));\n// console.log(linkedList.printList());\n\n// linkedList = JSON.parse(JSON.stringify(linkedList));\n// console.log('linked list', linkedList)\n\n/**\n * Leetcode\n * 328 Odd Even Linked List\n * medium\n *\n * Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\n\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\n\nExample 1:\n\nInput: 1->2->3->4->5->NULL\nOutput: 1->3->5->2->4->NULL\nExample 2:\n\nInput: 2->1->3->5->6->4->7->NULL\nOutput: 2->3->6->7->1->5->4->NULL\n *\n * Note:\n\nThe relative order inside both the even and odd groups should remain as it was in the input.\nThe first node is considered odd, the second node even and so on .\n *\n * explanation\n * first odd and then even\n * have one list\n * separate odd list\n * separate even list\n *\n * Intuition\n\nPut the odd nodes in a linked list and the even nodes in another. Then link the evenList to the tail of the oddList.\n*/\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar oddEvenList = function(head) {\n  if (!head) return head;\n\n  var odd = head;\n  var even = head.next;\n  while (odd.next && odd.next.next) {\n    var tmp = odd.next;\n    odd.next = odd.next.next;\n    odd = odd.next;\n    tmp.next = odd.next;\n  }\n  odd.next = even;\n  return head;\n};\n\nexport {\n  ListNode,\n  LinkedList\n}\n","import React from 'react';\nimport Details from '../Details';\n\nimport { LinkedList } from '../../ds/linked-list/singly/singly-linked-list';\n\nexport default function LinkedLists() {\n  return (\n    <div className=\"number\">\n      <h2>Linked Lists</h2>\n\n      <h4>Singly-linked List</h4>\n      <ul>\n        <li>\n          <Details\n            id=\"singly-linked-list\"\n            question=\"Singly linked list implementation\"\n            code={LinkedList.toString()}\n          />\n        </li>\n      </ul>\n\n      {/* <h4>Doubly-linked List</h4>\n      <ul>\n        <li>\n          ...\n        </li>\n      </ul>\n\n      <h6>Problems</h6>\n      <ul>\n        <li>\n          ...\n        </li>\n      </ul> */}\n  </div>\n  );\n}\n","/*\n\nHash tables are a common data structure for storing key-value pairs.\n\nget is O(n)\n*/\n\n// https://www.freecodecamp.org/news/how-to-implement-a-simple-hash-table-in-javascript-cb3b9c1f2997/\n// https://leetcode.com/problems/design-hashset/discuss/528614/long-javascript-solution-without-hashset-methods\n// https://leetcode.com/problems/design-hashset/discuss/137257/javascript-solution%3A-100ms.\n// https://leetcode.com/problems/design-hashset/discuss/768659/Python-Easy-Multiplicative-Hash-explained\n// https://www.mattzeunert.com/2017/02/01/implementing-a-hash-table-in-javascript.html\nclass HashTable {\n  constructor() {\n    this.keys = [];\n    this.values = [];\n  }\n\n  set(key, value) {\n    this.keys.push(key);\n    this.keys.push(value);\n  }\n\n  get(lookupKey) {\n    for (let i = 0; i < this.keys.length; i++) {\n      if (this.keys[i] === lookupKey) {\n        return this.values[i];\n      }\n    }\n  }\n}\n\nexport {\n  HashTable\n}\n","/*\nLeetcode\n705 Design a HashSet without using any built-in hash table libraries.\neasy\n\nTo be specific, your design should include these functions:\nadd(value): Insert a value into the HashSet.\n\ncontains(value): Return whether the value exists in the HashSet or not.\n\nremove(value): Remove a value in the HashSet. If the value does not exist in\nthe HashSet, do nothing.\n\nExample:\nMyHashSet hashSet = new MyHashSet();\nhashSet.add(1);\nhashSet.add(2);\nhashSet.contains(1);    // returns true\nhashSet.contains(3);    // returns false (not found)\nhashSet.add(2);\nhashSet.contains(2);    // returns true\nhashSet.remove(2);\nhashSet.contains(2);    // returns false (already removed)\n\nNote:\nAll values will be in the range of [0, 1000000].\nThe number of operations will be in the range of [1, 10000].\nPlease do not use the built-in HashSet library.\n*/\n\n/*\nApproach use obj\n\nthis solution under requirement, because {} is using any built-in hash in JS\n*/\nclass HashSet {\n  constructor() {\n    this.data = {};\n    this.length = 0;\n  }\n\n  /**\n   * @param {number} key\n   * @return {void}\n   */\n  add(key) {\n    //debugger\n    // count only unique values\n    if (!this.contains(key)) this.length++;\n    key = key.toString();\n    this.data[key] = key;\n  }\n\n  /**\n   * Returns true if this set contains the specified element\n   * @param {number} key\n   * @return {boolean}\n   */\n  contains(key) {\n    key = key.toString()\n    // Converts Object to boolean. If it was false (e.g. 0, null, undefined, etc.),\n    // it will be false, otherwise, true.\n    return (!!this.data[key] && this.data.hasOwnProperty(key));\n  }\n\n  /**\n   * @param {number} key\n   * @return {void}\n   */\n  remove(key) {\n    if (!this.contains(key)) {\n      return\n    } else {\n      delete this.data[key.toString()];\n      this.length--;\n    }\n  }\n  // remove with return\n  // remove(value) {\n  //   value = value.toString();\n  //   if (!this.data.contains(value)) {\n  //     return false\n  //   } else {\n  //     delete this.data[value];\n  //     this.length--;\n  //     return true;\n  //   }\n  // }\n\n  size() {\n    return this.length\n  }\n\n  isEmpty() {\n    return this.length === 0\n  }\n\n  toArray() {\n\n  }\n}\n\n/*\nApproach use obj, simple API\n*/\nclass HashSetVariant1 {\n  constructor() {\n    this.data = {};\n    this.length = 0;\n  }\n\n  add(key) {\n    if (!this.data[key]) {\n      this.data[key] = true;\n      this.length++;\n    }\n  }\n\n  remove(key) {\n    if (this.data[key]) {\n      delete this.data[key];\n      this.length--;\n    }\n  }\n\n  contains(key) {\n    if (!this.data[key]) {\n      return false;\n    }\n    else return true;\n  }\n\n  size() {\n    return this.length;\n  }\n\n  isEmpty() {\n    return this.length === 0;\n  }\n}\n\n\n// tests\nconst hash = new HashSet();\nhash.add(1);\nhash.add(2);\nhash.contains(1);\nhash.remove(2);\nhash.remove(3);\nhash.contains(3);\nhash.add(1);\nhash.add(2);\nconsole.log('hash', hash)\n\n\n\n// https://leetcode.com/problems/design-hashset/discuss/768659/Python-Easy-Multiplicative-Hash-explained\n// return ((key*1031237) & (1<<20) - 1)>>5\n// key is val\n// let mySet = new Set()\n// mySet.add(10000)\n\n// hashing with load factor\n// array https://leetcode.com/problems/design-hashset/discuss/137257/javascript-solution%3A-100ms.\n// https://leetcode.com/problems/design-hashset/discuss/304242/Javascript-Solution-Easy-To-Understand\n\n// https://javascript.info/class-inheritance\n// interface js\n// strategy pattern\n/*\n\nclass Duck {\n  constructor() {\n   this.flyBehaviour = new Date()\n}\n}\n\nk = new Duck()\n\nclass CanFly {\nfly = () => console.log('fly...')\n}\n\nclass FlyingDuck extends Duck {\n   constructor() {\n    super();\n    this.newFly = new CanFly();\n}\n}\npp = new CanFly()\npp = new FlyingDuck()\npp.flyBehaviour\npp.newFly.fly()\n*/\n\nexport {\n  HashSet,\n  HashSetVariant1,\n}\n","/*\nHackerrunk: Ice Cream parlor\nLeetcode\n1. Two sum\neasy\n\nGiven an array of integers,\nreturn indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\n\nExample:\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n\nHint 1\nA really brute force way would be to search for all possible pairs\nof numbers but that would be too slow.\nAgain, it's best to try out brute force solutions for just for completeness.\nIt is from these brute force solutions that you can come up with optimizations.\n\nHint 2\nSo, if we fix one of the numbers, say x,\nwe have to scan the entire array to find the next number y\nwhich is value - x\nwhere value is the input parameter.\nCan we change our array somehow so that this search becomes faster?\n\nHint 3\nThe second train of thought is, without changing the array,\ncan we use additional space somehow?\nLike maybe a hash map to speed up the search?\n\nFollow up:\nWhat if the given input is already sorted in ascending order?\nSee Question [2. Two Sum II  Input array is sorted].\n*/\n\n/*\nApproach brute force\n\nQ. Are numbers are integer?\nQ. Could numbers be negative?\n\nIntuition\nLoop through each element x\nand find if there is another value that equals to target  x.\n\n\nTime complexity\nAs finding another value requires looping through the rest of array,\nits runtime complexity is O(n^2).\n\nSpace complexity is O(1)\n*/\nfunction twoSumBruteForce(arr, sum) {\n  const len = arr.length;\n  if (len === 0) return [];\n\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (arr[j] === sum - arr[i]) {\n        return [i, j]\n      }\n    }\n  }\n\n  // todo\n  // throw new Error('No two sum solution');\n  return -1;\n}\n\n/*\nApproach 2 Two-pass hash table\nUse Map\n\nTo improve our run time complexity, we need a more efficient way\nto check if the complement exists in the array.\nIf the complement exists, we need to look up its index.\nWhat is the best way to maintain a mapping of each element\nin the array to its index? A hash table.\n\nWe reduce the look up time from O(n) to O(1) by trading space for speed.\nA hash table is built exactly for this purpose, it supports fast look up\nin near constant time. I say \"near\" because if a collision occurred,\na look up could degenerate to O(n) time.\nBut look up in hash table should be amortized O(1) time as long as\nthe hash function was chosen carefully.\n\nA simple implementation uses two iterations.\nIn the first iteration, we add each element's value and its index\nto the table. Then, in the second iteration we check if each element's\ncomplement (target - nums[i]) exists in the table.\nBeware that the complement must not be nums[i] itself!\n\nComplexity Analysis:\nTime complexity : O(n). We traverse the list containing n elements exactly\ntwice. Since the hash table reduces the look up time to O(1),\nthe time complexity is O(n).\n\nSpace complexity: O(n). The extra space required depends on\nthe number of items stored in the hash table,\nwhich stores exactly n elements.\n*/\n\nfunction twoSumTwoPassHashes(arr, target) {\n  const len = arr.length;\n  if (len === 0) return [];\n\n  let map = new Map();\n  for (let i = 0; i < arr.length; i++) {\n    map.set(arr[i], i)\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    const complement = target - arr[i];\n    // Beware that the complement must not be nums[i] itself!\n    if (map.has(complement) && map.get(complement) !== i) {\n      return [i, map.get(complement)]\n    }\n  }\n\n  return -1;\n}\n\n/*\nApproach one-pass hash table\n\nWe could reduce the runtime complexity of looking up\na value to O(1) using a hash map\nthat maps a value to its index.\n\nIt turns out we can do it in one-pass. While we iterate and inserting elements\ninto the table, we also look back to check if current element's\ncomplement already exists in the table.\nIf it exists, we have found a solution and return immediately.\n\n1 Create an object containing the key-value pairs of the element and its index,\nrespectively.\n2 Iterate through an array. For currentElement, compute complement.\n\nTime complexity: O(n). We traverse the list containing n elements\nonly once. Each look up in the table costs only O(1) time.\n\nSpace complexity: O(n). The extra space required depends on the number\nof items stored in the hash table, which stores at most n elements.\n*/\n\n/*\n * @param {number[]} arr\n * @param {number} target\n * @return {number[]}\n*/\n\n// Example\n// { 2: 0, 7: 1, 11: 2, 15 : 2}\n// target 9\nfunction twoSum(arr, target) {\n  const len = arr.length;\n  if (len === 0) return [];\n\n  let hash = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    const complement = target - arr[i]; // is 7\n    const index2 = hash[complement];\n    if (index2 !== undefined) {\n      return [index2, i]\n    } else {\n      hash[arr[i]] = i;\n    }\n  }\n\n  // or through an exception\n  // throw new Error('No two sum solution');\n  return -1;\n}\n\nexport {\n  twoSum,\n  twoSumBruteForce,\n  twoSumTwoPassHashes\n}\n","/*\nLeetcode\n274 H-index\nmedium\n\nGiven an array of citations (each citation is a non-negative integer)\nof a researcher, write a function to compute the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h\nif h of his/her N papers have at least h citations each, and the other N  h papers\nhave no more than h citations each.\"\n\nExample:\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of\nthem had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining\ntwo with no more than 3 citations each, her h-index is 3.\n\nNote: If there are several possible values for h, the maximum one is taken as\nthe h-index.\n\nHint 1\nAn easy approach is to sort the array first.\n\nHint 2\nWhat are the possible values of h-index?\n\nHint 3\nA faster approach is to use extra space.\n*/\n\n\n/*\n\nCounting sort\nO(n) time\ninput is only positive integers\ncounters occurence\narr = [4,3,1,2,0]\nk is amount of unique values\nlaregest item is 4\ntrack occurences of numbers 0,1,2,3,4\ncount 0  1  2  3  4 - 5 positions\n      1  1  1   1  1\nput 1 at position 4\nput 1 at position 3\nput 1 at position 1\nput 1 at position 2\nput 1 at position 0\n\neach of items occured just once - [1,1,1,1,1] this array holds elements from 0 to k -1\n5 total items which is k\n\nrunning sum start from position 1 what is value here + value behind me: 1+ 1\nindex 1  count: 1 2 1 1 1\nindex 2 count: 1 2 3 1 1 - value at pos 2 + value behind me\n3: 1 2 3 4 1\n4: 1 2 3 4 5 just took running sums\n\nindex 3 has a value of 4 = there 4 occurrence of value less than of equal 3 =\nwe have 0,1,2,3\nlet say we have index 2 = 0,1,2\n\nplacement step\nplace a role in placements\nrepresent last position item can occur\n\nfinal work backwards\ncount array 1 2 3 4 5\n0\n0\n\n4 for loops\n\ntime is linear\n\ntodo\nhttps://github.com/bephrem1/backtobackswe/blob/master/Sorting%2C%20Searching%2C%20%26%20Heaps/CountingSort/CountingSort.java\nvideo https://www.youtube.com/watch?v=1mh2vilbZMg\n*/\n\n/*\nApproach\n\ntodo explanation https://www.youtube.com/watch?v=zzTUtpBQh4k\n*/\nvar hIndexSort = function(citations) {\n  if (citations === null || citations.length === 0) return 0;\n  citations = citations.sort((a,b) => a - b);\n  const n = citations.length;\n  for (let i = 1; i <= n; i++) {\n    if (citations[n-i] >= i) break;\n    return i-1;\n  }\n  return 0\n}\n\n/*\nApproach sort\n\ntime is O(n log n)\nspace is O(1)\n\n*/\nvar hIndexSort = function(citations) {\n  if (citations === null || citations.length === 0) return 0;\n  //debugger\n  citations = citations.sort((a,b) => a - b);\n  const n = citations.length;\n  for (let i = 0; i < n; i++) {\n    if (citations[i] >= n - i) return n - i\n  }\n  return 0;\n}\n\n// provide a test\nconsole.log('hIndexSort', hIndexSort([3,0,6,1,5]));\nconsole.log('hIndexSort 1', hIndexSort([0,1,1,1,1,1,2,2,2,2]));\n\n/*\nApproach\n\nThe idea is to see that the result can only range from 0 to the length of the array\n(because we can't have h-index greater than the total papers published)\nSo we create an array which acts like a HashMap and loop backwards form the highest\nelement, then we find total which is the total number of papers that has more than\ni citations, and we stop when total > i\n(total number of papers with more that i citation >= i)\nwe don't need to keep going because we are trying the biggest i possible, we stop\nand return result\n\ncomplexity\n...\n*/\n// todo bucket sort https://eavis.gitbooks.io/leetcode/content/h-index.html\n// count sort\n/**\n * @param {number[]} citations\n * @return {number}\n */\nvar hIndex = function(citations) {\n  const n = citations.length;\n  let total = 0;\n  let arr = new Array(n+1).fill(0);\n\n  for (let i = 0; i < n; i++) {\n    if (citations[i] >= n) arr[n]++\n    else {\n      arr[citations[i]]++\n    }\n  }\n  //debugger\n\n  for (let i = n; i > 0; i--) {\n    total += arr[i];\n    if (total >= i) return i;\n  }\n\n  console.log('arr', arr)\n  return 0;\n};\n\n// provide a test\nconsole.log('hIndex', hIndex([3,0,6,1,5]))\n\n/*\nLeetcode\n275 H-index II\nmedium\n\nGiven an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N  h papers have no more than h citations each.\"\n\nExample:\n\nInput: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had\n             received 0, 1, 3, 5, 6 citations respectively.\n             Since the researcher has 3 papers with at least 3 citations each and the remaining\n             two with no more than 3 citations each, her h-index is 3.\n\nNote:\nIf there are several possible values for h, the maximum one is taken as the h-index.\n\nFollow up:\nThis is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order.\nCould you solve it in logarithmic time complexity?\n*/\n\n// todo https://github.com/bobwei/algorithms/blob/master/src/leetcode/h-index-ii/index.js\n// wiki https://en.wikipedia.org/wiki/H-index\n// https://leetcode.com/problems/h-index-ii/discuss/71063/Standard-binary-search\n// https://leetcode.com/problems/h-index-ii/discuss/71124/Java-binary-search-simple-and-clean\n\n// tests\n\n\nexport {\n  hIndex,\n  hIndexSort\n}\n","import React from 'react';\nimport Details from './../Details';\n\nimport { HashTable as HashMap } from \"../../ds/hash/hashMap/hashMap-use-array\";\nimport { HashSet, HashSetVariant1 } from \"../../ds/hash/hashSet/hashSet-use-object\";\n\n// problems\nimport { twoSumBruteForce, twoSum, twoSumTwoPassHashes } from \"../../leetcode/array/sum-problems/two-sum\";\nimport { hIndex } from '../../leetcode/hash/274-h-index';\n// import { prisonAfterNDays } from '../../leetcode/hash/957-prison-cells-after-N-days'\n\nexport default function Hash() {\n  return (\n    <div className=\"hash\">\n      <h2>Hash / Hash Table</h2>\n\n        <ul>\n          <Details\n            id=\"test\"\n            question=\"\"\n            code={hIndex.toString()}\n            //code={prisonAfterNDays.toString()}\n          />\n\n        <li>\n          <Details\n            id=\"hashMap\"\n            question=\"HashMap / HashTable implementation: use array\"\n            code={HashMap.toString()}\n            time=\"\"\n            space=\"\"\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"hashSet\"\n            question=\"HashSet implementation: use object\"\n            code={HashSet.toString()}\n            secondCode={HashSetVariant1.toString()}\n            time=\"\"\n            space=\"\"\n          />\n        </li>\n\n\n\n        <li>\n          <Details\n            id=\"search-two-sum\"\n            question=\"Two sum using hash\"\n            solution={`\n              Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n              You may assume that each input has exactly one solution.\n              And you may not use the same element twice.\n            `}\n            time=\"O(n)\"\n            space=\"O(n). The extra space required depends on the number of items stored in the hash table, which stores exactly nn elements\"\n            code={twoSumBruteForce.toString()}\n            secondCode={twoSumTwoPassHashes.toString()}\n            thirdSolution={twoSum.toString()}\n          />\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","/*\nLeetcode\n733 Flood Fill\neasy\n\nAn image is represented by a 2-D array of integers, each integer representing\nthe pixel value of the image (from 0 to 65535).\nGiven a coordinate (sr, sc) representing the starting pixel (row and column)\nof the flood fill, and a pixel value newColor, \"flood fill\" the image.\n\nTo perform a \"flood fill\", consider the starting pixel, plus any pixels\nconnected 4-directionally to the starting pixel of the same color as the\nstarting pixel, plus any pixels connected 4-directionally to those pixels\n(also with the same color as the starting pixel), and so on.\nReplace the color of all of the aforementioned pixels with the newColor.\n\nNote\nThe length of image and image[0] will be in the range [1, 50].\nThe given starting pixel will satisfy 0 <= sr < image.length and\n0 <= sc < image[0].length.\nThe value of each color in image[i][j] and newColor will be an integer in [0, 65535].\n\nHint\nWrite a recursive function that paints the pixel if it's the correct color,\nthen recursion on neighboring pixels.\n\nExample 1\nInput: image = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\n\nExplanation\nFrom the center of the image ( with position (sr, sc) = (1, 1) ), all pixels connected\nby a path of the same color as the starting pixel are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected\nto the starting pixel.\n\nFlood fill also called seed fill, is an algorithm that determines the area\nconnected to a given node in a multi-dimensional array. The flood-fill algorithm\ntakes three parameters:\na start node,\na target color,\nand a replacement color.\n\nIn computer graphics, a bitmap image or a raster graphics is a dot matrix data\n(2 dimensional array) structure that represents a generally rectangular\ngrid of pixels (points of color), viewable via a monitor, paper.\n\nA bitmap is a rectangular grid of pixels, with each pixel's color being specified\nby a number of bits. A raster is technically characterized by the width and\nheight of the image in pixels and by the number of bits per pixel (or color depth,\nwhich determines the number of colors it can represent).\n*/\n\n/*\nApproach 1: DFS via recursion\n\nIntuition\nWe perform the algorithm explained in the problem description:\npaint the starting pixels, plus adjacent pixels of the same color, and so on.\n\nAlgorithm\nSay color is the color of the starting pixel.\nLet's flood-fill the starting pixel: we change the color of that pixel to the\nnew color, then check the 4 neighboring pixels to make sure they are valid pixels\nof the same color, and of the valid ones, we flood-fill those, and so on.\n\nWe can use a function dfs to perform a flood-fill on a target pixel.\nAnd check a boundary conditions to prevent infinite loop.\n\nComplexity Analysis\nTime Complexity: O(N), where N is the number of pixels in the image.\nWe might process every pixel.\n\nSpace Complexity: O(N), the size of the implicit call stack when calling dfs.\n*/\n\n/**\n * @param {number[][]} image\n * @param {number} sr\n * @param {number} sc\n * @param {number} newColor\n * @return {number[][]}\n*/\nvar floodFill = function(image, row, col, newColor, startingColor = image[row][col]) {\n  // handle if the coordinate is out of bounds\n  // FIRST check indexes outs of bound (ORDER is important) and then your condition\n\t// or if it is already the new color\n  // or if it's not from the original color we're trying to change\n  if (\n    row < 0 ||\n    col < 0 ||\n    row >= image.length ||\n    col >= image[row].length ||\n    image[row][col] !== startingColor ||\n    image[row][col] === newColor\n  ) return image; // return image as it is\n\n  // make it equal to new color\n  image[row][col] = newColor;\n\n  // going to 4 directions\n  floodFill(image, row - 1, col, newColor, startingColor); // top row\n  floodFill(image, row + 1, col, newColor, startingColor); // bottom row\n  floodFill(image, row, col - 1, newColor, startingColor); // left column\n  floodFill(image, row, col + 1, newColor, startingColor); // right column\n\n  return image\n};\n\n/*\nThe same approach: DFS via recursion helper method.\n\nWhy this approach called DFS?\nbecause of visited flag?\n\nWe can use a function dfs to perform a flood-fill on a target pixel.\nAnd check a boundary conditions + visited flag to prevent infinite loop.\n\nKeep track of what color was at the beginning startingColor = original color image\ninput = [\n  [1,1,1],\n  [1,1,0],\n  [1,0,1]\n]\nanything you change, you keep doing it connectively\noutput = [\n  [2,2,2],\n  [2,2,0],\n  [2,0,1]\n]\n\nThere are three things that you need to consider once you have identified that\na question can be solved using DFS\n1 The base case (return condition)\n2 Mark that node as visited\n3 nGiven that I am at a particular node what operations do I need to perform\n\nThe base case:\nThe current node cannot\na) Exit the matrix bounding condition\nb) Different from the base color\nc) Be a node that we have already visited\n\nTime complexity is proportional to a number of pixes\nwe have to fill rows * cols or O(n)\n*/\nvar floodFillUseHelper = function(img, sr, sc, newColor) {\n  // sr - starting row\n  // sc - starting col\n  const color = img[sr][sc]; // starting color\n  if (color !== newColor) {\n    helper(img, sr, sc, color, newColor)\n  }\n  // else color === newColor just return an image, blue === blue\n  return img;\n}\n\nfunction helper(img, i, j, originalColor, newColor) {\n  // check out of bounds to prevent infinite loop + our condition\n  const rows = img.length;\n  const cols = img[0].length;\n  if (\n    i < 0 || i >= rows ||\n    j < 0 || j >= cols ||\n    // if color is not a color I started with\n    // Without checking if (color != newColor), your program will keep moving\n    // around in the image visited flag: we are using the changing colour to\n    // keep track of which pixels we've already visited.\n    // If the colour doesn't change, we forget where we've been and visit the\n    // same pixels over and over again.\n    img[i][j] !== originalColor\n  ) return;\n\n  // starts from the middle as the starting pixel, changes itself to a new color\n  // have to modify color position\n  img[i][j] = newColor;\n  // exploring all directions\n  // replaces those that had the same number as the one the starting pixel had\n  helper(img, i - 1, j, originalColor, newColor);\n  helper(img, i + 1, j, originalColor, newColor);\n  helper(img, i, j - 1, originalColor, newColor);\n  helper(img, i, j + 1, originalColor, newColor);\n}\n\n/*\nApproach BFS\n\nCreate a queue with queue = [[sr,sc]]. Dequeue a queue, go to 4 directions and\ncheck of i,j are not out of boundary.\n\ntime is O(n) need to visit all nodes\nspace is O(n)\n*/\nconst floodFillBFS = function(img, sr, sc, newColor) {\n  const rows = img.length;\n  const cols = img[0].length;\n  const startingColor = img[sr][sc];\n\n  if (startingColor === newColor) return img;\n\n  // if startingColor !== newColor\n  let queue = [[sr,sc]];\n\n  while (queue.length) {\n    const [i, j] = queue.shift();\n    if (img[i][j] === startingColor) {\n      img[i][j] = newColor;\n      if (i-1 >= 0) queue.push([i-1, j]); // up\n      if (i+1 < rows) queue.push([i+1, j]); // down\n      if (j-1 >= 0) queue.push([i, j-1]); // left\n      if (j+1 < cols) queue.push([i, j+1]); // right\n    }\n  }\n\n  return img;\n}\n\n\n/*\nApproach: Depth-First Search\nI'm not sure that it's correct solution\n\n*/\nconst floodFillDFS = function(img, sr, sc, newColor) {\n  const rows = img.length;\n  const cols = img[0].length;\n  const startingColor = img[sr][sc]\n  if (startingColor === newColor) return img;\n\n  let stack = [[sr,sc]];\n  while (stack.length) {\n    const [i,j] = stack.pop();\n    if (img[i][j] === startingColor) {\n      img[i][j] = newColor;\n\n      if (i-1 >= 0) stack.push([i-1, j]); // up\n      if (i+1 < rows) stack.push([i+1, j]); // down\n      if (j-1 >= 0) stack.push([i, j-1]); // left\n      if (j+1 < cols) stack.push([i, j+1]); // right\n    }\n  }\n\n  return img;\n}\n\n// tests\n// let input = [\n//   [1,1,1],\n//   [1,1,0],\n//   [1,0,1]\n// ]\n// console.log('floodFillUseHelper', floodFillUseHelper(input, 1, 1, 2))\n// console.log('floodFillDFS', floodFillDFS(input, 1, 1, 2))\n\nexport {\n  floodFill,\n  floodFillUseHelper,\n  floodFillBFS,\n  floodFillDFS\n}\n","import React from 'react';\nimport Details from '../Details';\n\n// problems\n// dfs\nimport { floodFill, floodFillUseHelper } from '../../leetcode/graph/dfs/733-flood-fill';\n// bfs\n// import { rottingOranges } from '../../leetcode/graph/bfs/994-rotting-oranges';\n// import { allPathsSourceTarget } from '../../leetcode/graph/bfs/797-all-paths-from-source-target';\n// import { exist } from '../../leetcode/backtracking/79-word-search';\n// import { solve } from '../../leetcode/graph/dfs/130-surrounded-regions';\n\nexport default function Graph() {\n  return (\n    <div className=\"graph\">\n      <h2>Graph</h2>\n\n      <ul id=\"graph\">\n        <li>\n        <Details\n            id=\"test\"\n            question=\"test\"\n            //code={rottingOranges.toString()}\n            //code={findMin.toString()}\n            //secondCode={exist.toString()}\n            //thirdSolution={solve.toString()}\n          />\n        </li>\n        <li>\n          <Details\n            id=\"graph-dfs-flood-fill\"\n            question=\"Flood fill image bitmap algorithm using dfs (Depth-First Search)\"\n            solution=\"We can use a function dfs to perform a flood-fill on a target pixel.\"\n            time=\"O(N), where N is the number of pixels in the image. We might process every pixel\"\n            space=\"O(N), the size of the implicit call stack when calling dfs.\"\n            code={floodFill.toString()}\n            secondCode={floodFillUseHelper.toString()}\n          />\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","/*\nImplementation BT\n\ninsertNode(val) iterative approach\n\nAlgorithm:\nStep 1: Create a function to insert the given node and pass two arguments to it,\nthe root node and the data to be inserted.\n\nStep 2: Define a temporary node to store the popped out nodes from the queue for\nsearch purpose.\n\nStep 3: Define a queue to store the nodes of the binary tree.\n\nStep 4: Push the root node inside the queue data structure.\n\nStep 5: Start a while loop and check for the condition that whether the queue is\nempty or not, if not empty then go to Step 6, else go to Step 9.\n\nStep 6: Pop out the first node from the queue and store it inside the temporary node.\n\nStep 7: Check, for the current pooped out node, in the binary tree, inside the\nwhile loop, if its left child(in binary tree) is null then call the memory\nallocation method for the new node, with its left and right child set as null\nand then insert the given node to its new position else push its left child in\nthe queue data structure.\n\nStep 8: Similarly repeat Step 7 for the right child of the current node in the\nbinary tree.\n\nStep 9: End of while loop.\n\nStep 10: End of the function.\n\ntime is O(log n)\nspace is O(1)\n*/\n\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = (val === undefined) ? 0 : val;\n    this.left = (left === undefined) ? null : left;\n    this.right = (right === undefined) ? null : right;\n  }\n}\n\nclass BT {\n  constructor(val) {\n    this.root = new TreeNode(val);\n  }\n\n  // iterative approach\n  insert(val, root = this.root) {\n    const newNode = new TreeNode(val);\n\n    if (root === null) {\n      root = newNode;\n    }\n\n    let queue = [];\n    queue.push(root);\n\n    // Do level order traversal until we find\n    // an empty place.\n    while (queue.length) {\n      let node = queue[0];\n      queue.shift();\n\n      if (node.left === null) {\n        node.left = newNode;\n        break;\n      } else {\n        queue.push(node.left);\n      }\n\n      if (node.right === null) {\n        node.right = newNode;\n        break;\n      } else {\n        queue.push(node.right)\n      }\n\n    }\n  }\n\n  // recursion approach\n  // insertNode(val, node = this.root) {\n  // ...\n  // }\n}\n\n// todo\n// BT recursive approach\n// https://www.netjstech.com/2019/03/binary-tree-implementation-in-java-insertion-traversal.html#BinarytreeInsertItr\n\n// tests\n// todo doesn't work, case with null\n// input [1,null,2,3]\n// let tree = new BT(1);\n// tree.insert(null);\n// tree.insert(2);\n// tree.insert(3);\n// tree = JSON.parse(JSON.stringify(tree)).root;\n// console.log('BT tree', tree);\n\nexport {\n  BT\n}\n","/**\n * Binary Search Tree implementation in JavaScript\n * Nodes as objects\n */\nclass Node {\n  constructor(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left); // left pointer\n    this.right = (right === undefined ? null : right); // right pointer\n  }\n}\n\n/**\n * Represents a single node in a BinarySearchTree.\n * @class BinarySearchTree\n */\nclass BinarySearchTree {\n  constructor(val) {\n    this.root = new Node(val);\n    this.count = 1; // how many nodes in Tree\n  }\n\n  size() {\n    // count doesn't work correctly with duplicated nodes\n    return this.count;\n  }\n\n  /**\n    * Recursive approach\n    * Adds some value into the tree. This method traverses the tree to find\n    * the correct location to insert the value. Duplicate values are discarded.\n    * @param {*} val The value to add to the tree.\n    * @returns {void}\n  */\n  insert(val) {\n    let currentNode = this.root;\n\n    // search\n    const check = (node) => {\n      /*\n      * Create a new node to insert into the tree and store the value in it.\n      * This node will be added into the tree.\n      */\n      const newNode = new Node(val);\n\n      if (node === null) {\n        node = newNode;\n      } else if (val === node.val) {\n        // case with duplicated\n        console.log('equal val');\n        return null;\n      } else if (val < node.val) {\n         // if value less than node value, go left\n        if (node.left === null) {\n          node.left = newNode;\n        } else {\n          check(node.left)\n        }\n      } else {\n        // if value bigger than node value go right\n        if (node.right === null) {\n          node.right = newNode;\n        } else {\n          check(node.right)\n        }\n      }\n    }\n\n    // call search on root node\n    check(currentNode);\n    this.count++;\n  }\n\n  /*\n  * Insertion Node iteratively\n  */\n  insertNode(val, root = this.root) {\n    const newNode = new Node(val);\n\n    let x = root;\n    let y = null; // last node at the moment = leaf\n\n    while (x !== null) {\n      y = x;\n      if (val <= x.val) {\n        x = x.left;\n      } else {\n        x = x.right;\n      }\n    }\n\n    // now y is leaf\n    if (y === null) {\n      y = newNode;\n    } else if (val <= y.val) {\n      y.left = newNode;\n    } else {\n      y.right = newNode;\n    }\n\n    this.count++;\n  }\n\n  /**\n    * search\n    * The contains() method accepts a value as an argument and\n    * returns true if the value is present in the tree or false if not.\n  */\n  contains(val) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (val === currentNode.val) {\n        return true\n      }\n\n      if (val < currentNode.val) {\n        currentNode = currentNode.left\n      } else {\n        currentNode = currentNode.right\n      }\n    }\n\n    return false;\n  }\n\n  // im not sure that this is correct solution\n  // height of binary tree, should return '-1' when root is NULL.\n  height(node = this.root) {\n    // empty node\n    if (node === null) return -1;\n\n    if (node.left === null && node.right === null) {\n      return 0\n    }\n\n    if (node.left === null) {\n      return this.height(node.right) + 1\n    }\n\n    if (node.right === null) {\n      return this.height(node.left) + 1\n    }\n\n    const leftHeight = this.height(node.left);\n    const rightHeight = this.height(node.right);\n\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n\n  // Start at root and check if p and q are less, then go left, otherwise go right\n  // p is v1\n  // q is v2\n  lowestCommonAncestor(\n    p,\n    q,\n    node = this.root\n  ) {\n    if (node.value > p && node.value > q) {\n      return this.lowestCommonAncestor(p, q, node.left)\n    } else if (node.value < p && node.value < q) {\n      return this.lowestCommonAncestor(p, q, node.right)\n    } else {\n      return node\n    }\n  }\n}\n\n// tests\nconst tree = new BinarySearchTree(4);\ntree.insert(2)\ntree.insert(3)\ntree.insert(1)\n// tree.insert(7)\n// tree.insert(6)\n//console.log('BST', tree)\n\n\ntree.lowestCommonAncestor(2,7) // should be 4 it's not correct\n//console.log('lca', tree.lowestCommonAncestor(2,7));\n// console.log('size', tree.size());\n\n// todo move each method separately?\n// height\n// depth\n/*\nIn a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.\n\nTwo nodes of a binary tree are cousins if they have the same depth, but have different parents.\n\nWe are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.\n\nReturn true if and only if the nodes corresponding to the values x and y are cousins.\n\n\n\nExample 1:\n\n\nInput: root = [1,2,3,4], x = 4, y = 3\nOutput: false\nExample 2:\n\n\nInput: root = [1,2,3,null,4,null,5], x = 5, y = 4\nOutput: true\nExample 3:\n\n\n\nInput: root = [1,2,3,null,4], x = 2, y = 3\nOutput: false\n\n\nConstraints:\n\nThe number of nodes in the tree will be between 2 and 100.\nEach node has a unique integer value from 1 to 100.\n */\n/**\n * 993\n *\n *\n * family tree = generation tree\n * same generation\n * different parent\n * shouldn't be siblings\n *\n * conditions:\n * and same level - same generation\n * and shouldn't be siblings\n *\n * find depth for search\n *\n * traverse to the tree: check x and y and track depth and track parent\n *\n * let parent = -1\n *\n * todo fill in task\n */\n// doesn't work\n// [1,2,3,null,4,null,5]\n// 5\n// 4\n// true\n// wrong\n// var isCousins = function name(root, x, y) {\n//   let xParent, yParent;\n//   let xDepth, yDepth;\n\n//   const dfs = (node, parent, depth, x, y) => {\n//     if (node === null) {\n//       return false\n//     }\n\n//     if (node.val === x) {\n//       xParent = parent;\n//       xDepth = depth\n//     }\n\n//     if (node.val === y) {\n//       yParent = parent;\n//       yDepth = depth\n//     }\n\n//     dfs(node.left, parent, depth + 1, x, y);\n//     dfs(node.right, parent, depth + 1, x, y);\n//   }\n\n//   // call\n//   dfs(root, null, 0, x, y)\n\n//   if (xDepth === yDepth && xParent !== yParent ) {\n//     return true\n//   } else {\n//     return false\n//   }\n// }\n\n// correct solution\n// var isCousins = function(root, x, y) {\n//   const dfs = (node, target, depth, parent) => {\n//     if (!node) return null;\n//     if (node.val === target) return { depth, parent };\n\n//     return dfs(node.left, target, depth + 1, node.val)\n//            || dfs(node.right, target, depth + 1, node.val);\n//   };\n\n//   const xMeta = dfs(root, x, 0, null);\n//   const yMeta = dfs(root, y, 0, null);\n\n//   return (xMeta.depth === yMeta.depth)\n//          && (xMeta.parent !== yMeta.parent);\n// };\n\n// var isCousins = function name(root, x, y) {\n//   const dfs = (node, parent, depth, x, y) => {\n//     if (!node) {\n//       return null\n//     }\n\n//     if (node.val === parent) {\n//       return { parent, depth}\n//     }\n\n//     dfs(node.left, parent, depth + 1, x, y);\n//     dfs(node.left, parent, depth + 1, x, y);\n//   }\n\n//   // call\n//   dfs(root, null, 0, x, y)\n\n//   if (xDepth === yDepth && xParent !== yParent ) {\n//     return true\n//   } else {\n//     return false\n//   }\n// }\n\n// var isCousins = function name(root, x, y) {\n//   let tracker = {};\n\n//   const dfs = (node, parent, depth, x, y) => {\n//     if (node === null) {\n//       return\n//     }\n\n//     dfs(node.left, node, depth+1, x, y);\n//     dfs(node.left, node, depth+1, x, y);\n\n//     if (node.val === x || node.val === y) {\n//       // tracker[node.val] = parent depth\n//     }\n\n//     dfs(root, null, 0, x, y)\n//   }\n// }\n\n//isCousins([1,2,3,null,4], 2, 3)\n\nexport { BinarySearchTree }\n\n\n","/*\nLeetcode\n226. Invert Binary Tree\neasy\n\nAn inversion, or mirror, of a Binary Tree,\nis just a Binary Tree whose left and right children\n(of all non-leaf nodes) are swapped.\n\nThe inverse of an empty tree is the empty tree.\n\nTrivia:\nThis problem was inspired by this original tweet by Max Howell:\nGoogle: 90% of our engineers use the software you wrote (Homebrew),\nbut you cant invert a binary tree on a whiteboard so f*** off.\n\nExample:\nInput:\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\nOutput:\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\ninput [4,2,7,1,3,6,9]\noutput [4,7,2,9,6,3,1]\n\nInput [1,2]\nOutput [1,null,2]\n*/\n\n// Definition for a binary tree node.\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = (val === undefined ? 0 : val)\n    this.left = (left === undefined ? null : left)\n    this.right = (right === undefined ? null : right)\n  }\n}\n\nclass BinarySearchTree {\n  constructor(val) {\n    this.root = null;\n  }\n\n  add(val) {\n    const node = this.root;\n\n    if (node === null) {\n      this.root = new TreeNode(val);\n    } else {\n      // recursion function\n      const searchTree = node => {\n        if (val < node.val) {\n          if (node.left === null) {\n            node.left = new TreeNode(val);\n          } else if (node.left !== null) {\n            // continue searching\n            return searchTree(node.left)\n          }\n        } else if (val > node.val) {\n          if (node.right === null) {\n            node.right = new TreeNode(val);\n          } else if (node.right !== null) {\n            return searchTree(node.right)\n          }\n        } else return null;\n      }\n      searchTree(node);\n    }\n  }\n}\n\n\n/*\nApproach recursive\nThis is a classic tree problem that is best-suited for a recursive approach.\n\nAlgorithm\nThe inverse of an empty tree is the empty tree.\nThe inverse of a tree with root r, and subtrees right and left,\nis a tree with root r, whose right subtree is the inverse of left,\nand whose left subtree is the inverse of right.\n\ncall invert for left subtree\ncall invert for right subtree\nswap left and right subtrees\n\nComplexity Analysis\nSince each node in the tree is visited only once,\nthe time complexity is O(n), where n is the number of nodes in the tree.\nWe cannot do better than that, since at the very least\nwe have to visit each node to invert it.\n\nBecause of recursion, O(h) function calls will be placed on the stack\nin the worst case, where h is the height of the tree.\nBecause h O(n), the space complexity is O(n).\n*/\n\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst invertTree = function(node) {\n  if (!node) return null;\n\n  // call invert for left subtree\n  let left = invertTree(node.left);\n  // call invert for right subtree\n  let right = invertTree(node.right);\n\n  // swap left and right subtrees\n  node.left = right;\n  node.right = left;\n\n  return node;\n};\n\n/*\ntodo\nApproach iterative\n\nflip nodes on each layers\nswap leaves of subtree\ndfs\n*/\n\nlet tree4 = new BinarySearchTree();\nconst arr = [4,2,7,1,3,6,9];\n//const arr = [4,2,7];\narr.map((element, index) => {\n  tree4.add(element);\n  return tree4;\n})\ntree4 = JSON.parse(JSON.stringify(tree4)).root;\n\nconst invertedTree = invertTree(tree4);\n//const test = JSON.parse(JSON.stringify(invertedTree))\n// console.log('tree 4', tree4)\n// console.log('invert tree 4', JSON.parse(JSON.stringify(invertedTree)));\n// console.log('test', test.left.val)\n\nexport {\n  invertTree,\n  BinarySearchTree\n}\n","/*\nLeetcode\n144 Binary Tree Preorder Traversal\nmedium\n\nGiven a binary tree, return the preorder traversal of its nodes' values.\n\nExample:\nInput: [1,null,2,3]\n1\n  \\\n    2\n  /\n3\n\nOutput: [1,2,3]\nFollow up: Recursive solution is trivial, could you do it iteratively?\n*/\n\n/*\nApproach Recursive\nTime is O(n)\nspace is O(n)\n*/\nvar preorder = function(root, nodes = []) {\n  if (root) {\n    nodes.push(root.val);\n    preorder(root.left, nodes);\n    preorder(root.right, nodes);\n  }\n\n  return nodes;\n};\n\n\n/*\nApproach Stack + Iterative\n\nDepth-first search: preorder traversal <root><left><right>\n\nI find preorder traversal the easiest to implement iteratively.\nYou can just reuse the dfs algorithm, but make sure you push the children onto\nthe stack in such a way that the left child is processed before\nthe right child.\n\nAlgorithm\n1 visit root\n2 visit left sub-tree (visit all nodes left)\n3 visit right sub-tree (visit all nodes right)\n\nIntuition\n1 Create an empty stack, push root node to the stack\n2 Do following while stack is not empty:\n  2.1 pop an item from the stack and push it to stack\n  2.2 push the right child of popped item to stack.\n  2.3 push the left child of popped item to stack.\n\nComplexity\nIn an average case however, if you are considering a balanced/close-to-balanced tree,\nthe time complexity is always O(n) as you HAVE to visit each node\n\nEach iteration you're going one level deeper and adding 2 elements (right and\nleft if they exist) to the stack while popping one node out (the parent one).\nIt means that at most 1 new element is added as you go 1 level down. Once you reach\nthe left most node and pop it out you repeat the same procedure for the top node\nin the stack -> O(h).\nThe space complexity was always proportional to the height of the tree.\n*/\n\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function(root) {\n  // Initialize the result to an empty array\n  let result = [];\n  if (root === null) return result;\n\n  let nodeStack = [];\n\n  // We do not push the root node onto the stack if the root node is null.\n  // This way we will avoid\n  // going into the while loop when the root is null and just return an empty\n  // array as the result.\n  if (root !== null) {\n    nodeStack.push(root);\n  }\n\n  while (nodeStack.length) {\n    const node = nodeStack.pop();\n    // Do the preorder processing\n    result.push(node.val);\n\n    // If there is a right child, push it onto the stack.\n    if (node.right) nodeStack.push(node.right);\n    // If there is a left child, push it onto the stack.\n    // when order will be root -> left -> right\n    // push last, pop last\n    if (node.left) nodeStack.push(node.left);\n  }\n\n  return result;\n};\n\n// Definition for a binary tree node\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n  }\n}\n\nclass BT {\n  constructor(val) {\n    this.root = new TreeNode(val);\n  }\n\n  // iterative approach\n  insert(val, root = this.root) {\n    const newNode = new TreeNode(val);\n\n    if (root === null) {\n      root = newNode;\n    }\n\n    let queue = [];\n    queue.push(root);\n\n    while (queue.length) {\n      let node = queue[0];\n      queue.shift();\n\n      if (node.left === null) {\n        node.left = newNode;\n        break;\n      } else {\n        queue.push(node.left)\n      }\n\n      if (node.right === null) {\n        node.right = newNode;\n        break;\n      } else {\n        queue.push(node.right)\n      }\n    }\n  }\n}\n\n// tests\n// input [1,null,2,3]\n// Output: [1,2,3]\n// todo\n// let tree = new BT(1);\n// tree.insert(null);\n// tree.insert(2);\n// tree.insert(3);\n// tree = JSON.parse(JSON.stringify(tree)).root;\n// console.log('tree', tree);\n// console.log('preorder', preorder(tree));\n\n// let tree1 = new TreeNode(1);\n// tree1.right = new TreeNode(2);\n// tree1.right.left = new TreeNode(3);\n// console.log('tree', tree1);\n// const preorder1 = preorder(tree1);\n// console.log('preorderTraversal1', preorder1);\n\nvar inorderTraversal = function(root, nodes=[]) {\n  //debugger\n  if (root) {\n\n    inorderTraversal(root.left, nodes);\n    nodes.push(root.val);\n    inorderTraversal(root.right, nodes);\n  }\n\n  return nodes\n};\n\n\n\nlet tree = new TreeNode(1);\ntree.right = new TreeNode(2);\ntree.right.left = new TreeNode(3);\n// tree.insert(null);\n// tree.insert(2);\n// tree.insert(3);\n// tree = JSON.parse(JSON.stringify(tree)).root;\n// console.log('tree', tree);\n// console.log('inorderTraversal', inorderTraversal(tree));\n// const inorder = inorderTraversal(tree);\n// console.log('inorder', inorder); // [1,3,2]\n\n// https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/929/\n\n\n\n// const build = buildTree([9,3,15,20,7], [9,15,7,20,3])\n// // inorder = [9,3,15,20,7]\n// // postorder = [9,15,7,20,3]\n// console.log('build tree', build)\n\nexport {\n  preorder,\n  preorderTraversal,\n  BT,\n  TreeNode\n}\n","/*\nLeetcode\n102 Binary Tree Level Order Traversal\nmedium\n\nGiven a binary tree, return the level order traversal of its nodes' values.\n(ie, from left to right, level by level).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its level order traversal as:\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val === undefined ? 0 : val)\n *     this.left = (left === undefined ? null : left)\n *     this.right = (right === undefined ? null : right)\n * }\n*/\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n  }\n}\n\n/*\nApproach iterative, Queue\nBreadth-first Search - exploring every level before going further\n\nprintLevelorder(tree)\n1) Create an empty queue q (FIFO)\n2) put root into the queue\n3) Loop while until queue is not empty\n  a) create temp node\n  b) Enqueue nodes children (first left then right children) to q\n  c) Dequeue a node from q and assign its value to temp_node\n\nTime complexity is O(n) visit all nodes.\nSpace depends on Queue size. In worst case we need to move all leaf nodes,\nmaximum BT has n/2 leas, space is O(n)\n*/\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function(root) {\n  let result = [];\n  if (!root) return result;\n\n  let queue = [];\n  queue.push(root);\n\n  while (queue.length) {\n    const node = queue.shift();\n    result.push(node.val);\n\n    if (node.left) queue.push(node.left);\n    if (node.right) queue.push(node.right);\n  }\n\n  return result;\n}\n// on Leetcode you need to push nodes into specific manner\nvar levelOrderForLeetcode = function(root) {\n  let result = [];\n  if (!root) return result;\n\n  let queue = [];\n  queue.push(root);\n\n  while (queue.length > 0) {\n    let size = queue.length;\n    const temp = [];\n\n    for (let i = 0; i < size; i++) {\n      const node = queue.shift();\n      temp.push(node.val);\n      if (node.left) {\n        queue.push(node.left)\n      }\n      if (node.right) {\n        queue.push(node.right)\n      }\n    }\n    result.push(temp);\n  }\n\n  return result;\n};\n\n// tests\nlet tree = new TreeNode(0)\ntree.left = new TreeNode(3);\ntree.right = new TreeNode(2);\ntree.left.left = new TreeNode(9);\ntree.right.right = new TreeNode(10);\nconsole.log('tree', tree);\nconsole.log('levelOrderForLeetcode', levelOrderForLeetcode(tree));\n\n/*\nLeetcode\n107 Binary Tree Level Order Traversal II\nbottom = reverse order\n\nGiven a binary tree, return the bottom-up level order traversal of its nodes'\nvalues. (ie, from left to right, level by level from leaf to root).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its bottom-up level order traversal as:\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n*/\n\n/*\nApproach Queue\n\n1. Add root to queue\n2. pop item in queue and add left and right nodes of that item to queue.\nnow add value of popped to a temporary array\n3. repeat the above step len(queue) no of times\n4. Add that temporary to result array\n5. if size of queue !=0 go to step 2\n6. return reversed result array\n\nTime Complexity: O(n) where n is number of nodes in the binary tree\n(we need to visit every node)\n*/\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrderBottom = function(root) {\n  let result = [];\n  if (!root) return result;\n\n  let queue = [];\n  if (root) queue.push(root);\n\n  while (queue.length) {\n    let size = queue.length;\n    let temp = [];\n    for (let i = 0; i < size; i++) {\n      let node = queue.shift();\n      temp.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    result.unshift(temp);\n  }\n  return result\n};\n\nclass BT {\n  constructor(val) {\n    this.root = new TreeNode(val);\n  }\n\n  // iterative approach\n  insertNode(item, root = this.root) {\n    const newNode = new TreeNode(item);\n    if (!root) root = newNode;\n\n    let queue = [];\n    queue.push(root);\n\n    while (queue.length) {\n      const node = queue.shift();\n      queue.shift()\n      if (node.left === null) {\n        node.left = newNode;\n        break;\n      } else {\n        queue.push(node.left)\n      }\n\n      if (node.right === null) {\n        node.right = newNode;\n        break;\n      } else {\n        queue.push(node.right)\n      }\n    }\n  }\n}\n\n// let tree = new BT(3);\n// tree.insertNode(9);\n// tree.insertNode(20);\n// tree.insertNode(21);\n// tree = JSON.parse(JSON.stringify(tree)).root;\n// console.log('tree', tree);\n// console.log('levelorder', levelOrderBottom(tree));\n\n\nexport {\n  levelOrder,\n  levelOrderForLeetcode,\n  BT,\n  levelOrderBottom\n}\n","/*\nLeetcode\n987 Vertical order traversal of BT\nmedium\n\nGiven a binary tree, return the vertical order traversal of its nodes values.\n\nFor each node at position (X, Y), its left and right children respectively will\nbe at positions (X-1, Y-1) and (X+1, Y-1).\n\nRunning a vertical line from X = -infinity to X = +infinity, whenever the vertical\nline touches some nodes, we report the values of the nodes in order from top to\nbottom (decreasing Y coordinates).\n\nIf two nodes have the same position, then the value of the node that is reported\nfirst is the value that is smaller.\n\nReturn an list of non-empty reports in order of X coordinate.  Every report will\nhave a list of values of nodes.\n\n\nExample 1:\nInput: [3,9,20,null,null,15,7]\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\nOutput: [[9],[3,15],[20],[7]]\nExplanation:\nWithout loss of generality, we can assume the root node is at position (0, 0):\nThen, the node with value 9 occurs at position (-1, -1);\nThe nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);\nThe node with value 20 occurs at position (1, -1);\nThe node with value 7 occurs at position (2, -2).\n\nExample 2:\n     1\n    / \\\n  2     3\n /  \\  /  \\\n4   5  6  7\n\nInput: [1,2,3,4,5,6,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nThe node with value 5 and the node with value 6 have the same position according\nto the given scheme.\nHowever, in the report \"[1,5,6]\", the node value of 5 comes first since 5 is\nsmaller than 6.\n\nNote:\nThe tree will have between 1 and 1000 nodes.\nEach node's value will be between 0 and 1000.\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val === undefined ? 0 : val)\n *     this.left = (left === undefined ? null : left)\n *     this.right = (right === undefined ? null : right)\n * }\n*/\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n  }\n}\n\n/*\nApproach Queue + HashTable without ordering (doesn't required conditions)\n\nIf we do not need to think about ordering, which is described in problem, like\n\n-Running a vertical line from X = -infinity to X = +infinity, in order from top to\nbottom (decreasing Y coordinates).\n\n-If two nodes have the same position, then the value of the node that is reported\nfirst is the value that is smaller.\n\n-Return an list of non-empty reports in order of X coordinate\n\nThen we can calculate hd (horizontal distance)\n\nHD assign to each node:\n1 for root, hd = 0\n2 left child, hd = hd - 1\n3 right child, hd = hd + 1\nNodes with the same hd come to the same vertical line.\n\nFor example [3,9,20,null,null,15,7]\nmin distance -1\nmax distance 2\nhd\n-1 : 9\n0: 3, 15 the same vertical line\n1: 20\n2: 7\n\nAlgorithm BFS(queue) + HashTable\n1 enqueue root\n2 update hd for root as 0\n3 add hd = 0 in HashTable and root as value\n4 dequeue and\n  - check left and right and update hd in HashTable\n  - enqueue the left and the right child\n\nNote: Queue\nqueue(node) - insert to the front of Queue\ndequeue() - return from front\n*/\nvar verticalTraversalWithoutOrder = function(root) {\n  if (root === null) return [];\n\n  let queue = [];\n  let x = 0; // hd\n  let y = 0; // vertical distance\n  if (root !== null) queue.push([root,x,y]);\n\n  let list = [];\n\n\n  while (queue.length) {\n    const [node, x, y] = queue.shift();\n    if (node.left) queue.push([node.left, x-1, y-1]);\n    if (node.right) queue.push([node.right, x+1, y-1]);\n    if (node) list.push([node.val, x, y]);\n  }\n\n  //console.log('list', list);\n\n  let hash = {};\n  // let hashKeys = [];\n  // let hashValues = [];\n  for (let i = 0; i < list.length; i++) {\n    const [val, x, y] = list[i];\n    //debugger\n    if (hash[x] !== undefined) {\n      //debugger\n      let values = hash[x].push(val);\n      hash[x] = values;\n    } else {\n      hash[x] = [val]\n    }\n\n  }\n\n  console.log('list', list);\n  console.log('hash', hash);\n\n  return list;\n\n}\n\n// tests\nlet root = new TreeNode(3)\nroot.left = new TreeNode(9);\nroot.right = new TreeNode(20);\nroot.right.left = new TreeNode(15);\nroot.right.right = new TreeNode(7);\nconsole.log('verticalTraversalWithoutOrder', verticalTraversalWithoutOrder(root));\n\n// const compare = (a, b) => {\n//   if (a[2] - b[2] === 0 ) {\n\n//     if (a[1] - b[1] === 0) {\n//       return a[0] - b[0];\n//     }\n//   }\n\n//   return a[2] - b[2]\n// }\n\n// var verticalTraversal1 = function(root) {\n//   if (root === null) return [];\n\n//   let hash = {};\n//   let queue = [];\n\n//   // x = 0, y = 0 for root\n//   if (root !== null) queue.push([root,0,0]);\n//   let list = [];\n\n//   while (queue.length) {\n//     const [node, x, y] = queue.shift();\n//     //console.log('node', node)\n//     if (node.left) {\n//       queue.push([node.left, x-1, y-1]);\n//     }\n//     if (node.right) {\n//       queue.push([node.right, x+1, y-1]);\n//     }\n//     if (node) list.push([node.val, x, y]);\n//   }\n\n//   console.log('list', list)\n//   list = list.sort(compare);\n//   console.log('list', list);\n\n//   // for (let i = 0; i < list.length; i++) {\n//   //   const [val, x, y] = list[i];\n\n\n//   // }\n\n//   const map = new Map();\n//   for(let i = 0; i < list.length; i++) {\n//     const [value, row, column] = list[i]\n\n//     if (map.has(column)) {\n//       map.get(column).push(value)\n//     } else {\n//       map.set(column, [value]);\n//     }\n//   }\n\n//   return [...map.values()]\n\n//   //return list;\n// }\n\nvar verticalTraversal = function(root) {\n  if (root == null) {\n      return [];\n  }\n\n  const queue = [];\n\n  queue.push([root, 0, 0]);\n  const list = [];\n  while(queue.length > 0) {\n      const [node, row, column] = queue.shift();\n\n\n      if (node) {\n          queue.push([node.left, row + 1, column - 1])\n          queue.push([node.right, row + 1, column + 1])\n          list.push([node.val, row, column]);\n      }\n  }\n\nconst compare = (a, b) => {\n  if (a[2] - b[2] === 0 ) {\n\n    if (a[1] - b[1] === 0) {\n      return a[0] - b[0];\n    }\n  }\n\n  return a[2] - b[2]\n}\n\n list.sort(compare)\n\nconst map = new Map();\nfor(let i = 0; i < list.length; i++) {\n  const [value, row, column] = list[i]\n\n  if (map.has(column)) {\n    map.get(column).push(value)\n  } else {\n    map.set(column, [value]);\n  }\n}\n\nreturn [...map.values()]\n};\n\n// tests\n// let tree = new TreeNode(3)\n// tree.left = new TreeNode(9);\n// tree.right = new TreeNode(20);\n// tree.right.left = new TreeNode(15);\n// tree.right.right = new TreeNode(7);\n//console.log('tree', tree);\n//console.log('verticalTraversal', verticalTraversal(tree));\n\n// solution https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/777997/JavaScript-Clean-BFS-Beat-97\n// check https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/773459/Javascript-BFS-solution\n// video https://www.youtube.com/watch?v=NjdOhYKjFrU\n\nexport {\n  verticalTraversal\n}\n","/*\nLeetcode\n112 Path sum\neasy\n\nGiven a binary tree and a sum, determine if the tree has a root-to-leaf path\nsuch that adding up all the values along the path equals the given sum.\n\nNote: A leaf is a node with no children.\n\nExample:\nGiven the below binary tree and sum = 22,\n      5\n     / \\\n    4   8\n   /   / \\\n  11  13  4\n /  \\      \\\n7    2      1\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n*/\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n  }\n}\n\n// https://leetcode.com/problems/path-sum-iii/discuss/91895/JavaScript-Solution-BFS-and-DFS-with-explanation\n/*\nApproach\n\npreorder DFS root->left->right see task\nhow to solve with other methods\n\ntime\nspace\n*/\n// https://leetcode.com/problems/path-sum/discuss/36486/Python-solutions-(DFS-recursively-DFS%2Bstack-BFS%2Bqueue)\n\n\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {boolean}\n */\nvar hasPathSum = function(root, sum) {\n  //debugger;\n  if (root === null) return false;\n\n  let stack = [];\n  if (root !== null) stack.push([root, root.val]);\n\n  let result = [];\n  // while (stack.length) {\n  //   const [node, val] = stack.pop();\n\n  //   // means leaf\n  //   if (!node.left && !node.right) {\n  //     if (val === sum) {\n  //       return true;\n  //     }\n  //   }\n\n  //   if (node.right) stack.push(node.right, val + node.right.val);\n  //   if (node.left) stack.push(node.left, val + node.val.left);\n  // }\n\n  console.log('result2', result);\n  return false\n};\n\n// tests\nlet tree = new TreeNode(5);\ntree.left = new TreeNode(4);\ntree.right = new TreeNode(8);\ntree.left.left = new TreeNode(11);\ntree.right.left = new TreeNode(13);\ntree.right.right = new TreeNode(4);\ntree.left.left.left = new TreeNode(7);\ntree.left.left.right = new TreeNode(2);\ntree.right.right.right = new TreeNode(4);\nconsole.log('tree', tree);\n\nconsole.log('hasPathSum', hasPathSum(tree, 22));\n\n// describe task with path iii\n// has path sum III\n// https://leetcode.com/problems/path-sum-iii/discuss/377535/Javascript-Read-this-solution-if-you've-given-up-hope-and-just-want-to-see-some-progress\n\n// path sum 3 desc\n/*\nYou are given a binary tree in which each node contains an integer value.\n\nFind the number of paths that sum to a given value.\n\nThe path does not need to start or end at the root or a leaf, but it must go\ndownwards (traveling only from parent nodes to child nodes).\n\nThe tree has no more than 1,000 nodes and the values are in the range -1,000,000\nto 1,000,000.\n\nExample:\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n\nReturn 3. The paths that sum to 8 are:\n\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3. -3 -> 11\n*/\n\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number}\n */\nvar pathSum = function(root, sum) {\n\n}\n\n\n\n\n\n\n/*\n448. Find All Numbers Disappeared in an Array\nEasy\n\n3008\n\n253\n\nAdd to List\n\nShare\nGiven an array of integers where 1  a[i]  n (n = size of array), some elements appear twice and others appear once.\n\nFind all the elements of [1, n] inclusive that do not appear in this array.\n\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\n\nExample:\n\nInput:\n[4,3,2,7,8,2,3,1]\n\nOutput:\n[5,6]\n*/\n\nexport {\n  hasPathSum\n}\n","/*\nLeetcode\n106 Given inorder and postorder traversal of a tree, construct the binary tree.\nmedium\n\nNote:\nYou may assume that duplicates do not exist in the tree.\n\nFor example, given\n\ninorder = [9,3,15,20,7]\npostorder = [9,15,7,20,3]\n\nReturn the following binary tree:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n*/\n\n// Definition for a binary tree node.\nfunction TreeNode(val, left, right) {\n  this.val = (val === undefined ? 0 : val)\n  this.left = (left === undefined ? null : left)\n  this.right = (right === undefined ? null : right)\n}\n\n/*\nApproach Recursion\n\nExample [2,1,3], [2,3,1]\nIntuition\n1) We first find the last node in postOrder. The last node is '1', we know this value\nis root as root always appear in the end of postorder traversal.\n\n2) We search 1 in inOrder to find left and right subtrees of root. Everything on\nleft of 1 in inOrder is in left subtree and everything on right is in right subtree.\n\n3) We recur the above process for following two.\nMake the created tree leftInorder, leftPostorder as left child of root.\nMake the created tree rightInorder, rightPostorder as right child of root.\n\nAlgorithm\nThe root is at the end of postorder\ninorder is of the form [...leftinorder, root, ...rightinorder]\npostorder is of the form [...leftpostorder, ...rightpostorder, root]\nleftinorder.length === leftpostorder.length\nrightinorder.length === rightpostorder.length\n\nThe code is clean and short. However, if you give this implementation during an\ninterview, there is a good chance you will be asked, \"can you improve/optimize\nyour solution?\"\n\nWhy? Take a look at Line A, Line B and Line C.\nLine A takes O(N) time.\nLine B and C takes O(N) time and extra space.\n\nThus, the overall running time and extra space is O(N^2).\nSo this implementation has a very bad performance, and you can avoid it.\n\ntime is O(N^2)\nspace is O(N^2)\n*/\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\n\nfunction buildTreeUseRecursion(inorder, postorder) {\n  if (inorder.length === 0) return null;\n  const rootNode = new TreeNode(postorder[postorder.length-1]);\n  const rootNodeIndex = inorder.indexOf(rootNode.val); // line A\n\n  const leftInorder = inorder.slice(0, rootNodeIndex);\n  const rightInorder = inorder.slice(rootNodeIndex + 1);\n  const leftPostorder = postorder.slice(0, leftInorder.length);\n  const rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\n\n  if (leftInorder.length === 0) {\n    rootNode.left = null\n  } else {\n    rootNode.left = buildTreeUseRecursion(leftInorder, leftPostorder); // line B\n  }\n\n  if (rightInorder.length === 0) {\n    rootNode.right = null\n  } else {\n    rootNode.right = buildTreeUseRecursion(rightInorder, rightPostorder); // line C\n  }\n  return rootNode;\n};\n\n/*\nApproach Recursion (other variant)\n\nExample\n[9,3,15,20,7]\n[9,15,7,20,3]\n\ninorder: left root right [9,3,15,20,7]\npostorder: left right root [9,15,7,20,3]\n\nroot is 3\n      3\n    /   \\\n  9   15 20 7\nwe can find out root element form postorder, it will be 20\nfind 20 in inorder traversal from left side is 15, from right side is 7\n          20\n        /   \\\n       15    7\n\nThe idea\n1) Inorder: <LEFT><ROOT><RIGHT>, postorder: <LEFT><RIGHT><ROOT>\n\n2) The last element of postorder will always be the root of a subtree.\n\n3) We can further determine its left and right subtree by finding its position\nin the inorder array.\n*/\nfunction buildTreeUseRecursion1(inorder, postorder) {\n  if (inorder.length === 0) return null;\n  const root = postorder.pop();\n  const rootIndex = inorder.indexOf(root)\n  const rootNode = new TreeNode(root);\n\n  // todo why it's right and then left?\n  rootNode.right = buildTreeUseRecursion1(inorder.slice(rootIndex + 1), postorder);\n  rootNode.left = buildTreeUseRecursion1(inorder.slice(0, rootIndex), postorder);\n  return rootNode;\n}\n\n/*\nApproach Hash indexes of inorder traversal + Recursion\n\nOptimized approach: We can optimize the above solution using hashing (HashMap).\nWe store indexes of inorder traversal in a hash table. So that search can be done\nO(1) time.\n\nTo further clarify, if you look at the way the nodes are ordered at the end of\nthe postorder array you'll see that we encounter the root, then the right subtrees\nbefore encountering the left nodes.\nThis is because postorder is left -> right -> root, thus when we pop the root from\nthe back of the postorder array the next available node is a right node therefore\nwe construct the right subtree first before the left. :)\n\nThe solution constantly pops from the end of the postorder traversal and relies\nof the fact that postorder is left-right-center. While doing the left first,\nyou are getting elements from the right side when you are still trying to build\nthe left tree.\n\nTime is O(n)\nSpace is O(n) create additional DS hash\n*/\n\nvar buildTreeUseHash = function(inorder, postorder) {\n  let hash = {};\n  for (let i = 0; i < inorder.length; i++) {\n    hash[inorder[i]] = i\n  }\n  //console.log('hash', hash)\n\n  function recur(start, end) {\n    if (start > end) return null;\n    const root = new TreeNode(postorder.pop()); // modifying postorder, is not optimal\n    const index = hash[root.val];\n\n    // I first traversal right because of modifying postorder\n    root.right = recur(index + 1, end);\n    root.left = recur(start, index - 1);\n    return root;\n  }\n  return recur(0, inorder.length - 1)\n}\n\n/*\nApproach Hash indexes of inorder traversal without pop\n\nPrevious solution destroys the postorder list unnecessarily. If I used this\nlibrary function, I'd be surprised by the behavior if I noticed the mutation and\nmight wind up with a difficult to track down bug if I didn't. The updated version\ndoesn't offer any improvement in this regard. Use an index instead of popping.\n*/\n\nvar buildTree = function(inorder, postorder) {\n  const map = new Map();\n  for (let i = 0; i < inorder.length; i++) {\n    map.set(inorder[i], i);\n  }\n\n  function recur(inorder, inStart, inEnd, postorder, posStart, posEnd) {\n    if (inStart > inEnd || posStart > posEnd) return null;\n    const root = new TreeNode(postorder[posEnd]);\n    const index = map.get(root.val);\n\n    // example [9,3,15,20,7], [9,15,7,20,3]\n    // 3 is root, left is 9, 15,20,7 is right\n    // todo\n    root.left = recur(inorder, inStart, index - 1, postorder, posStart, posStart + index - inStart - 1);\n    root.right = recur(inorder, index + 1, inEnd, postorder, posStart + index - inStart, posEnd - 1)\n    return root;\n  }\n\n  return recur(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\n}\n\n// tests\n// inorder = [9,3,15,20,7]\n// postorder = [9,15,7,20,3]\n//const build = buildTreeUseHash([9,3,15,20,7], [9,15,7,20,3])\nconst build = buildTree([2,1,3], [2,3,1])\nconsole.log('build tree', build)\n\n\n/*\ncheck preorder\ncheck the same tree\nAlso, try build tree from inorder and preorder traversal https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/758681/java-2-solution-detailed-explanation-with-code\n\npreorder and postorder https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/759122/Java-2-Solutions-DFS-Linear-Time-or-Easy-to-Understand\n\nBST from Preorder https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/758443/detailed-explanation-with-code\n\nIf you like solution upvote.\n\n*/\n\nexport {\n  TreeNode,\n  buildTreeUseRecursion,\n  buildTreeUseRecursion1,\n  buildTreeUseHash,\n  buildTree\n}\n","/*\nLeetcode\nGiven a binary tree, write a function to get the maximum width of the given tree.\nThe width of a tree is the maximum width among all levels. The binary tree has\nthe same structure as a full binary tree, but some nodes are null.\n\nThe width of one level is defined as the length between the end-nodes\n(the leftmost and right most non-null nodes in the level, where the null nodes\nbetween the end-nodes are also counted into the length calculation.\n\nExample 1:\nInput:\n           1\n         /   \\\n        3     2\n       / \\     \\\n      5   3     9\n\nOutput: 4\nExplanation: The maximum width existing in the third level with the length 4 (5,3,null,9).\n\nExample 2:\n          1\n         /\n        3\n       / \\\n      5   3\n\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n\n\n\ntodo ...\n*/\n\n/*\nApproach BFS level order traversal\nIn this method we store all the child nodes at the current level in the queue\nand then count the total number of nodes after the level order traversal for a\nparticular level is completed.\nSince the queue now contains all the nodes of the next level, we can easily find\nout the total number of nodes in the next level by finding the size of queue.\nWe then follow the same procedure for the successive levels.\nWe store and update the maximum number of nodes found at each level.\n\nTime is O(n) in worst case\nspace\n*/\n/**\n * @param {TreeNode} root\n * @return {number}\n*/\n\nvar widthOfBinaryTree = function(root) {\n  if (root === null) return 0;\n  let maxWidth = 0;\n\n  let queue = [];\n  if (root) queue.push(root);\n\n  while (queue.length) {\n    // size of queue when when the level order traversal for on level finishes\n    let count = queue.length;\n    // update the max node count value\n    maxWidth = Math.max(maxWidth, count);\n\n    // iterate for all nodes in queue currently\n    while (count-- > 0) {\n      const node = queue.shift();\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n  }\n  return maxWidth;\n};\n\nvar widthOfBinaryTreeVariant1 = function(root) {\n  //debugger\n  if (root === null) return 0;\n  let maxWidth = 0;\n  let queue = [];\n  queue.push([root, 0]);\n\n  while (queue.length) {\n    const size = queue.length;\n    let node, position, first;\n\n    for (let i = 0; i < size; i++) {\n      [node, position] = queue.shift();\n      // logic explain?\n      if (i === 0) first = position;\n      if (node.left) queue.push([node.left, position*2]);\n      if (node.right) queue.push([node.right, (position*2)+1]);\n    }\n\n    const currentWidth = (position - first + 1) | 0;\n    maxWidth = Math.max(maxWidth, currentWidth);\n  }\n  return maxWidth;\n}\n\n\n/*\nApproach Using Level order traversal\n\nThis method mainly involves two functions. One is to count nodes at a given\nlevel (getWidth), and other is to get the maximum width of the tree(getMaxWidth).\ngetMaxWidth() makes use of getWidth() to get the width of all levels starting\nfrom root.\n\nTime is n^2\n*/\nclass TreeNode {\n  constructor(val, left, right) {\n    this.val = (val === undefined) ? 0 : val;\n    this.left = (left === undefined) ? null : left;\n    this.right = (right === undefined) ? null : right;\n  }\n}\n\nclass BT {\n  constructor(val) {\n    this.root = new TreeNode(val);\n  }\n\n  // height of BT\n  getHeight(root = this.root) {\n    if (root === null) return 0;\n    let leftHeight = this.getHeight(root.left);\n    let rightHeight = this.getHeight(root.right);\n    return 1 + Math.max(leftHeight, rightHeight);\n  }\n\n  getWidth(node, level) {\n    //debugger\n    if (node === null) return 0;\n\n    if (level === 1) return 1;\n    else if (level > 1) {\n      return this.getWidth(node.left, level - 1) + this.getWidth(node.right, level - 1)\n    }\n    return 0\n  }\n\n  // function to get the maximum width of a binary tree\n  getMaxWidth(root = this.root) {\n    //debugger\n    let maxWidth = 0;\n    let width = 0;\n    let height = this.getHeight(root);\n\n    // Get width of each level and compare the width with maximum width so far\n    for (let i = 0; i < height; i++) {\n      width = this.getWidth(root, i);\n      if (width > maxWidth) maxWidth = width\n    }\n    return maxWidth\n  }\n\n  insertNode(val, root = this.root) {\n    const newNode = new TreeNode(val);\n    if (root === null) root = newNode;\n\n    let queue = [];\n    queue.push(root);\n\n    while (queue.length) {\n      const node = queue[0];\n      queue.shift();\n\n      if (node.left === null) {\n        node.left = newNode;\n        break;\n      } else {\n        queue.push(node.left)\n      }\n\n      if (node.right === null) {\n        node.right = newNode;\n        break;\n      } else {\n        queue.push(node.right)\n      }\n    }\n  }\n}\n\n/*\nApproach is using DFS\ntodo\n*/\n\n// test 1\nlet tree = new BT(1);\ntree.insertNode(2);\ntree.insertNode(3);\ntree.insertNode(4);\ntree.insertNode(5);\ntree.insertNode(6);\ntree.insertNode(7);\ntree.insertNode(8);\ntree = JSON.parse(JSON.stringify(tree)).root;\n// console.log('tree', tree);\n// const width = widthOfBinaryTree(tree)\n// console.log('width', width)\n\n\n// test 2\n// let root = new BT(1);\n// root = JSON.parse(JSON.stringify(root)).root;\n// root.left = new BT(2);\n// root.right = new BT(3);\n// root.left.left = new BT(4);\n\n// console.log('root', root);\n// const width = widthOfBinaryTree(root)\n// console.log('width', width)\n\n// test 3\n// tree.getMaxWidth();\n// console.log('height', tree.getHeight())\n// console.log('getMaxWidth', tree.getMaxWidth())\n// console.log('tree', tree);\n\n// test 4\nconst width = widthOfBinaryTreeVariant1(tree)\nconsole.log('width', width)\n\n\nexport {\n  widthOfBinaryTree,\n  BT\n}\n","import React from 'react';\nimport Details from '../Details';\n\nimport { BT } from '../../ds/tree/bt/bt';\nimport { BinarySearchTree } from '../../ds/tree/bst/binary-search-tree';\nimport { invertTree } from '../../leetcode/tree/binary-tree/226-invert-binary-tree';\n\n// traversal\nimport { preorderTraversal } from '../../ds/tree/bt/traversal/preorder';\nimport { levelOrder } from '../../ds/tree/bt/traversal/level-order-traversal';\n// import { zigzagLevelOrder } from '../../algorithms/tree/bt/traversal/103-level-order-zigzag-traversal';\nimport { verticalTraversal } from '../../leetcode/tree/binary-tree/traversal/987-vertical-order-traversal';\n\n// problems\n// import { countNodes } from '../../leetcode/tree/binary-tree/222-count-complete-tree-nodes';\n// import { sumNumbers, BT } from '../../leetcode/tree/binary-tree/129-sum-root-to-leaf-numbers';\n// import { isSameTree, TreeNode } from '../../leetcode/tree/binary-tree/100-same-tree';\n\n// path sum\nimport { hasPathSum } from '../../leetcode/tree/binary-tree/path-sum/112-path-sum';\n\nimport { buildTreeUseRecursion } from '../../leetcode/tree/binary-tree/traversal/106-construct-bt-from-postorder-inorder-traversal';\nimport { BT as BT1 , widthOfBinaryTree } from '../../leetcode/tree/binary-tree/max-width-bt';\n\n// contest move\n// import { average, kthFactor, longestSubarray } from '../../leetcode/contest/biweekly/29/contest'\n// contest\n//import { reformatDate, rangeSum, minDifference, subsets } from '../../leetcode/contest/biweekly/30/index';\n//import { countOdds, numOfSubarrays } from '../../leetcode/contest/biweekly/31/index';\n\n// contest 32?\n//import {findKthPositive, minInsertions} from '../../leetcode/contest/biweekly/32/index';\n\nexport default function Tree() {\n  return (\n    <div className=\"tree\">\n      <h2>Trees</h2>\n\n      <ul id=\"binary-search-tree\">\n        <li>\n          <Details\n            id=\"test-bt\"\n            question=\"\"\n            code={hasPathSum.toString()}\n            //code={findKthPositive.toString()}\n            //secondCode={minInsertions.toString()}\n            //code={buildTreeUseRecursion.toString()}\n            //code={verticalTraversal.toString()}\n            //secondCode={widthOfBinaryTree.toString()}\n            // secondCode={Trie.toString()}\n          />\n        </li>\n        <li>\n          <Details\n            id=\"bt-implementation\"\n            question=\"BT implementation: .insert(node)\"\n            solution=\"insert(node): iterative + Queue\"\n            complexity=''\n            time=\"\"\n            space=\"\"\n            code={BT.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"binary-search-tree-operations\"\n            question=\"Binary Search Tree: .insert, .contains, height, lowest common ancestor\"\n            solution=\"\"\n            complexity={\n              `\n                Binary search trees provide logarithmic time for the common operations of lookup, insertion, and deletion in the average case,\n                and linear time in the worst case.\n                Why is this? Each of those basic operations requires us to find an item in the tree\n                and because of the tree structure at each parent node we are branching left or right\n                and effectively excluding half the size of the remaining tree.\n                This makes the search proportional to the logarithm of the number of nodes in the tree,\n                which creates logarithmic time for these operations in the average case.\n              `\n            }\n            time=\"O(log(n)) in the average case, linear - in worst cases\"\n            space=\"\"\n            code={BinarySearchTree.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"bt-levelorder\"\n            question=\"Level order (bottom level) traversal BT\"\n            time=\"O(n)\"\n            space=\"O(n)\"\n            code={levelOrder.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"bt-preorder-traversal\"\n            question=\"Preorder traversal BT\"\n            time=\"\"\n            space=\"\"\n            code={preorderTraversal.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"invert-binary-tree\"\n            question=\"Invert Binary Tree: approach recursion\"\n            time=\"is O(n), since each node in the tree is visited only once\"\n            space=\"is O(h) because of recursion, O(h) function calls will be placed on the stack\n            in the worst case, where h is the height of the tree\"\n            code={invertTree.toString()}\n          />\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","\n/*\nImplementation\nWe can use a class to implement adding and removing from the heap,\nbut we need a way to store the values in order. What kind of data structures\ndo we know in JavaScript that have a specific order? Arrays do!\nThe first element in the array is the root node. The left child is the second\nitem and the right child is the third item, etc\n\nComplexity\ntime\ninsert is O(log n)\n*/\nclass MaxBinaryHeap {\n  constructor() {\n    this.values = [];\n    //this.size = this.values.length; // number of elements\n  }\n\n  // helper methods that bubbles up values from end\n  bubbleUp() {\n    // get index of inserted element\n    let index = this.values.length - 1;\n\n    while (index > 0) {\n      const parentIndex = Math.floor((index - 1)/2);\n      if (this.values[parentIndex] < this.values[index]) {\n        this.swap(index, parentIndex);\n        // We reassign our current index to the elements new index if swapped,\n        // and keeps testing parents in a loop until the element fits, or we reach\n        // the root of the heap.\n        index = parentIndex;\n      } else break;\n    }\n    return 0\n  }\n\n  // swim or bubble up\n  swim(index) {\n    // if index starts from 0\n    while (index > 1) {\n      // get parent index via formula\n      const parentIndex = Math.floor((index - 1)/2);\n      if (this.values[parentIndex] < this.values[index]) {\n        this.swap(index, parentIndex);\n        // change current index to parent index\n        index = parentIndex\n      } else break;\n    }\n\n    return 0;\n  }\n\n  // method that pushes new value onto the end and calls the bubble helper\n  insertOntoEnd(val) {\n    this.values.push(val);\n    this.bubbleUp();\n    return this.values;\n  }\n\n  // method that pushes new value and calls the bubble helper\n  insert(val) {\n    let size = this.values.length;\n    // (size > 0) ? this.values[++size] = val : this.values[0] = val\n    // //this.values[++size] = val;\n    this.values.push(val);\n    this.swim(size);\n    return this.values;\n  }\n\n  // bubble down elements to readjust heap after removing max element\n  bubbleDown() {\n    let parentIndex = 0;\n    let size = this.values.length;\n    const parent = this.values[0];\n\n    while(true) {\n      let leftChildIndex = 2*parentIndex + 1;\n      let rightChildIndex = 2*parentIndex + 2;\n\n      let leftChild;\n      let rightChild;\n      let indexToSwap = null;\n\n      // if left child exists, and is greater than the element, plan to swap\n      // with the left child index\n      if (leftChildIndex < size) {\n        leftChild = this.values[leftChildIndex];\n        if (leftChild > parent) {\n          indexToSwap = leftChildIndex\n        }\n      }\n\n      // if right child exists\n      if (rightChildIndex < size) {\n        rightChild = this.values[rightChildIndex];\n        if (\n          (rightChild > parent && indexToSwap === null) ||\n          (rightChild > leftChild && indexToSwap !== null)\n          ) {\n            indexToSwap = rightChildIndex\n        }\n      }\n\n      // if there are no plans to swap, break out of the loop\n      if (indexToSwap === null) break;\n      // swap with planned element\n      this.swap(parentIndex, indexToSwap);\n      // starting index is now index that we swapped with\n      parentIndex = indexToSwap;\n    }\n  }\n\n  deleteMax() {\n    // swap first and last element\n    this.swap(0, this.values.length - 1);\n    //pop max value off of values\n    let poppedVal = this.values.pop();\n    //re-adjust heap if length is greater than 1\n    if (this.values.length > 1) {\n      this.bubbleDown();\n    }\n    return poppedVal;\n  }\n\n  max() {\n    return this.values[0]\n  }\n\n\n  // helper methods\n  swap(index1, index2) {\n    let temp = this.values[index1];\n    this.values[index1] = this.values[index2];\n    this.values[index2] = temp;\n  }\n}\n\n// tests\nconst heap = new MaxBinaryHeap();\nheap.insert(100);\nheap.insert(20);\nheap.insert(80);\nheap.insert(30);\nheap.insert(70);\nheap.insert(40);\nheap.deleteMax()\n\n// heap.insertOntoEnd(100);\n// heap.insertOntoEnd(20);\n// heap.insertOntoEnd(80);\n// heap.insertOntoEnd(30);\n// heap.insertOntoEnd(70);\n// heap.insertOntoEnd(40);\n\n//console.log('heap', heap)\n\nexport {\n  MaxBinaryHeap\n}\n","import React from 'react';\nimport Details from '../Details';\n\nimport { MaxBinaryHeap } from '../../ds/heap/max-binary-heap';\n// problems\n\nexport default function Heap() {\n  return (\n    <div className=\"heap\" id=\"heap\">\n      <h2>Heap</h2>\n\n        <Details\n          id=\"\"\n          question=\"test\"\n          //code={.toString()}\n        />\n      <ul>\n        <li>\n          <Details\n            id=\"max-binary-heap\"\n            question=\"Max Binary Heap\"\n            code={MaxBinaryHeap.toString()}\n          />\n        </li>\n\n      </ul>\n\n      {/* <ul>\n        <li>\n          <details\n            className=\"details\"\n            id=\"queue-problems\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n              <summary role=\"button\" aria-controls=\"content\">\n                Different problems related to\n              </summary>\n\n              <Details\n                id=\"\"\n                question=\"\"\n                time=\"\"\n                space=\"\"\n                code={.toString()}\n              />\n          </details>\n        </li>\n      </ul> */}\n  </div>\n  );\n}\n","/*\nTrie DS (Prefix Tree)\n\nImplement a trie with insert, search, and remove methods.\n\nExample:\nTrie trie = new Trie();\n\ntrie.insert(\"bad\");\ntrie.insert(\"ball\");\ntrie.search(\"bad\");   // returns true\ntrie.search(\"ba\");    // returns false\n\n\nNote:\nYou may assume that all inputs are consist of lowercase letters a-z.\nAll inputs are guaranteed to be non-empty strings.\n*/\n\n/*\nApproach:\n\nclass Node = {\n  key: key,\n  val: null,\n  children: []\n}\n\nclass Trie {\n  this.head = {\n    key: '',\n    children: {}\n  }\n}\n\ntime:\ninsert\nsearch\nremove\n\n*/\nclass TrieNode {\n  constructor(key) {\n    // the \"key\" value will be the character in sequence\n    this.key = (key === undefined) ? null : key;\n    this.val = null; // need to think about this solution is not obvius better to use boolen Endword\n    this.children = [];\n  }\n}\n\nclass Trie {\n  constructor() {\n    // head or root\n    this.head = {\n      key: '',\n      children: {},\n      // end of word boolean\n    }\n  }\n\n  /*\n    insert a word\n    to insert an element into the trie, simply build the correct path from the\n    root to the leaf\n  */\n  insert(word) {\n    let curNode = this.head,\n      curChar = word.slice(0,1),\n      newNode = null;\n\n      // decrease a word for one character\n    word = word.slice(1);\n\n    // looks for an appropriate place to insert an element and\n    // !== null\n    while (typeof curNode.children[curChar] !== 'undefined' &&\n      curChar.length > 0) {\n        curNode = curNode.children[curChar]; // update this.head. object is reference type\n        curChar = word.slice(0,1);\n        word = word.slice(1)\n    }\n\n    // iterates through the remaining characters of the string, filling out the trie\n    while (curChar.length > 0) {\n      //newNode = new TrieNode(curChar);\n      newNode = {\n        key: curChar,\n        val: word.length === 0 ? null : undefined,\n        children : {}\n\t\t  };\n      curNode.children[curChar] = newNode; // update this.head. object is reference type\n      curNode = newNode;\n      curChar = word.slice(0,1);\n      word = word.slice(1);\n    }\n  }\n\n  // The search method returns the depth of the given key or -1 if it does not\n  // find any.\n  search(word) {\n    //debugger\n    let curNode = this.head,\n      curChar = word.slice(0,1),\n      d = 0;\n\n    word = word.slice(1);\n\n    while (typeof curNode.children[curChar] !== \"undefined\" &&\n      curChar.length > 0\n    ) {\n      curNode = curNode.children[curChar];\n      curChar = word.slice(0,1);\n      word = word.slice(1);\n      d += 1;\n    }\n\n    if (curNode.val === null && word.length === 0) {\n      console.log('d', d)\n      return true\n    } else return false\n  }\n\n  /*\n  If the string in question is present in the trie, the remove method recurses\n  down to the node that represents the last character of the string and removes\n  nodes associated with the characters in the string only if they have no sub\n  nodes dependent on them.\n  */\n  remove(word) {\n\n  }\n}\n\n// one good example https://johnresig.com/blog/javascript-trie-performance-analysis/#:~:text=A%20Trie%20is%20a%20relatively,prefixes%20in%20words%20quite%20easily.\n// check remove as well https://medium.com/@alexanderv/tries-javascript-simple-implementation-e2a4e54e4330\n// todo\n// // need to think about this solution is not obvius better to use boolen Endword\n// left a comment\n\nlet trie = new Trie();\ntrie.insert('bad');\ntrie.search('bad');\n// trie.insert('ball');\n// trie.insert('dad');\n//trie.add('mad');\n//trie = JSON.parse(JSON.stringify(trie)).head;\nconsole.log('trie', trie)\n\nexport {\n  Trie\n}\n","/*\nLeetcode\n208 Implement Trie (Prefix Tree\nmedium\n\nImplement a trie with insert, search, and startsWith methods.\nInsert\nSearch\nstartsWith method\n\nExample:\nTrie trie = new Trie();\n\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // returns true\ntrie.search(\"app\");     // returns false\ntrie.startsWith(\"app\"); // returns true\ntrie.insert(\"app\");\ntrie.search(\"app\");     // returns true\n\nNote:\nYou may assume that all inputs are consist of lowercase letters a-z.\nAll inputs are guaranteed to be non-empty strings.\n*/\n\n\n\n// implementation\nclass TrieNode1 {\n  constructor(key) {\n    // the \"key\" value will be the character in sequence\n    this.key = key;\n\n    // its possible\n    // this.keys = new Map()\n\n\n    // we keep a reference to parent\n    this.parent = null;\n\n    // we have hash of children\n    this.children = {};\n\n    // check to see if the node is at the end\n    this.end = false;\n  }\n}\n\nclass Trie1 {\n  constructor() {\n    // start point\n    this.root = new TrieNode1(null);\n  }\n\n  // inserts a word into the trie.\n// time complexity: O(k), k = word length\n  // add word\n  insert(word) {\n    // we start at the root \n    var node = this.root;\n\n    // todo check if it's null case\n\n    // for every character in the word\n    for (let i = 0; i < word.length; i++) {\n      // check to see if character node exists in children.\n      if ( !node.children[word[i]] ) {\n        // if it doesn't exist, we then create it.\n        node.children[word[i]] = new TrieNode1(word[i]);\n\n        // we also assign the parent to the child node.\n        node.children[word[i]].parent = node;\n        debugger\n      }\n\n      // proceed to the next depth in the trie.\n      node = node.children[word[i]];\n\n      // finally, we check to see if it's the last word.\n      if (i === word.length-1) {\n        // if it is, we set the end flag to true.\n        node.end = true;\n      }\n\n    }\n  }\n\n  // lookup\n}\n\n// const trie = new Trie1();\n// //trie.insert('apple')\n// trie.insert('ap')\n// console.log(trie)\n\n// class Trie {\n//   constructor() {\n//     this.root = {}\n//   }\n\n//   insert(word) {\n//     let node = this.root;\n//     for (const c of word) {\n//       if (node[c] == null) node[c] = {};\n//       node = node[c]\n//     }\n//     node.isWord = true\n//   }\n\n//   traverse(word) {\n//     let node = this.root;\n//     for (const c of word) {\n//       node = node[c];\n//       if (node == null) return null\n//     }\n//     return node\n//   }\n\n//   search(word) {\n//     const node = this.traverse(word);\n//     return node != null && node.isWord === true;\n//   }\n\n//   startsWith(prefix) {\n//     return this.traverse(prefix) != null;\n//   }\n// }\n\n// const trie = new Trie();\n// trie.insert('ap');\n// console.log(trie)\n\n\n/**\n * The Idea\nStore the entire trie in an object\nEach node is an object that uses character as keys to connect to other characters\nSet isEnd to true for the last character node in a word\n */\nvar Trie = function() {\n  this.root = {};\n};\n\n/**\n* Inserts a word into the trie.\n* @param {string} word\n* @return {void}\n*/\nTrie.prototype.insert = function(word) {\n  let node = this.root;\n  for (const c of word) {\n    if (node[c] == null) node[c] = {};\n    node = node[c]\n  }\n  node.isWord = true\n};\n\nTrie.prototype.traverse = function(word) {\n  let node = this.root;\n  for (const c of word) {\n    node = node[c];\n    if (node == null) return null\n  }\n  return node\n}\n\nTrie.prototype.search = function(word) {\n  const node = this.traverse(word);\n  return node != null && node.isWord === true;\n}\n\nTrie.prototype.startsWith = function(prefix) {\n  return this.traverse(prefix) != null;\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */\n\nconst trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // returns true\ntrie.search(\"app\");     // returns false\ntrie.startsWith(\"app\"); // returns true\ntrie.insert(\"app\");\ntrie.search(\"app\");     // returns true\nexport { Trie }\n","/*\nLeetcode\nAdd and Search Word - Design DS\n\nDesign a data structure that supports the following two operations:\nvoid addWord(word)\nbool search(word)\n\nsearch(word) can search a literal word or a regular expression string containing\nonly letters a-z or .. A . means it can represent any one letter.\n\nExample:\naddWord(\"bad\")\naddWord(\"dad\")\naddWord(\"mad\")\nsearch(\"pad\") -> false\nsearch(\"bad\") -> true\nsearch(\".ad\") -> true\nsearch(\"b..\") -> true\n\nNote:\nYou may assume that all words are consist of lowercase letters a-z.\n\nHint #1\nYou should be familiar with how a Trie works. If not, please work on this problem:\nImplement Trie (Prefix Tree) first.\n*/\n\n// https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/59669/Java-Solution-easy-understand\n/*\nApproach\n*/\nclass TrieNode {\n  constructor() {\n    this.children = {};\n    this.isEnd = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    \n  }\n}\n\n// I think best case is O(n) (straight search down tree), worst case is O(26^m * n) where n is the length of the search term and m is the number of \".\" characters that appear in the search term.\n// WordDictionary.prototype.search = function(word) {\n//   var search = function(current, level) {\n//       // Cannot search for the word\n//       if (!current || (level === word.length && !current.isEnd)) {\n//           return false;\n//       }\n\n//       if (level === word.length && current.isEnd) {\n//           return true;\n//       }\n\n//       if (word[level] === '.') {\n//           for (let i = 0; i < 26; i++) {\n//               var ch = String.fromCharCode(97 + i);\n\n//               if (search(current.children[ch], level + 1)) {\n//                   return true;\n//               }\n//           }\n\n//           return false;\n//       }\n\n//       return search(current.children[word[level]], level + 1);\n//   };\n\n//   return search(this.root, 0);\n// };\n\n\nclass WordDictionary {\n  /**\n   * Initialize your data structure here.\n  */\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  /**\n   * Adds a word into the data structure.\n   * @param {string} word\n   * @return {void}\n   */\n  addWord(word) {\n    //debugger\n    let cur = this.root;\n\n    for (let i = 0; i < word.length; i++) {\n      if ( !(word[i] in cur.children) ) {\n        cur.children[word[i]] = new TrieNode()\n      }\n      cur = cur.children[word[i]];\n    }\n\n    cur.isEnd = true\n  }\n\n  /**\n   * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.\n   * @param {string} word\n   * @return {boolean}\n   */\n  search(word) {\n    const len = word.length;\n\n    const match = function(cur, level) {\n      if ( !cur || (level === len && !cur.isEnd) ) {\n        return false\n      }\n\n      if (level === len && cur.isEnd) {\n        return true\n      }\n\n      if (word[level] === '.') {\n\n      }\n\n    }\n\n    return match(this.root, 0);\n  }\n\n};\n\n// solutions\n// DFS https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/499657/JavaScript-Solution-Trie-%2B-DFS\n// https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/528035/Javascript-and-C%2B%2B-solutions\n// https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/774859/JavaScript-Solution\n\n// tests\nlet trie1 = new WordDictionary();\ntrie1.addWord('bad');\ntrie1.addWord('dad');\n// trie.add('good');\n// trie.add('glad');\n// trie.add('gold');\n\n// trie.add('apple');\n// trie.add('app');\n// trie.add('abide');\n// trie.add('ball');\n// trie.add('bat');\n//trie = JSON.parse(JSON.stringify(trie)).head;\n//console.log('trie', trie)\n\nexport {\n  Trie,\n  WordDictionary\n}\n","import React from 'react';\nimport Details from '../Details';\n\n// design\nimport { Trie as ImplementationTrie } from '../../ds/trie/implementation-Trie';\nimport { Trie as DesignTrie } from '../../ds/trie/trie';\n\n// problems\nimport { WordDictionary, Trie as DesignTrie1 } from '../../leetcode/trie/add-search-word';\n\n\nexport default function Trie() {\n  return (\n    <div className=\"trie\">\n      <h2>Trees</h2>\n\n      <ul id=\"trie\">\n        <li>\n          <Details\n            id=\"trie-implementation\"\n            question=\"Trie implementation\"\n            solution=\"\"\n            complexity=\"\"\n            time=\"\"\n            space=\"\"\n            code={ImplementationTrie.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"test-trie\"\n            question=\"\"\n            code={WordDictionary.toString()}\n            secondCode={DesignTrie1.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"trie-design\"\n            question=\"Trie design\"\n            solution=\"\"\n            complexity=\"\"\n            time=\"\"\n            space=\"\"\n            code={DesignTrie.toString()}\n          />\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","/**\n * Complexity analysis\n *\n * Time complexity\n * We don't need to loop all the way to the end every time because\n * the right side of the array becomes sorted every loop\n * In the end of the day it still O(n^2)\n *\n * Space is constant O(1)\n *\n*/\nfunction bubbleSort(arr) {\n  const len = arr.length;\n  let swap;\n\n  do {\n    swap = false;\n    for (let i = 0; i < len-1; i++) {\n      if (arr[i] > arr[i+1]) {\n        [arr[i], arr[i+1]] =[arr[i+1], arr[i]];\n        swap = true;\n      }\n    }\n  } while (swap)\n\n  return arr;\n}\n\nfunction bubbleSortTwoForLoops(arr) {\n  const len = arr.length;\n\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < len - i - 1; j++) {\n      const current = arr[j];\n      const next = arr[j+1];\n\n      if (current > next) {\n        arr[j] = next;\n        arr[j+1] = current;\n      }\n    }\n  }\n\n  return arr;\n}\n\n/*\n  Modified bubble sort is just an enhancement to the bubble sort algorithm.\n  It wont improve the algorithm worst case running time\n  but on an average case or for nearly sorted array it is a great improvement as it skips many passes.\n  Modified bubble sort keeps count of the number of adjacent inversions in each pass\n  and when there are no adjacent inversions the algorithm halts as the list will be sorted\n  if there are no adjacent inversions\n*/\nfunction bubbleSortModified(arr) {\n  const len = arr.length;\n\n  for (let i = 0; i < len; i++) {\n    let swaps = 0;\n    for (let j = 0; j < len - i - 1; j++) {\n      const current = arr[j];\n      const next = arr[j+1];\n\n      if (current > next) {\n        arr[j] = next;\n        arr[j+1] = current;\n        swaps++;\n      }\n\n      if (swaps === 0) {\n        break\n      }\n    }\n  }\n\n  return arr;\n}\n\nfunction bubbleSortDisplayCount(arr) {\n  const len = arr.length;\n  let count = 0; // swaps count\n  let swap;\n\n  do {\n    swap = false;\n    for (let i = 0; i < len-1; i++) {\n      if (arr[i] > arr[i+1]) {\n        [ arr[i], arr[i+1] ] =[ arr[i+1], arr[i] ];\n        swap = true;\n        count += 1;\n      }\n    }\n  } while (swap)\n\n  return count;\n}\n\n\nexport { bubbleSort, bubbleSortDisplayCount, bubbleSortTwoForLoops, bubbleSortModified }\n","/*\nQuick sort: Hoare partition schema and Lomuto partition schema\nDivide and conquer: recursion\n\npivot\npartitioning\nrecursion\n\n*/\nfunction quickSort(arr) {\n  const len = arr.length;\n\n  if (len < 2) {\n    return arr;\n  }\n\n  const pivot = arr[len - 1];\n  const leftArr = [];\n  const rightArr = [];\n\n  for (const el of arr.slice(0, len - 1)) {\n    // exclude last element, because it's our pivot\n    el < pivot ? leftArr.push(el) : rightArr.push(el);\n  }\n\n  const merged = [...quickSort(leftArr), pivot, ...quickSort(rightArr)];\n  return merged;\n}\n\nfunction quickSortUseRandomPivot(arr) {\n  const len = arr.length;\n\n  if (len <= 1) {\n    return arr;\n  }\n  // pivot as a random\n  let min = 1;\n  let max = arr.length - 1;\n  const random = Math.floor(min + Math.random() * (max + 1 - min));\n  const pivot = arr[random]\n\n  const left = [];\n  const right = [];\n\n  arr.splice(arr.indexOf(pivot), 1);\n  arr = [pivot].concat(arr);\n\n  for (let i = 1; i < arr.length; i++) {\n    if (pivot > arr[i]) {\n      left.push(arr[i])\n    } else {\n      right.push(arr[i])\n    }\n  }\n\n  const merged = [...quickSort(left), pivot, ...quickSort(right)];\n  return merged;\n}\n\n// tests\n// console.log('Sorted array:', quickSort([1, 3, 4, 2, 5]));\n\n/*\nQuick-sort under Hoare partition schema\n\nComplexity\nQuick sorts worst case is O(n2) but that can be avoided if we pick random\npivot point (choose middle one), so that way its big O is O(nlogn).\nSlicing half and recursive and you need to loop through entire array -> O(n log n)\n\nIts space complexity is O(logn).\n*/\n\n// split subroutine\nfunction quickSortHoare(arr, left = 0, right = arr.length - 1) {\n  if (left < right) {\n    let j = partitionHoare(arr, left, right);\n    //console.log('partition from', left, 'to', right, '=> partition', j);\n\n    // sort subarrays\n    quickSortHoare(arr, left, j-1);\n    quickSortHoare(arr, j+1, right);\n  }\n\n  if (right - left === arr.length - 1) return arr;\n}\n\nfunction quickSortHoare1(arr, left = 0, right = arr.length - 1) {\n  // left-pointer would be the index of the first element which is 0\n  // and right-pointer would be the index of the last element which would be (length -1).\n  let pivot = partitionHoare1(arr, left, right);\n\n  // based on pivot splits inputs on 2 parts\n  // and run trees left and right\n  if (left < pivot - 1) {\n    quickSortHoare(arr, left, pivot - 1);\n  }\n\n  if (right > pivot) {\n    quickSortHoare(arr, pivot, right);\n  }\n\n  return arr;\n}\n\n/* Two indices that start at the ends of the array being partitioned, then move\ntoward each other, until they detect an inversion: a pair of elements, one\ngreater than the pivot, one smaller, that are in the wrong order relative\nto each other. The inverted elements are then swapped.\nHere the numerical values of left and right is continually getting updated with\neach inner while loop. But only if the while loop condition gets satisfied.\nThat is, when the while loop condition is unsatisfied, e.g. for the first inner\nwhile loop, when array[left] > array[pivot] which means we have found a misplaced pair.\nThat is, although the left <= right (which is being made sure by the outer while loop)\nthe actual elements are not sorted. Meaning a left side element is larger in\nvalue than the right side element. So, the code execution then jumps out of the\ninner while loop and goes right in to execute the swap function.\n*/\nfunction partitionHoare(arr, lo, hi) {\n  let i = lo;\n  let j = hi + 1;\n  // arr[lo] is pivot\n\n  while (true) {\n    while (arr[++i] < arr[lo]) {\n      if (i === hi) break;\n    }\n\n    while (arr[lo] < arr[--j]) {\n      if (j === lo) break;\n    }\n\n    if (i >= j) break;\n    let temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n  }\n\n  let temp = arr[lo];\n    arr[lo] = arr[j];\n    arr[j] = temp;\n\n  return j;\n}\n\nfunction partitionHoare1(arr, lo, hi) {\n  let pivot = Math.floor((lo + hi)/2);\n\n  while (lo < hi) {\n    // find item on left to swap\n    while (arr[lo] < arr[pivot]) {\n      lo++;\n    }\n    // find item on right to swap\n    while (arr[hi] > arr[pivot]) {\n      hi--;\n    }\n\n    // check if pointers cross\n    if (lo <= hi) {\n      let temp = arr[lo];\n      arr[lo] = arr[hi];\n      arr[hi] = temp;\n\n      lo++;\n      hi--;\n    }\n  }\n\n  return lo;\n}\n\n/*\nLomuto partition schema\nanother idea of pivoting\n\n1) choose pivot, for example last, pivot = arr[last]\n2) start pivot location at the begin of the array\n3) run i and j\n4) i remember last pivot position - keep memory\n5) j investigate\n6) if arr[j] <= pivot swap element before pivot location and increment i\n7) move pivot to final pivot location - in the end swap i and end\n\ngreat video with explanation https://www.youtube.com/watch?v=MZaf_9IZCrc\n*/\n\nfunction partitionLomuto(arr, start, end) {\n  // choose element as pivot\n  const pivot = arr[end];\n  let i = start; // pivot location\n\n  for (let j = start; j < end; j++) {\n    if (arr[j] <= pivot) {\n      swap(arr, i, j);\n      i++;\n    }\n  }\n  // move a pivot to its proper location\n  swap(arr, i, end);\n  return i;\n}\n\nfunction swap(arr, i, j) {\n  [arr[i], arr[j]] = [arr[j], arr[i]];\n}\n\n// tests\nfunction getRandom(max) {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n\n// let arr = [];\n// for (let i = 0; i < 6; i++) {\n//   arr.push(getRandom(10))\n// }\n// console.log(\"Unsorted array: \", arr);\n// let arr = quickSortHoare([10,33,15,0]);\n// console.log('Sorted array:', arr);\n\n\nexport {\n  quickSort, quickSortUseRandomPivot,\n  quickSortHoare,\n  quickSortHoare1\n};\n","/*\nSelection sort works by selecting the minimum value in a list and\nswapping it with the first value in the list.\n\nIt then starts at the second position, selects the smallest value in the remaining list,\nand swaps it with the second element.\nIt continues iterating through the list and swapping elements until\nit reaches the end of the list.\nNow the list is sorted.\n\nTo maintain algorithm invariants:\n- Move the pointer to the right i++\n- Identify index of minimum entry on right\n- Exchange onto position\n\nTime complexity\nSelection sort has quadratic time complexity in all cases.\nThe number of compares and exchanges made by selection sort does not\ndepend on the order of the input.\n*/\nfunction swap(arr, a, b) {\n  let temp = arr[a];\n  arr[a] = arr[b];\n  arr[b] = temp;\n}\n\nfunction selectionSort(arr) {\n  const len = arr.length;\n\n  for (let i = 0; i < len; i++) {\n    // set minimum to this position\n    let min = i; // index of the smallest element to the right of pointer i\n    for (let j = i + 1; j < len; j++) {\n      if (arr[j] < arr[min]) {\n        // resets min\n        min = j\n      }\n    }\n\n    // or possible to use ES6 syntax\n    let temp = arr[i];\n    arr[i] = arr[min];\n    arr[min] = temp;\n    // or separate function\n    //swap(arr, i, min);\n  }\n\n  return arr;\n}\n\nexport { selectionSort, swap }\n","/*\nMerge sort: divide and conquer\n\nDivide in two halves\nSolve recursively each half\nMerge 2 halves\n\nMerge sort is pretty efficient and the best way to solve merge sort is recursively.\nThis algorithm is a good example of Divide and conquer\n\nSo suppose we have large array and we want to sort it.\nWhat if we could magically sort the left half and sort the right half,\nand then get back two sorted halves.\nWhen if you want to have the whole array sorted all we have to do is merge those\nin in sorted order and that's merge sort is.\nSo we apply merge sort to the left half, apply to the right half\nand merge those back in order\nIt always give us n log n runtime. There is no case than array looks really funky.\nThe downside is merging 2 arrays together requires extra space - O(n) space\n*/\n\nfunction merger(left, right) {\n  // auxilary\n  let singleSorted = [];\n\n  while (left.length && right.length) {\n    if (left[0] < right[0]) {\n      singleSorted.push(left[0]);\n      // is it O(n) complexity\n      left.shift(); // move pointer to next element\n    } else {\n      singleSorted.push(right[0]);\n      right.shift(); // move pointer to next element\n    }\n  }\n\n  // need to concat here because there will be one element\n  // remaining from either left or the right\n  return singleSorted.concat(left, right);\n}\n\nfunction mergeSort(arr) {\n  // it means we no longer divide the array into smaller chunks\n  if ( arr.length <= 1) {\n    return arr;\n  }\n\n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n\n  return merger(mergeSort(left), mergeSort(right))\n}\n\n/*\nMerge sort: practical improvements\n\nUse insertion sort for small subarrays.\nMergesort has too much overhead for tiny subarrays.\nCutoff to insertion sort for  7 items\n*/\nfunction insertionSort(arr, lo, hi) {\n  for (let i = lo; i <= hi; i++) {\n    for (let j = i; j > 0 && arr[j] < arr[j-1]; j--) {\n      let temp = arr[j];\n      arr[j] = arr[j-1];\n      arr[j-1] = temp;\n    }\n\n  }\n}\n\n// todo doesn't work\nfunction merge(arr, aux, lo, mid, hi) {\n  // Copy to aux[]\n  for (let i = lo; i <= hi; i++) {\n    aux[i] = arr[i];\n  }\n\n  // Merge back to a[]\n  let i = lo, j = mid + 1;\n  for (let k = lo; k <= hi; k++) {\n    if      (i > mid)              arr[k] = aux[j++];\n    else if (j > hi)               arr[k] = aux[i++];\n    else if (aux[i] < aux[j])      arr[k] = aux[i++];\n    else                           arr[k] = aux[j++];\n  }\n}\n\n\nfunction mergeSortImprove(arr, aux, lo, hi) {\n  const CUTTOF = 7;\n\n  // #1 improvement\n  // Stop condition for this recursion.\n  // This time we add a CUTOFF, when the items in array\n  // is less than 7, we will use insertion sort.\n  if (hi <= lo + CUTTOF - 1) {\n    insertionSort(arr, lo, hi);\n    return;\n  }\n\n  let mid = lo + (hi - lo) / 2;\n  mergeSortImprove(arr, aux, lo, mid);\n  mergeSortImprove(arr, aux, mid + 1, hi);\n  if (!(arr[mid+1] < arr[mid])) return;\n  merge(arr, aux, lo, mid, hi);\n}\n\n/*\nBottom-up mergeSort\n\nBasic plan.\nPass through array, merging subarrays of size 1.\nRepeat for subarrays of size 2, 4, 8, 16, ....\n\nComplexity\n*/\nfunction bottomUpMergeSort(arr) {\n  var sorted = arr.slice();\n  const n = sorted.length;\n  var buffer = new Array(n);\n\n  for (var size = 1; size < n; size *= 2) {\n    for (var leftStart = 0; leftStart < n; leftStart += 2*size) {\n      var left = leftStart,\n          right = Math.min(left + size, n),\n          leftLimit = right,\n          rightLimit = Math.min(right + size, n),\n          i = left;\n      while (left < leftLimit && right < rightLimit) {\n        if (sorted[left] <= sorted[right]) {\n          buffer[i++] = sorted[left++];\n        } else {\n          buffer[i++] = sorted[right++];\n        }\n      }\n      while (left < leftLimit) {\n        buffer[i++] = sorted[left++];\n      }\n      while (right < rightLimit) {\n        buffer[i++] = sorted[right++];\n      }\n    }\n    var temp = sorted,\n        sorted = buffer,\n        buffer = temp;\n  }\n\n  return sorted;\n}\n\n//console.log('bottomUpMergeSort', bottomUpMergeSort([5, 2, 1, 3, 6, 4]));\n\nexport { mergeSort, merger, mergeSortImprove, bottomUpMergeSort }\n","/*\nInsertion sort\n\nInvariants\nEntries to the left of  (including ) are in ascending order.\nEntries to the right of  have not yet been seen.\n\nTo maintain algorithms invariants:\n- Move pointer to the right i++;\n- Moving from right to the left, exchange a[i] with each larger entry to its left\n\n\nIn Insertion Sort Part 2: learning exercise\n\nGuideline: You already can place an element into a sorted array.\nHow can you use that code to build up a sorted array, one element at a time?\nNote that in the first step, when you consider an array with just the first element,\nit is already sorted since there's nothing to compare it to.\n\nPrint the array after each iteration of the insertion sort, i.e.,\nwhenever the next element has been inserted at its correct position.\nSince the array composed of just the first element is already sorted,\nbegin printing after placing the second element.\n\nFor example, there are n=7 elements in [3,4,7,5,6,2,1].\nWorking from left to right, we get the following output:\n3 4 7 5 6 2 1\n3 4 7 5 6 2 1\n3 4 5 7 6 2 1\n3 4 5 6 7 2 1\n2 3 4 5 6 7 1\n1 2 3 4 5 6 7\n*/\n\nfunction insertionSort2(n, arr) {\n  let storage;\n\n  for (let i = 1; i < n; i++) {\n    storage = arr.splice(i, 1)[0]\n\n    for (let j = i; j >= 0; j--) {\n      if (storage > arr[j-1] || j === 0) {\n        arr.splice(j, 0, storage)\n        break\n      }\n    }\n    //console.log(arr.join(' '))\n  }\n}\n// insertionSort2(7, [3,4,7,5,6,2,1]);\n\n/**\n * Insertion sort algorithm\n */\nfunction insertionSort(arr) {\n  const len = arr.length;\n\n  // can skip the first item = index 0, since any array of size 1 is trivially sorted\n  for (let i = 1; i < len; i++) {\n    const key = arr[i];\n    // look to the left\n    let j = i - 1;\n\n    // Move elements of arr[0...i-1], that are greater than key, to one position\n    // ahead of their current position\n    while (j >= 0 && arr[j] > key) {\n      arr[j+1] = arr[j];\n      j = j - 1;\n    }\n\n    arr[j+1] = key;\n  }\n\n  return arr;\n}\n\n/*\nUse 2 for loops\n*/\nfunction insertionSortVariant2(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i; j > 0; j--) {\n\n      if (arr[j] < arr[j-1]) {\n        let temp = arr[j];\n        arr[j] = arr[j-1];\n        arr[j-1] = temp;\n      } else break;\n      \n    }\n  }\n  return arr;\n}\n\nfunction runningTimeOfInsertionSort(arr) {\n  let swap = 0;\n\n  for (let i = 1; i < arr.length; i++) {\n    const key = arr[i];\n    let j = i - 1;\n\n    while (j>=0 && arr[j] > key) {\n      swap++;\n      arr[j+1] = arr[j];\n      j = j - 1;\n    }\n\n    arr[j+1] = key;\n\n  }\n\n  return swap;\n}\n\nexport {\n  insertionSort2,\n  insertionSort, runningTimeOfInsertionSort,\n  insertionSortVariant2\n}\n","/*\nHeapsort algorithm implementation\n*/\n\nfunction heapify(arr, length, i) {\n  let largest = i; // referring to indexes\n  let left = i*2 + 1;\n  let right = left + 1; // i*2 + 2\n\n  // That recursive call below heapify(arr, size, largest) is going to\n  // ripple down our heap every time we make a switch. When we are checking\n  // the bottom elements of the heap, they are going to be next to elements\n  // we have already popped off our heap and sorted. So we need to make sure\n  // they get left alone. That is why we pass in length of the array that we\n  // are using in our heap. Lets make sure we dont go past that length!\n  if (left < length && arr[left] > arr[largest]) {\n    largest = left\n  }\n\n  if (right < length && arr[right] > arr[largest]) {\n    largest = right;\n  }\n\n  // Now we can check to see if largest is still referring to the parent\n  // element. If it isnt then, we will swap the largest element with the parent,\n  // putting them into their appropriate places.\n  if (largest !== i) { // if largest is not left or right\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    // If we are only comparing three elements at a time, we need a way to make\n    // sure our swaps arent going to affect the elements further down the heap.\n    // We are going to heapify this array from the bottom up. This means that\n    // any swaps we do are changing the parent elements of the nodes below.\n    // We need some kind of check in place to make sure that our lower elements\n    // are still in order!\n    heapify(arr, length, largest);\n  }\n\n  return arr;\n}\n\nfunction heapSort(arr) {\n  const length = arr.length;\n  let i = Math.floor(length/2 - 1); // index of last parent node\n  let k = length - 1; // last index\n\n  while (i >= 0) {\n    heapify(arr, length, i);\n    i--;\n  }\n\n  // repeat steps one and 2 until the heap has only 1 element remaining\n  while (k >= 0) {\n    // swap first and last element\n    [arr[0], arr[k]] = [arr[k], arr[0]];\n    // k = length - 1\n    // k is length argument for next heapify call\n    heapify(arr, k, 0);\n    // we can continue decrementing it and using it as our length argument for\n    // heapify until there is nothing left in heap and everything is sorted.\n    k--;\n  }\n\n  // in-place algorithm\n  return arr\n}\n\nconsole.log('heapSort', heapSort([6,5,3,1,8,7,2,4]));\n\n\n/*\nIsland Perimeter\n\nYou are given a map in form of a two-dimensional integer grid where 1 represents\nland and 0 represents water.\n\nGrid cells are connected horizontally/vertically (not diagonally).\nThe grid is completely surrounded by water, and there is exactly one island\n(i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes\" (water inside that isn't connected to the water\naround the island). One cell is a square with side length 1. The grid is\nrectangular, width and height don't exceed 100. Determine the perimeter of the island.\n\n\nInput:\n[ [0,1,0,0],\n  [1,1,1,0],\n  [0,1,0,0],\n  [1,1,0,0]\n]\nOutput: 16\n\nExplanation: The perimeter is the 16 yellow stripes in the image below:\n*/\n\n/*\nApproach traversal\n\nSince there are no lakes, every pair of neighbour cells with different values is part of the perimeter (more precisely, the edge between them is). So just count the differing pairs, both horizontally and vertically (for the latter I simply transpose the grid).\n\n*/\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar islandPerimeter = function(grid) {\n  const row = grid.length;\n  const col = grid[0].length;\n  let perimeter = 0;\n  let square = 0\n\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n      if (grid[i][j] === 1) square += 4;\n      if (i > 0 && j > 0 && i < row - 1 && j < col - 1) {\n        perimeter += grid[i][j-1] + grid[i][j+1] + grid[i-1][j] + grid[i+1][j]\n      }\n      if (i === 0 && j === 0) {\n        perimeter += grid[i][j+1] + grid[i+1][j];\n      }\n      if (i === row - 1 && j === col - 1) {\n        //debugger\n        perimeter += grid[i][j-1] + grid[i-1][j];\n      }\n    }\n  }\n\n  return square - perimeter\n};\n\nconst input = [\n  [0,1,0,0],\n  [1,1,1,0],\n  [0,1,0,0],\n  [1,1,0,0]\n]\n\n// var islandPerimeter = function(grid) {\n//   const row = grid.length;\n//   const col = grid[0].length;\n//   let perimeter = 0;\n\n//   for (let i = 0; i < row; i++) {\n//       for (let j = 0; j < col; j++) {\n//           if (grid[i][j] === 1) perimeter += 4;\n//  todo inside loop\n//           if (i < row - 1 && grid[i+1][j] === 1) perimeter -= 2;\n//           if (j < col - 1 && grid[i][j+1] === 1) perimeter -= 2;\n//       }\n//   }\n//   return perimeter;\n// };\n\nconsole.log('islandPerimeter', islandPerimeter(input))\n\nexport {\n  heapSort,\n  heapify\n}\n","/**\n * The median of a list of numbers can be found by arranging all the numbers\n * from smallest to greatest.\n * If there is an odd number of numbers, the middle one is picked.\n * If there is an even number of numbers, median is then defined\n * to be the average of the two middle values.\n*/\nfunction findMedian(arr) {\n  const len = arr.length;\n  const sortedArr = arr.sort((a, b) => a - b);\n\n  let median;\n  if (len === 0) return median = 0;\n  let index;\n\n  if (len % 2 === 0) {\n    index = len / 2;\n    median = Math.floor((sortedArr[index] + sortedArr[index - 1]) / 2)\n  } else {\n    index = Math.floor(len / 2);\n    median = sortedArr[index]\n  }\n\n  return median\n}\n\nfunction findMedianVariant1(arr) {\n  const n = arr.length;\n  arr = arr.sort((a, b) => a - b);\n  return arr[(n - 1)/2];\n}\n\nexport { findMedian, findMedianVariant1 }\n","import React from 'react';\nimport Details from './../Details';\n\n// sorting\nimport { bubbleSort } from '../../ds/sorting/bubble-sort';\nimport { quickSort } from '../../ds/sorting/quick-sort';\nimport { selectionSort } from '../../ds/sorting/selection-sort';\nimport { mergeSort, merger } from '../../ds/sorting/merge-sort';\nimport { insertionSort } from '../../ds/sorting/insertion-sort';\n// import { shellSort } from '../../algorithms/sorting/shell-sort';\nimport { heapSort } from '../../ds/sorting/heap-sort';\n\n// problems\nimport { findMedian } from '../../ds/sorting/problems/find-median';\n\nfunction Sorting() {\n  return (\n    <div className=\"sorting\">\n      <h2>Sorting</h2>\n\n      <ul>\n        {/* <Details\n          id=\"sort-test\"\n          code={heapSort.toString()}\n        /> */}\n\n        <li>\n          <Details\n            id=\"bubble-sort\"\n            question=\"Bubble sort: bubble up the biggest element to the right most position\"\n            solution=\"is a method for sorting arrays by comparing each array element to the element behind it\"\n            complexity=\"Unfortunately bubble sort is pretty slow\"\n            time={`\n              (n-1) * (n-1) ... = n2 - 2n + 1 = O(n^2).\n              The worst case situation is reverse ordered array.\n              `\n            }\n            omega={`\n              (n) when array is sorted.\n              As the complete array is sorted, your number of swaps will be zero.\n              If you do not swaps just quit.\n            `}\n            space=\"O(1)\"\n            code={bubbleSort.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"selection-sort\"\n            question=\"Selection sort: move the smallest element to the very left position\"\n            solution=\"\"\n            complexity=\"n + (n-1) + (n-2) + ... + 1 = n*(n+1)/2 = (n^2 + n)/2 = O(n^2)\"\n            time=\"O(n^2) quadratic in all cases, (n^2)\"\n            space=\"\"\n            code={selectionSort.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"insertion-sort\"\n            question=\"Insertion sort: compare items on its left and shift if needed\"\n            solution={`\n              Insertion sort is used when number of elements is small.\n              It can also be useful when input array is almost sorted,\n              only few elements are misplaced in complete big array.\n            `}\n            complexity=\"in worst cases number of shifts over that number to the beginning of the array = 1 + 2 + ... + (n-1) = n(n-1)/2 = n^2/2 = n^2\"\n            time=\"O(n^2)\"\n            space=\"O(1)\"\n            code={insertionSort.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"merge-sort\"\n            question=\"Merge sort\"\n            solution=\"we could magically sort the left half and sort the right half and repeat it again\"\n            complexity=\"It always give us O(n log n) runtime. There is no case than array looks really funky.\"\n            time=\"O(n log n)\"\n            space=\"The downside is merging 2 arrays together requires extra space - O(n) space\"\n            code={mergeSort.toString()}\n            secondCode={merger.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"quick-sort\"\n            question=\"Quick sort: pick a pivot\"\n            solution=\"first pick a random number - pivot\"\n            complexity=\"Quick sorts worst case is O(n^2) (for example, if list was already sorted) but that can be avoided if we pick random pivot point (choose middle one)\"\n            time=\"O(n log n)\"\n            space=\"O(log n)\"\n            code={quickSort.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"heap-sort\"\n            question=\"Heapsort\"\n            solution=\"\"\n            complexity=\"\"\n            time=\"O(nlogn)\"\n            space=\"O(1)\"\n            code={heapSort.toString()}\n          />\n        </li>\n\n        {/* other tasks */}\n        <li>\n          <Details\n            id=\"find-median\"\n            question=\"Find a median\"\n            solution=\"The median of a list of numbers is essentially it's middle element after sorting. The same number of elements occur after it as before.\"\n            time=\"\"\n            space=\"\"\n            code={findMedian.toString()}\n          />\n        </li>\n      </ul>\n  </div>\n  );\n}\n\nexport default Sorting;\n","/**\n * Linear Search (array a, value x)\n *\n * Algorithm:\n * Step 1: Set i to 1\n * Step 2: if i > n then go to step 7\n * Step 3: if a[i] = x then go to step 6\n * Step 4: Set i to i + 1\n * Step 5: Go to Step 2\n * Step 6: Print Element x Found at index i and go to step 8\n * Step 7: Print element not found\n * Step 8: Exit\n *\n * Characteristics:\n * The worst case performance scenario for a linear search is that\n * it needs to loop through the entire collection;\n * either because the item is the last one, or because the item isn't found.\n * In other words, if you have N items in your collection,\n * the worst case scenario to find an item is N iterations.\n * This is known as runtime O(n) using the Big O Notation.\n * The speed of search grows linearly with the number of items within your collection.\n *\n * @param {array, number}\n * @return {number | undefined}\n */\n\nexport function findIndex(arr, searchQuery) {\n  const len = arr.length;\n\n  for (let index = 0; index < len; index++) {\n    const element = arr[index];\n    if (element === searchQuery) {\n      return index\n    } else return undefined\n  }\n}\n","/**\n * Binary search is a textbook algorithm based on the idea to compare the target value to the middle element of the array.\n * If the target value is equal to the middle element - we're done.\n * If the target value is smaller - continue to search on the left.\n * If the target value is larger - continue to search on the right.\n *\n * Binary search must always operated on sth which is sorted\n * and returns either the index of the location in the array,\n * or -1 if the array did not contain the target Value.\n *\n * You probably already have an intuitive idea that binary search makes fewer guesses than linear search\n *\n * Complexity analysis\n *\n * Time complexity: O(logN).\n * Let's compute time complexity with the help of master theorem ...\n * The equation represents dividing the problem up into a subproblems of size ...\n * Here at step there is only one subproblem a = 1, its size is a half of the initial problem b = 2,\n * and all this happens in a constant time d = 0.\n * And hence we're dealing with case 2 that results O(logN) time complexity.\n *\n * Space complexity: O(1) since it's a constant space solution.\n*/\nfunction binarySearch(arr, target) {\n  arr = arr.sort((a, b) => a - b);\n  const len = arr.length;\n  let start = 0;\n  let end = len - 1;\n\n\n  while (start <= end) {\n    // left + right could overflow\n    let mid = Math.floor(start + (end - start)/2)\n\n    if (target === arr[mid]) {\n      return mid;\n    } else if (target < arr[mid]) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return -1;\n}\n\nfunction binarySearchRecursive(arr, target, start = 0, stop = (arr.length - 1)) {\n  // left + right could overflow\n  // let midPoint = Math.floor((start + stop) / 2);\n  let mid = Math.floor(start + (stop - start)/2)\n\n  switch (true) {\n    case arr[mid] === target:\n      return mid;\n\n    case stop - start === 0:\n      return -1;\n\n    case target > arr[mid]:\n      return binarySearchRecursive(arr, target, mid + 1, stop);\n\n    case  target < arr[mid]:\n      return binarySearchRecursive(arr, target, start, mid);\n\n    default:\n      console.log('Sorry, we are out of expressions');\n  }\n}\n\nexport { binarySearch, binarySearchRecursive }\n","/**\n * Search\n * Sherlock and array\n * Watson gives Sherlock an array of integers.\n * His challenge is to find an element of the array such that the sum of all elements\n * to the left is equal to the sum of all elements to the right.\n * For instance, given the array [5, 6, 8, 11], 8 is between two subarrays that sum to 11.\n * If your starting array is [1], that element satisfies the rule as left and right sum to 0.\n *\n * Complete the balancedSums function in the editor below. It should return a string,\n * either YES if there is an element meeting the criterion or NO otherwise.\n */\n\nfunction balancedSum(arr) {\n  const len = arr.length;\n  if (len <= 0) return 'YES';\n\n  let i = 0;\n  let j = len - 1;\n  let sum = 0;\n  while (i !== j) {\n    if (sum >= 0) {\n\n      sum -= arr[j];\n      j--;\n    } else {\n      sum +=arr[i];\n      i++;\n    }\n  }\n\n  return sum === 0 ? 'YES' : 'NO';\n}\n\n/**\n * this solution is not optimal and\n * count sum every loop cycle\n*/\nfunction balancedSumVariant1(arr) {\n  const len = arr.length;\n\n  let leftSum = 0;\n  let rightSum = 0;\n  let leftArr = [];\n  let rightArr = []\n\n\n  if (len === 1) {\n    return 'YES'\n  }\n\n  for (let i = 1; i < len; i++) {\n    leftArr = arr.slice(0, i);\n    leftSum = (leftArr.length > 0) ?\n      leftArr.reduce((accumulator, currentValue) => accumulator + currentValue) :\n      0;\n\n    rightArr = arr.slice(i+1); //rightArr = arr.slice(i, len);\n    rightSum = (rightArr.length > 0) ?\n      rightArr.reduce((accumulator, currentValue) => accumulator + currentValue) :\n      0;\n\n    if (leftSum === rightSum) {\n      return 'YES'\n    }\n  }\n\n  return 'NO'\n}\n\nexport { balancedSum, balancedSumVariant1 }\n","/**\n * Leetcode javascript\n * 278. First Bad version\n * Easy\n *\n * You are a product manager and currently leading a team to develop a new product.\n * Unfortunately, the latest version of your product fails the quality check.\n * Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n * Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one,\n * which causes all the following ones to be bad.\n *\n * You are given an API bool isBadVersion(version) which will return whether version is bad.\n * Implement a function to find the first bad version. You should minimize the number of calls to the API.\n *\n * Example:\n * Given n = 5, and version = 4 is the first bad version.\n *  call isBadVersion(3) -> false\n *  call isBadVersion(5) -> true\n *  call isBadVersion(4) -> true\n */\n\n/*\n  Approach 1 Linear scan: The straight forward way is to brute force it by doing a linear scan.\n\n  Time complexity : O(n). Assume that isBadVersion(version) takes constant time to check if a version is bad.\n  It takes at most n - 1 checks, therefore the overall time complexity is O(n).\n  Space complexity : O(1).\n*/\nvar solutionLinearSearch = function(isBadVersion) {\n  return function(n) {\n    for (let i = 1; i < n; i++) {\n      if (isBadVersion(i) === true) {\n        return i;\n      }\n    }\n    return n;\n  };\n};\n\n/*\n  Approach 2 Binary search\n  Let us see how the search space could be halved each time below.\n\n  Scenario 1\n  where isBadVersion(mid) => false.\n  We know that all versions preceding and including mid are all good.\n  So we set left = mid + 1 to indicate that the new search space is the interval [mid + 1, right] (inclusive).\n\n  Scenario 2\n  The only scenario left is where isBadVersion(mid) => true.\n  This tells us that mid may or may not be the first bad version,\n  ut we can tell for sure that all versions after mid can be discarded.\n  Therefore we set right = mid as the new search space of interval [left,mid] (inclusive).\n\n  Case: left + right can overflow\n  In our case, we indicate left and right as the boundary of our search space (both inclusive).\n  This is why we initialize left = 1 and right = n.\n  How about the terminating condition?\n  We could guess that left and right eventually both meet and it must be the first bad version,\n  but how could you tell for sure?\n  Here is a helpful tip to quickly prove the correctness of your binary search algorithm during an interview.\n  We just need to test an input of size 2.\n  left + right could overflow\n  One way to fix this is to use left + (right - left)/2\n\n  Time complexity: O(log n). The search space is halved each time.\n  Space complexity: O(1)\n*/\n\nvar solutionBinarySearch = function(isBadVersion) {\n  return function(n) {\n    let left = 1;\n    let right = n;\n\n    while (left < right) {\n      // left + right could overflow.\n      let mid = left + (right - left) / 2;\n      if (isBadVersion(mid)) {\n        right = mid // new search [left, mid] (inclusive)\n      } else {\n        left = mid + 1; // search from [mid + 1, right] (inclusive)\n      }\n    }\n  };\n};\n\nexport { solutionLinearSearch, solutionBinarySearch }\n","import React from 'react';\nimport Details from './../Details';\n\nimport { findIndex } from '../../ds/search/linear/find-index';\nimport { binarySearchRecursive, binarySearch } from '../../ds/search/binary/binary-search';\n\n// problems\nimport { balancedSum } from '../../ds/search/problems/balanced-sum';\nimport { solutionBinarySearch } from '../../leetcode/search/binary-search/278-first-bad-version';\n// import { findMin } from '../../leetcode/search/binary-search/153-find-min-in-rotated-sorted-arr';\n// import { findMin2 } from '../../leetcode/search/binary-search/154-find-min-in-rotated-sorted-arr-2';\n//import { arrangeCoins } from '../../leetcode/search/binarySearch/441-arrangeCoins';\n// import { twoSumSorted } from '../../leetcode/array/sum-problems/two-sum-sorted';\n// import { threeSum } from '../../leetcode/array/sum-problems/15-3sum-problem';\n\nexport default function Searching() {\n  return (\n    <div className=\"number\">\n      <h2>Search / Binary search</h2>\n\n        <ul>\n          test\n          <Details\n            id=\"test\"\n            question=\"\"\n            // code={findMin2.toString(2)}\n            // code={twoSumSorted.toString()}\n            // secondCode={threeSum.toString()}\n          />\n        <li>\n          <Details\n            id=\"is-find-index\"\n            question=\"Linear search: find an index of element in array\"\n            solution=\"\"\n            complexity=\"The worst case performance scenario for a linear search is that it needs to loop through the entire collection.\"\n            time=\"O(n)\"\n            spaceComplexity=\"O(1)\"\n            code={findIndex.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"binary-search\"\n            question=\"Binary search with loop while and recursion\"\n            solution=\"left + right could overflow, correct mid = left + (right - left)/2\"\n            complexity=\"For iterative and recursive approach: time is O(log n), but for recursive space is O(log n)\"\n            time=\"O(log n)\"\n            space=\"O(1)\"\n            code={binarySearch.toString()}\n            secondCode={binarySearchRecursive.toString()}\n          />\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"searching-tasks\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n              <summary role=\"button\" aria-controls=\"content\">\n                Different tasks related to Binary search\n              </summary>\n              <Details\n                id=\"search-balanced-sum\"\n                question=\"Balanced sum\"\n                solution=\"challenge is to find an element of the array such that the sum of all elements to the left is equal to the sum of all elements to the right\"\n                complexity=\"\"\n                time=\"O(n)\"\n                code={balancedSum.toString()}\n              />\n\n              <Details\n                id=\"first-bad-version\"\n                question=\"First Bad version\"\n                solution={`\n                  Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one,\n                  which causes all the following ones to be bad.\n                `}\n                time=\"O(log n)\"\n                space=\"O(1)\"\n                code={solutionBinarySearch.toString()}\n              />\n          </details>\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","/*\nExplain a recursion\n\n*/\nconst loopNTimes = function(n) {\n  if ( n <= 1) {\n    return 'complete'\n  }\n  return loopNTimes(n-1);\n}\n\nconst countDown = function(N) {\n  console.log('N', N)\n  // base case\n  if (N <= 0) {\n    return;\n  }\n\n  // recursive case\n  return countDown(N-1);\n}\n\n// tests\n//console.log('countDown', countDown(4))\n\n\n/*\nYoure given an array of numbers [2,4,6]\nYou have to add up all the numbers and return the total.\n*/\n\nfunction sumUseLoop(arr) {\n  let total = 0;\n  for (let i = 0; i < arr.length; i++) {\n    total += arr[i]\n  }\n  return total;\n}\n\n// Recursive approach\nfunction sum(arr) {\n  if (arr.length === 0) return 0;\n  return arr[0] + sum(arr.slice(1));\n}\n\n//console.log('sumUseLoop', sum([2,4,6]))\n\n// Find max list\nfunction max(arr) {\n  if (arr.length === 2) {\n    return arr[0] > arr[1] ? arr[0] : arr[1]\n  }\n  let subMax = max(arr.slice(1));\n  return (arr[0] > subMax) ? arr[0] : subMax;\n}\n\n//console.log('max', max([10,12,0,2,4,6,1]))\n\nexport {\n  loopNTimes,\n  countDown,\n  sumUseLoop,\n  sum,\n  max\n}\n","/**\n * Factorial of a Number: return the factorial of the provided integer.\n * Desc: if the integer is represented with the n, a factorial is the product\n * of all positive integers less than or equal to n.\n *\n * solution(5) --> 5! = 1 * 2 * 3 * 4 * 5 = 120\n * 0! = 1\n * 1! = 1\n * 2! = 2 * 1\n * 3! = 3 * 2 * 1\n * 4! = 4 * 3 * 2 * 1\n * 5! = 5 * 4 * 3 * 2 * 1\n *\n * position of stack trace\n *\n * First Part of the recursion method\n * You need to remember that you wont have just one call, youll have several nested calls\n * Each call: n === \"?\"        \t          n * factorial(n - 1)\n * 1st call: factorial(5) will return     5 * factorial(5 - 1) // -> factorial(4)\n * 2nd call  factorial(4) will return    4 * factorial(4 - 1) // factorial(3)\n * 3rd call  factorial(3) will return    3 * factorial(3 - 1) // factorial(2)\n * 4th call  factorial(2) will return    2 * factorial(2 - 1) // factorial(1)\n * 5th call  factorial(1) will return    1 * factorial(1 - 1) // factorial(0)\n *\n * Second part of the recursion method\n * The method hits the if condition, it returns 1 which num will multiply itself with\n * The function will exit with the total value\n * 5th call will return (5 * (5 - 1))     // n = 5 * 4\n * 4th call will return (20 * (4 - 1))    // n = 20 * 3\n * 3rd call will return (60 * (3 - 1))    // n = 60 * 2\n * 2nd call will return (120 * (2 - 1))   // n = 120 * 1\n * 1st call will return (120)             // n = 120\n * If we sum up all the calls in one line, we have\n * (5 * (5 - 1) * (4 - 1) * (3 - 1) * (2 - 1)) = 5 * 4 * 3 * 2 * 1 = 120\n *\n * @param {number}\n * @return {number}\n*/\nfunction factorialUseLoop(n) {\n  //console.time('test-factorialUseLoop');\n  let result = 1;\n\n  for (let i = 2; i <= n; i++) {\n    result *= i\n  }\n\n  //console.timeEnd('test-factorialUseLoop');\n  return result;\n}\n\nfunction factorialUseLoopOperatorMinus(n) {\n  //console.time('test-factorialUseLoopOperatorMinus');\n  if ( n < 0 ) {\n    return -1;\n  }\n\n  if (n === 0 || n === 1 ) {\n    return 1;\n  }\n\n  for (let i = n - 1; i >= 1; i--) {\n    n = n * i\n  }\n\n  //console.timeEnd('test-factorialUseLoopOperatorMinus');\n  return n;\n}\n\nfunction factorialUseWhileLoop(n) {\n  //console.time('test-factorialUseWhileLoop');\n  let result = n;\n  if ( n < 0 ) {\n    result = -1;\n  }\n\n  if (n === 0 || n === 1) {\n    result = 1\n  }\n\n  while (n > 1) {\n    n--;\n    result *= n;\n  }\n\n  //console.timeEnd('test-factorialUseWhileLoop');\n  return result;\n}\n\n// use recursion\nfunction factorial(n) {\n  //console.time('test-factorial');\n  // if the number is less than 0, reject it\n  if ( n < 0 ) {\n    return -1;\n  }\n\n  // works with (n === 1) as well\n  if (n === 0) {\n    return 1;\n  } else {\n    //console.timeEnd('test-factorial');\n    return n * factorial(n - 1);\n  }\n}\n\nexport { factorialUseLoop, factorial, factorialUseWhileLoop, factorialUseLoopOperatorMinus }\n","// Recursion explanation\nlet countDownFrom = (num) => {\n  if (num === 0) return;\n  countDownFrom(num - 1);\n}\ncountDownFrom(10);\n//console.log('countDownFrom', countDownFrom(10))\n\n/*\nleetcode\n509. Fibonacci Number\neasy\n\n1,1,2,3,5,8 ...\nThe Fibonacci numbers, commonly denoted F(n) form a sequence,\ncalled the Fibonacci sequence, such that each number is the sum of the two preceding ones,\nstarting from 0 and 1. That is,\n\nF(0) = 0,\nF(1) = 1\nF(N) = F(N - 1) + F(N - 2), for N > 1.\nGiven N, calculate F(N).\n\nExample 1:\nInput: 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\n\nExample 2:\nInput: 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\n\nExample 3:\nInput: 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\n\nNote:\n0  N  30.\n*/\n\n/*\nApproach Recursion (inefficient solution)\n\nUse recursion to compute the Fibonacci number of a given integer.\n\nAlgorithm\nCheck if the provided input value, N, is less than or equal to 1. If true, return N.\n\nOtherwise, the function fib(int N) calls itself, with the result of the 2 previous\nnumbers being\nadded to each other, passed in as the argument.\nThis is derived directly from the recurrence relation: F_{n} = F_{n-1} + F_{n-2}\n\nDo this until all numbers have been computed, then return the resulting answer.\n\nComplexity Analysis\nTime complexity: O(2^n)\nThis is the slowest way to solve the Fibonacci Sequence because it takes exponential time.\nThe amount of operations needed, for each level of recursion, grows exponentially\nas the depth approaches N.\n\nT(1) = 1\nT(n) = T(n-1) + T(n-2) + T(1)\na^n == a^(n-1) + a^(n-2)\ndivide through by a^(n-2): a^2 == a + 1\n(1+sqrt(5))/2 = 1.6180339887 --> golden ratio, so it takes exponential time.\n\nSpace complexity: O(N).\nWe need space proportionate to N to account for the max size of the stack, in memory.\nThis stack keeps track of the function calls to fib(N).\nThis has the potential to be bad in cases\nhat there isn't enough physical memory to handle the increasingly growing stack,\nleading to a StackOverflowError.\n*/\n/**\n * @param {number} N\n * @return {number}\n */\nlet fib = (N) => {\n  if (N === 0) return 0;\n  if (N === 1) return 1;\n\n  if (N > 1) {\n    return fib(N-1) + fib(N-2)\n  }\n};\n\n/*\n  Approach: Iterative solution\n  use for loop\n\n  time - O(n)\n  space - O(1)\n*/\nfunction fibIterative(N) {\n  let arr = [0, 1];\n\n  for (let i = 2; i <= N; i++) {\n    arr.push(arr[i-2] + arr[i-1])\n  }\n\n  return arr[N]\n}\n\n// todo Approach 4: Iterative Top-Down Approach\n/*\n\n*/\n// Here is a O(1) memory solution:\n\n// function fibIterative(n) {\n//     if (n === 0) return 0\n\n//     let prevPrev = 0\n//     let prev = 1\n//     n -= 1\n\n//     while (n > 0) {\n//         let current = prev + prevPrev\n//         prevPrev = prev\n//         prev = current\n//         n--\n//     }\n\n//     return prev\n// }\n\n/*\n  Approach 2: Memoized Solution\n  todo\n\n*/\n\n// const fib1 = (N, memo) => {\n//   memo = memo || {};\n\n//   if (memo(N)) return memo[N];\n//   if (N > 2) return N;\n\n//   return memo[N] = fib1(N-1, memo) + fib1(N-2, memo);\n// }\n\n/*\n  Approach 2: Bottom-Up Approach using Memoization\n\n\n*/\n\n\nexport { fib, fibIterative }\n\n","/*\nLeetocde\n215 Find the kth largest (smallest) element in an unsorted array.\nmedium\n\nFind the kth largest element in an unsorted array. Note that it is the\nkth largest element in the sorted order, not the kth distinct element.\n\nOr find the kth smallest element.\nProblem related to Quick select algorithm\n\nExample 1:\nInput: [3,2,1,5,6,4] and k = 2\nOutput: 5\n\nExample 2:\nInput: [3,2,3,1,2,4,5,5,6] and k = 4\nOutput: 4\n\nNote:\nYou may assume k is always valid, 1  k  array's length\n*/\n\n\n/*\nApproach sort\nif you wanna find a smallest you look on first position,\nlargest - last, median\n\ntime O(n log n)\nspace is O(1)\n*/\nvar findKthLargestSort = function(nums, k) {\n  nums = nums.sort((a,b) => a - b);\n  return nums[nums.length - k];\n};\n\n\n/*\nApproach Heap\n*/\n// ...\n\n/*\nApproach quicksort partition schema\n\nDuring sorting we are doing extra work - still doing more work that we need to do.\nBecause we know after sorting every kth element, but we need to know only one.\n\nWe wanna find a selection algorithm which runs in linear time. There is a solution\nbased on partition.\n\nIn quicksort, we pick a pivot element, then move the pivot element to its correct\nposition and partition the array around it. The idea is, not to do complete\nquicksort, but stop at the point where pivot itself is kth smallest element.\n\nThe basic idea is to use Quick Select algorithm to partition the array with pivot:\nPut numbers < pivot to pivot's left\nPut numbers > pivot to pivot's right\nThen\nif indexOfPivot == k, return A[k]\nelse if indexOfPivot < k, keep checking left part to pivot\nelse if indexOfPivot > k, keep checking right part to pivot\n\nPartition array around pivot so that\n- entry a[j] in place\n- no larger entry to the left of j\n- no smaller entry to the right of j\nRepeat in one subarray, depending on j; finished when j equals k;\n\nComplexity\nThe average case for quick select is O(n) while the worst case is\nO(n2).\n\nDiscard half each time: n+(n/2)+(n/4)..1 = n + (n-1) = O(2n-1) = O(n),\nbecause n/2+n/4+n/8+..1 = n-1.\n*/\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n*/\nfunction findKthLargest(nums, k) {\n  k = nums.length - k;\n  let lo = 0;\n  let hi = nums.length - 1;\n  while (lo < hi) {\n    let j = partitionLomuto(nums, lo, hi);\n    if (j < k) {\n      /*\n        pivotIndex < n - k\n        k'th largest must be in the right partition. We \"undershot\" and need to\n        go right (and we do this by narrowing the left bound)\n      */\n      lo = j + 1;\n    } else if (j > k) {\n      /*\n        k'th largest must be in the left partition. We \"overshot\" and need to go left\n        (and we do this by narrowing the right bound)\n      */\n      hi = j - 1;\n    } else {\n      break;\n      // if (j === nums.length - k)\n      /*\n        Found. The pivot is index on index n - k. This is literally its final\n        position if the array we were given had been sorted. See how we saved work?\n        We don't need to sort the whole array\n        In this case pivot would have a final position like in sorted array\n        [2 1 3 5 6 4]\n        3 is index 2 like in sorted array\n      */\n      // time limit exceed\n      //return nums[k]\n    }\n  }\n  return nums[k];\n};\n\nfunction partition(nums, start, end) {\n  let pivot = start, temp;\n  while (start <= end) {\n      while (nums[start] <= nums[pivot]) start++;\n      while (nums[end] > nums[pivot]) end--;\n      if (start > end) break;\n\n      temp = nums[start];\n      nums[start] = nums[end];\n      nums[end] = temp;\n  }\n  // why do we need second swap and as well pivot\n  // Pivot was set to start in the beginning but then we moved the pointers start\n  // and end inwards to reach the point where everything on the left is smaller and\n  // everything on right is bigger.\n  // This point is located at index end (The true Pivot). So we swap end and pivot\n  // and return end.\n  temp = nums[end];\n  nums[end] = nums[pivot];\n  nums[pivot] = temp;\n  return end;\n}\n\n/*\nLomuto partition schema\n*/\nfunction partitionLomuto(arr, start, end) {\n  // choose element as pivot\n  const pivot = arr[end];\n  let i = start; // pivot location\n\n  for (let j = start; j < end; j++) {\n    if (arr[j] <= pivot) {\n      swap(arr, i, j);\n      i++;\n    }\n  }\n  // move a pivot to its proper location\n  swap(arr, i, end);\n  return i;\n}\n\nfunction swap(arr, i, j) {\n  [arr[i], arr[j]] = [arr[j], arr[i]];\n}\n\n//console.log('findKthLargest', findKthLargest([3,2,1,5,6,4], 2))\n//console.log('findKthLargest', findKthLargest([3,2,1], 1))\n\nexport {\n  findKthLargest,\n  findKthLargestSort,\n  partition\n}\n","import React from 'react';\nimport Details from './../Details';\n\n// explanation\nimport { loopNTimes, countDown, sumUseLoop } from '../../leetcode/recursion/index';\n\n// problems\nimport { factorial } from '../../leetcode/recursion/factorial';\nimport { fib, fibIterative } from '../../leetcode/recursion/fibonacci';\nimport { findKthLargest } from '../../leetcode/divide-conquer/215-k-th-largest-element';\n\nexport default function Recursion() {\n  return (\n    <div className=\"number\">\n      <h2 id=\"recursion\">Recursion</h2>\n\n      <ul>\n        <Details\n          id=\"test\"\n          question=\"\"\n          code={findKthLargest.toString()}\n        />\n      <li>\n          <Details\n            id=\"recursion-explanation\"\n            question=\"Recursion examples\"\n            time=\"\"\n            space=\"\"\n            code={sumUseLoop.toString()}\n            secondCode={countDown.toString()}\n            third={loopNTimes.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"factorial\"\n            question=\"Factorial using recursion\"\n            time=\"The time complexity of recursive factorial is O(n)\"\n            space=\"As there is no extra space taken during the recursive calls, the space complexity is O(n)\"\n            code={factorial.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"fibonacci\"\n            question=\"Fibonacci Number: approach recursion, iterative solution\"\n            complexity={\n              `\n              Recursion is the slowest way to solve the Fibonacci Sequence because it takes exponential time.\n              We need space proportionate to N to account for the max size of the stack, in memory.\n              This stack keeps track of the function calls to fib(N).\n              This has the potential to be bad in cases\n              hat there isn't enough physical memory to handle the increasingly growing stack,\n              leading to a StackOverflowError.\n              `\n            }\n            time=\"with recursion O(2^n)\"\n            space=\"with recursion O(N)\"\n            code={fib.toString()}\n            secondCode={fibIterative.toString()}\n          />\n        </li>\n      </ul>\n  </div>\n  );\n}\n","/**\n * Consider an array of integers, arr = [arr[0], ... , arr[n-1]].\n * We define the absolute difference between two elements a[i] and a[j] (where i!=j),\n * to be the absolute value of a[i] - a[j].\n * Given an array of integers,\n * find and print the minimum absolute difference between any two elements in the array.\n * For example, given the array arr = [-2,2,4]\n * we can create  pairs of numbers: [-2,2], [-2,4] and [2,4].\n * The absolute differences for these pairs are\n * |-2 -2| = 4,\n * |-2-4| = 6 and\n * |2-4| = 2.\n * The minimum absolute difference is 2.\n *\n * Algorithm\n * 1) sort\n * 2) consider diff between the first pair as min\n * 3) compare all \"consecutive pair min\" with the one in step2 to get the least min.\n * */\nfunction minimumAbsoluteDifference(arr) {\n  const len = arr.length;\n  const sortedArr = arr.sort((a, b) => a - b); // solution doesn't work without sort\n\n  let min = Math.abs(sortedArr[0] - sortedArr[1]),\n    diff;\n\n  for (let i = 2; i < len; i++) {\n    diff = Math.abs(sortedArr[i] - sortedArr[i-1]);\n    if (diff < min) {\n      min = diff;\n    }\n  }\n\n  return min;\n}\n\nexport { minimumAbsoluteDifference }\n\n","/**\n * More description on hackerrunk greedy algorithms\n * The description would be clearer if it read \"L is the amount of luck\n * that can be gained by losing the contest.\"\n * She believes that luck is spent on wins and earned from losses.\n*/\nfunction luckBalance(k, contests) {\n  // sort descending, don't modify the original array\n  const arr = contests\n    .slice()\n    .sort((a, b) => b[0] - a[0]);\n\n  const len = arr.length;\n  let luck = 0,\n    lost = k;\n\n  for (let i = 0; i < len; i++) {\n      const [value, important] = arr[i];\n      // increment if lost, decrement if won\n      if (important) {\n          luck += lost > 0 ? value : -value;\n          lost -= 1;\n          continue;\n      }\n      // non-important are always lost\n      luck += value;\n  }\n\n  return luck;\n}\n\nexport { luckBalance }\n","/*\nLeetcode\n1029 Two city Scheduling\neasy\n\nThere are 2N people a company is planning to interview.\nThe cost of flying the i-th person to city A is costs[i][0],\nand the cost of flying the i-th person to city B is costs[i][1].\n\nReturn the minimum cost to fly every person to a city such\nthat exactly N people arrive in each city.\n\nExample 1:\nInput: [[10,20],[30,200],[400,50],[30,20]]\nOutput: 110\nExplanation:\nThe first person goes to city A for a cost of 10.\nThe second person goes to city A for a cost of 30.\nThe third person goes to city B for a cost of 50.\nThe fourth person goes to city B for a cost of 20.\n\nThe total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.\n\nNote:\n1 <= costs.length <= 100\nIt is guaranteed that costs.length is even.\n1 <= costs[i][0], costs[i][1] <= 1000\n*/\n\n/*\nApproach 1 Greedy\n\nActual cost parameter (profit margin) is how much more we benefit\nif we choose to go to city A rather then city B.\n\nLet's figure out how to sort the input here.\nThe input should be sorted by a parameter which indicates a money lost for the company.\n\nThe company would pay anyway : price_A to send a person to the city A,\nor price_B to send a person to the city B. By sending the person to the city A,\nthe company would lose price_A - price_B, which could negative or positive.\n\nTo optimize the total costs, let's sort the persons by price_A - price_B\nand then send the first n persons to the city A,\nand the others to the city B, because this way the company costs are minimal.\n\nComplexity Analysis\nTime complexity: O(NlogN) because of sorting of input data.\nSpace complexity: O(1) since it's a constant space solution.\n*/\n\n/**\n * @param {number[][]} costs\n * @return {number}\n*/\nvar twoCitySchedCost = function(costs) {\n  // sort by a gain which company has\n  // by sending a person to city A and not to city B\n  // function compare(a,b) {\n  //   if (a<b) return -1\n  //   if (a>b) return 1;\n  //   // must be equal\n  //   return 0\n  // }\n  // [10,20], // 10 - 20 - (200 - 30) = -10 - 170 = - 180\n  // [30,200],\n  // [400,50],\n  // [30,20]\n  costs = costs.sort((a, b) => a[0] - b[0] - (a[1] - b[1]));\n\n  let total = 0;\n  const midIndex = costs.length/2;\n\n  // to optimize the company expenses,\n  // send the first n persons to the city A\n  // and the others to the city B\n  for (let i = 0; i < midIndex; i++) {\n    total += costs[i][0] + costs[i + midIndex][1]\n  }\n\n  return total;\n};\n\n/*\n  The same approach as previous\n  but based on price_B - price_A\n*/\nvar twoCitySchedCostVariant2 = function(costs) {\n  // opposite sorting price_B - price_A\n  costs.sort((a,b) => (a[1] - a[0]) - (b[1] - b[0]));\n\n  let total = 0;\n  const len = costs.length;\n  const midIndex = Math.floor(len/2);\n\n  for (let i = 0; i < midIndex; i++) {\n    total+= costs[i][1] + costs[len - 1 - i][0];\n  }\n\n  return total;\n};\n\n/*\nApproach Greedy\nThe same approach: sort in descending order, take absolute difference\nsort from largest impact to smallest impact\n\n- because only N people should arrive in each city\n2n = length of arr\nn = length of arr / 2\n\n- have counters for each city to keep track of how many people we\nflown to that city\n\n- when adding to the sum we pick the city with the lower costs\nas long as city is under the N\n*/\n\nvar twoCitySchedCostSortAbs = function(costs) {\n  // costs city A descending order\n  costs = costs.sort((a, b) => {\n    return Math.abs(b[0] - b[1]) - Math.abs(a[0] - a[1])\n  });\n\n  //console.log('costs', costs)\n\n  // another solution for sorted, works as well\n  // costs = costs.sort((a, b) => {\n  //   const aDiff = a[0] > a[1] ? a[0] - a[1] : a[1] - a[0];\n  //   const bDiff = b[0] > b[1] ? b[0] - b[1] : b[1] - b[0];\n  //   return bDiff - aDiff;\n  // });\n\n  let sum = 0;\n  const len = costs.length;\n  const midIndex = Math.floor(len/2);\n\n  let counterA = 0;\n  let counterB = 0;\n\n  for (let i = 0; i < len; i++) {\n    let costCityA = costs[i][0];\n    let costCityB = costs[i][1];\n\n    if (costCityA <= costCityB) {\n      if (counterA < midIndex) {\n        sum += costCityA;\n        counterA++;\n      } else {\n        sum += costCityB;\n        counterB++;\n      }\n    } else {\n      if (counterB < midIndex) {\n        sum += costCityB;\n        counterB++;\n      } else {\n        sum += costCityA;\n        counterA++;\n      }\n    }\n  }\n\n  return sum;\n};\n\n// console.log('twoCitySchedCostSortAbs', twoCitySchedCostSortAbs([[10,20],[30,200],[400,50],[30,20]]))\n\nexport {\n  twoCitySchedCost,\n  twoCitySchedCostSortAbs\n}\n","import React from 'react';\nimport Details from '../Details';\n\n// problems\nimport { minimumAbsoluteDifference } from '../../leetcode/greedy/hack/min-abs-difference';\nimport { luckBalance } from '../../leetcode/greedy/hack/luck-balance';\nimport { twoCitySchedCost, twoCitySchedCostSortAbs } from '../../leetcode/greedy/1029-two-city-scheduling';\n//import { leastInterval } from '../../leetcode/greedy/621-task-scheduler';\n\nexport default function GreedyAlgorithms() {\n  return (\n    <div className=\"greedy\">\n      <h2 id=\"greedy\">Greedy Algorithms</h2>\n\n      <Details\n        id=\"test\"\n        //code={leastInterval.toString()}\n      />\n      <ul>\n        <li>\n          <Details\n            id=\"greedy-two-city-scheduling\"\n            question=\"Two city Scheduling\"\n            solution={`\n            There are 2N people a company is planning to interview.\n            The cost of flying the i-th person to city A is costs[i][0],\n            and the cost of flying the i-th person to city B is costs[i][1].\n\n            Return the minimum cost to fly every person to a city such\n            that exactly N people arrive in each city.\n            `}\n            time=\"O(NlogN) because of sorting of input data\"\n            space=\"O(1) since it's a constant space solution\"\n            code={twoCitySchedCost.toString()}\n            secondCode={twoCitySchedCostSortAbs.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"greedy-min-absolute-difference\"\n            question=\"Minimum absolute difference in an array\"\n            solution=\"We define the absolute difference between two elements a[i] and a[j] (where i!=j), to be the absolute value of a[i] - a[j].\"\n            code={minimumAbsoluteDifference.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"greedy-luck-balance\"\n            question=\"Luck Balance\"\n            code={luckBalance.toString()}\n          />\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","/*\nLeetcode\n518. Coin change 2\nmedium\n\nYou are given coins of different denominations and a total amount of money.\nWrite a function to compute the number of combinations that make up that amount.\nYou may assume that you have infinite number of each kind of coin.\n\nExample 1:\nInput: amount = 5, coins = [1, 2, 5]\nOutput: 4\n\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n\nExample 2:\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.\n\nExample 3:\nInput: amount = 10, coins = [10]\nOutput: 1\n\nNote: You can assume that\n0 <= amount <= 5000\n1 <= coin <= 5000\nthe number of coins is less than 500\nthe answer is guaranteed to fit into signed 32-bit integer\n*/\n\n/*\nApproach Dynamic Programming\n\nAny DP problem should start from explanation of sub problems.\nThe idea is in order to know how many combinations there were for 5,\nwe needed to know how many combinations the previous numbers had.\n\nIdea use coins as outer loop and amount of combinations as inner loop.\nOtherwise below logic will not work.\nAnd if you wanna use amount combination as outer loop,\nyou have to change logic.\n\nAlgorithm\n1 Create a combinations arr with size amount + 1.\nEach location of arr will be coordinated to amount of money loc 6 = money 6.\nSetup amount 0 with value 1, this will never change,\nbecause coin will never going to 0\n\n2 Iterate through coins arr where each coin is a parameter as an outer loop\nand combinations as inner loop (start iterate from 1).\n\n3 Logic during each iteration\nif amount >= coin THEN\n  combinations[amount] += combinations[amount - coin]\n\nInput: amount 12, coins [1,2,5], output should be 4\ncurrent coin is 1\n0 1 2 3 4 5 6 7 8 9 10 11 12\n1 1 1 1 1 1 1 1 1 1  1  1  1\n\ncurrent coin is 2\ni=1\n1 >= 2 false, skip amount 1\n\ni=2\n2 >= 2 true, 2-2 = 0\nlook at amount 0 which is equal to 1\ncurrent value is 1\n1+1 = 2\n\ni=3\n3>=2 true, 3-2 = 1\n\nand so on\n\n0 1 2 3 4 5 6 7 8 9 10 11 12\n1 1 2 2 3 3 4 4 5 5  6  6  7\n\ncurrent coin is 5\nrepeat algorithm\n0 1 2 3 4 5 6 7 8 9 10 11 12\n1 1 2 2 3 4 5 6 7 8 10 11 13\n\nreturn combinations[amount] = combinations[12] = 13\n\nTime complexity is O(n*m), where n - coins, m - amount(combinations)\nSpace is O(coins*amount)\n*/\n\n/**\n * @param {number} amount\n * @param {number[]} coins\n * @return {number}\n*/\nvar change = function(amount, coins) {\n  if (amount <= 0) return 1;\n\n  let combinations = new Array(amount + 1).fill(0);\n  // setup amount 0 with value equal to 1\n  // this will never going to change,\n  // because coin will never going to 0\n  combinations[0] = 1;\n\n  for (const coin of coins) {\n    // start from 1\n    for (let i = 1; i < combinations.length; i++) {\n      // i is amount\n      if (i >= coin ) {\n        combinations[i] += combinations[i - coin];\n      }\n\n    }\n  }\n\n  return combinations[amount]\n}\n\n// tests\n// console.log('change', change(5, [1,2,5]))\n\n/*\nApproach Brute force\ntodo\n...\n*/\n// todo check brute force https://leetcode.com/problems/coin-change-2/discuss/141076/Unbounded-Knapsack\n// brute force https://leetcode.com/problems/coin-change-2/discuss/141076/Unbounded-Knapsack\n// several methods https://leetcode.com/problems/coin-change-2/discuss/674977/100-Faster-or-Recursive-1-d-2-d-DP-or-Matrix-With-Example-or-Commented-Code-Video\n// outer loop iterating over amount and inner loop iterating over coins\n// amount as the outer of loop\n\nexport { change }\n","/*\nLeetcode\n96 Unique Binary Search Trees\nmedium\n\nCatalan numbers\nGiven n, how many structurally unique BST's (binary search trees) that store\nvalues 1 ... n?\n\nExample:\nInput: 3\nOutput: 5\n\nExplanation:\nGiven n = 3, there are a total of 5 unique BST's:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n*/\n\n/*\nApproach DP\n\nIntuition\nGiven a sequence 1 ... n, to construct a Binary Search Tree (BST) out of the\nsequence, we could enumerate each number i in the sequence, and use the number\nas the root, naturally,\nthe subsequence 1 ... (i-1) on its left side would lay on the left branch of the root,\nand similarly the right subsequence (i+1)...n lay on the right branch of the root.\n\nWe then can construct the subtree from the subsequence recursively.\nThrough the above approach, we could ensure that the BST that we construct are\nall unique, since they have unique roots.\n\nThe problem is to calculate the number of unique BST. To do so, we need to define\ntwo functions:\n\nG(n): the number of unique BST for a sequence of length n.\nF(i, n), 1 <= i <= n: the number of unique BST, where the number i is the root of BST,\nand the sequence ranges from 1 to n.\n\nFirst of all, given the above definitions, we can see that the total number of\nunique BST G(n), is the sum of BST F(i) using each number i as a root.\ni.e. G(n) = F(1, n) + F(2, n) + ... + F(n, n).\n\nThe bottom cases, there is only one combination to construct a BST out of a\nsequence of length 1 (only a root) or 0 (empty tree).\ni.e. G(0)=1, G(1)=1.\n\nGiven a sequence 1n, we pick a number i out of the sequence as the root, then\nthe number of unique BST with the specified root F(i), is the cartesian product\nof the number of BST for its left and right subtrees.\n\nFor example, F(3, 7):\nthe number of unique BST tree with number 3 as its root. To construct an unique\nBST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root,\nwhich is to say, we need to construct an unique BST out of its left subsequence\n[1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine\nthem together (i.e. cartesian product). The tricky part is that we could consider\nthe number of unique BST out of sequence [1,2] as G(2), and the number of of\nunique BST out of sequence [4, 5, 6, 7] as G(4).\nTherefore, F(3,7) = G(2) * G(4).\ni.e.\nF(i, n) = G(i-1) * G(n-i),\t1 <= i <= n (cartesian product)\n\nCombining the above two formulas, we obtain the recursive formula for G(n). i.e.\nG(n) = G(0) * G(n-1) + G(1) * G(n-2) +  + G(n-1) * G(0)\n\nExample\n    n = 0;     null\n    count[0] = 1\n\n\n    n = 1;      1\n    count[1] = 1\n\n\n    n = 2;    1__       \t\t\t __2\n    \t\t      \\\t\t\t\t\t/\n    \t\t     count[1]\t   \tcount[1]\n    count[2] = 1 + 1 = 2\n\n\n    n = 3;    1__\t\t\t\t      __2__\t                   __3\n    \t\t      \\\t\t            /       \\\t\t\t      /\n    \t\t  count[2]\t\t  count[1]    count[1]\t\tcount[2]\n\n    count[3] = 2 + 1 + 2  = 5\n\n\n\n    n = 4;    1__  \t\t\t\t\t__2__\t\t\t\t\t   ___3___\n    \t\t      \\\t\t\t\t /        \\\t\t\t\t\t  /\t\t  \\\n    \t\t  count[3]\t\t count[1]    count[2]\t\t  count[2]   count[1]\n\n                 __4\n               /\n           count[3]\n\n    count[4] = 5 + 2 + 2 + 5 = 14\n\n\nAnd  so on ...\n\nComplexity analysis\nTime is O(n^2), could be only 1/half in n^2\nSpace O(n) (n+1)\n*/\n\n/**\n * @param {number} n\n * @return {number}\n */\nvar numTrees = function(n) {\n  let T = new Array(n+1).fill(0);\n  // bottom cases\n  T[0] = T[1] = 1;\n\n  for (let i = 2; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      // just treat each number as root, and then left part * right part is the answer.\n      // combine together - cartesian product\n      T[i] += T[j - 1] * T[i - j]\n    }\n  }\n  return T[n];\n}\n\n// console.log('numTrees', numTrees(3));\nexport {\n  numTrees\n}\n\n","/*\nLeetcode\n62 Unique Paths\nmedium\n\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in\nthe diagram below).\n\nThe robot can only move either down or right at any point in time. The robot\nis trying to reach the bottom-right corner of the grid (marked 'Finish' in the\ndiagram below).\n\nHow many possible unique paths are there?\n\nExample 1:\nInput: m = 3, n = 2\nOutput: 3\n\n| 0 | x | x |\n| x | x | 0 |\n\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right\ncorner:\n1. Right -> Right -> Down\n2. Right -> Down -> Right\n3. Down -> Right -> Right\n\nExample 2:\nInput: m = 7, n = 3\nOutput: 28\n\n\nConstraints:\n1 <= m, n <= 100\nIt's guaranteed that the answer will be less than or equal to 2 * 10 ^ 9.\n*/\n\n/*\nApproach\n\nwhen (m==0 || n== 0), my understanding is there will be no way to go down or\nright, so return 0.\n\n| 0 |\n| 0 |\n\nFor all other cells. The result = uniquePaths(m-1,n)+uniquePaths(m,n-1)\n*/\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\n// var uniquePaths = function(m, n) {\n//   if (m === 0 || n === 0) return 0;\n//   if (m === 1 || n === 1) return 1;\n\n//   let dp = new Array(n);\n//   for (let i = 0; i < n; i++) {\n//     dp[i] = 1;\n//   }\n\n// };\n\n// var uniquePathsIterate = function(m, n) {\n//   let dp = new Array(m+1).fill(1).map(x => new Array(n+1).fill(0));\n//   for (let i=1;i<=m;i++) {\n//       for (let j=1;j<=n;j++) {\n//           if (i==1 && j==1) dp[i][j] = 1;\n//           else dp[i][j] = dp[i-1][j] + dp[i][j-1];\n//       }\n//   }\n//   return dp[m][n];\n// }\n\n// todo table\nvar uniquePaths = function(m,n) {\n  //let path = new Array[[]]\n  //let path = Array.from(Array(2), () => new Array(3)).fill(0);\n  let path = [...Array(m)].map(_ => Array(n).fill(0));\n  //path[0][0] = 0;\n\n\n  for (let i = 0; i < m; i++) {\n    path[0][i] = 1\n  }\n\n  for (let j = 0; j < n; j++) {\n    path[0][j] = 1\n\n  }\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      path[i][j] = path[i-1][j] + path[i][j-1];\n    }\n  }\n\n  console.log(path)\n  return path[m-1][n-1];\n}\n\nconsole.log('uniquePath', uniquePaths(3,2))\n\nexport {\n  uniquePaths\n}\n","/*\nLeetcode\n121 Best time to buy and sell stock\neasy\n\nSay you have an array for which the ith element is the price of a given stock on\nday i.\n\nIf you were only permitted to complete at most one transaction (i.e., buy one and\nsell one share of the stock), design an algorithm to find the maximum profit.\n\nNote that you cannot sell a stock before you buy one.\n\nExample 1:\n\nInput: [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6),\nprofit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.\n\nExample 2:\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n*/\n\n/*\nApproach Brute force\n\nIntuition\nexample [7,1,5,3,6,4]\nIf buy stock in first day for 7$ and sell on next day for 1$. It means we are\nlosing 6$. It is terrible algorithm. Want we want to do, buy stock for 1$ and sell it\nfor next maximum value. We can't sell for 7$ because it was day before we bought\nand we can't go back in time.\n\nInput: [7,6,4,3,1] in descending order => profit does not exist\n\nExplanation\nWe need to find out the maximum difference (which will be the maximum profit)\nbetween two numbers in the given array. Also, the second number (selling price)\nmust be larger than the first one (buying price).\n\nIn formal terms, we need to find max(prices[j]  prices[i]), for every i and j such\nthat j > i.\n\nComplexity Analysis\nTime complexity: O(n2). Loop runs n(n1)/2 times\nSpace complexity: O(1). Only two variables - maxprofit and profit are used.\n*/\n\n/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfitUseBruteForce = function(prices) {\n  let maxProfit = 0;\n  for (let i = 0; i < prices.length - 1; i++) {\n    for (let j = i+1; j < prices.length; j++) {\n      let profit = prices[j] - prices[i];\n      if (profit > maxProfit) {\n        maxProfit = profit\n      }\n    }\n  }\n\n  return maxProfit;\n};\n\n/*\nAlgorithm One pass\n\nSay the given array is:\n[7, 1, 5, 3, 6, 4]\n\nIf we plot the numbers of the given array on a graph (days - x, profit - y),\nwe get:\nThe points of interest are the peaks and valleys in the given graph.\nWe need to find the largest peak following the smallest valley.\nWe can maintain two variables - minprice and maxprofit corresponding to the\nsmallest valley and maximum profit (maximum difference between selling price and\nminprice) obtained so far respectively.\n\nComplexity Analysis\nTime complexity: O(n). Only a single pass is needed.\nSpace complexity: O(1). Only two variables are used.\n*/\nvar maxProfit = function(prices) {\n  // always set min to max value initially and max to min value\n  let minPrice = +Infinity; // smallest valley\n  let maxProfit = 0; // max difference between selling price and minprice\n  for (let i = 0; i < prices.length; i++) {\n    if (prices[i] < minPrice) {\n      minPrice = prices[i]\n    } else if (prices[i] - minPrice > maxProfit) {\n      maxProfit = prices[i] - minPrice;\n    }\n  }\n\n  return maxProfit\n}\n\n/*\nApproach find so far min price\nThe idea is to find so far min price.\n\ntime is O(n)\nspace is O(1)\n*/\nvar maxProfit1 = function(prices) {\n  if (prices.length === 0) return 0;\n\n  let max = 0;\n  let sofarMin = prices[0];\n  for (let i = 0; i < prices.length; i++) {\n    if (prices[i] > sofarMin) {\n      max = Math.max(max, prices[i] - sofarMin)\n    } else {\n      // prices[i] < sofarMin\n      sofarMin = prices[i]\n    }\n  }\n  return max;\n}\n\n/*\nApproach\n\ntime is O(n)\nspace is O(1)\n*/\nvar maxProfitFindMinPrice = function(prices) {\n  if (prices.length === 0 || prices.length === 1) return 0;\n  let minPrice = +Infinity;\n  let maxProfit = 0;\n\n  for (let i = 0; i < prices.length; i++) {\n    minPrice = Math.min(minPrice, prices[i]);\n    maxProfit = Math.max(maxProfit, prices[i] - minPrice);\n  }\n  return maxProfit\n}\n\n/*\nApproach DP\n\nThere's is a clear formula expression here, where dp[i] denotes the max profit\non ith day.\n\nWe should get the max profit on (i + 1)th day from\nprofit from previous days, or\nprofit gained on this day (current price - minimum price before)\nAnd only after this, we can update the minimum price.\n\nThen, according this 'naive' DP solution, we can see there's only one variable\nneeded for memorization. So we change the array dp[] to a variable, and thus\nchange the space from O(n) to O(1).\n\n(A good example of doing this reducing space would be knapsack problem. We can\nchange the space complexity from O(mn) to O(n). I think you can discover that\nby yourself.)\n\ntime is O(n)\nspace is O(n) create auxillary array\n*/\nvar maxProfitDP = function(prices) {\n  let dp = new Array(prices.length).fill(0);\n  dp[0] = 0;\n  let minPrice = prices[0];\n\n  for (let i = 1; i < prices.length; i++) {\n    dp[i] = Math.max(dp[i-1], prices[i] - minPrice);\n    minPrice = Math.min(minPrice, prices[i])\n  }\n  return Math.max(...dp);\n}\n\n//console.log('maxProfitDP', maxProfitDP([7,1,5,3,6,4]))\n\n// todo why it's DP problem\n// https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution/\n\nvar maxProfit2 = function(prices){\n  if (prices == null || prices.length <= 1) return 0;\n\n  let b0 = -prices[0], b1 = b0;\n  let s0 = 0, s1 = 0, s2 = 0;\n\n  for(let i = 1; i < prices.length; i++) {\n    b0 = Math.max(b1, s2 - prices[i]);\n    s0 = Math.max(s1, b1 + prices[i]);\n    b1 = b0; s2 = s1; s1 = s0;\n  }\n  return s0;\n}\n\n/*\nIt's kinda the same approach compared to the Kadane's Algorithm on maximum subarray.\nWhen iterating the array you consider to sell on day i what would be the best profit against\nits current minimum buying price while updating minimum buying price.\n\nhttps://hackernoon.com/kadanes-algorithm-explained-50316f4fd8a6\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane's-Algorithm-Since-no-one-has-mentioned-about-this-so-far-%3A)-(In-case-if-interviewer-twists-the-input)\n*/\n\n// https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/712254/simple-2-approaches-DP-and-Recursion-Time-O(n)-Space-O(1)\n// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\nconsole.log('maxProfit', maxProfitUseBruteForce([7,6,4,3,1]))\n\n// answer https://leetcode.com/discuss/explore/july-leetcoding-challenge/762350/Task-Scheduler-questions\n\n// word break\n// https://www.youtube.com/watch?v=WepWFGxiwRs\n\n//https://leetcode.com/problems/word-break/discuss/169383/The-Time-Complexity-of-The-Brute-Force-Method-Should-Be-O(2n)-and-Prove-It-Below\n/*\nLeetocode\n139 Word break\n\nGiven a non-empty string s and a dictionary wordDict containing a list of\nnon-empty words, determine if s can be segmented into a space-separated sequence\nof one or more dictionary words.\n\nNote:\nThe same word in the dictionary may be reused multiple times in the segmentation.\nYou may assume the dictionary does not contain duplicate words.\nExample 1:\n\nInput: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\nExample 2:\n\nInput: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\n             Note that you are allowed to reuse a dictionary word.\nExample 3:\n\nInput: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\nOutput: false\n*/\n\n/*\nApproach\n\ns = I a m a c e\nwordDict = [I, am, ace, a]\n\nlenght = 1\nlength = 2\n\nString=\"iamace\" Words=[i, am, ace]\n1) take array of length of the string+1.and first cell is empty string.\n2) take first character check in Words it's there or not.\n    If yes empty string in the cell.\n    If no that character plus previous cell string and keep in the cell.\n3) if not empty string in cell check any word in Words is matching with it or not if match empty string in cell or keep as it is.\n4) continue for rest character.\n5) in the last cell if it's empty then successful else not.\n\n*/\n/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {boolean}\n */\nvar wordBreak = function(s, wordDict) {\n\n};\n\n//console.log('wordBreak', wordBreak('leetcode', [\"leet\", \"code\"]))\n//console.log('wordBreak', wordBreak('leetcode', [\"leet\", \"code\"]))\n\n// word break ii\n// https://leetcode.com/problems/word-break-ii/discuss/739854/JavaScript-Easy-Solution\n\n\nexport {\n  maxProfit,\n  maxProfitUseBruteForce,\n  maxProfit1,\n  maxProfitFindMinPrice,\n  maxProfitDP\n}\n","/*\nLeetcode\n70 Climbing stairs\neasy\n\nYou are climbing a stair case. It takes n steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you\nclimb to the top?\n\nExample 1:\nInput: 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\nInput: 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\nConstraints:\n1 <= n <= 45\n\nHint\nTo reach nth step, what could have been your previous steps? (Think about the\nstep sizes)\n\nPossible questions to as the interviewer:\n- Do I need to return the order of steps takes as well? (No, just count and return\nthe total number of unique ways)\n- How many unique ways exists if N = 0? Conventionally we assume that as 1\n- Are [1,1,2] and [1,2,1] considered unique or same? The orders of steps if different\nbut numbers are the same. Yes, these two will be considered unique\n*/\n\n/*\nApproach Brute force - recursion\nRetrieving answer for current step using answers of previous smaller steps.\n\nIf you see carefully, the answer for N = 1,2,3,4,5,... from a pattern\n\nfor n = 1, answer = 1\nfor n = 2, answer = 2\nfor n = 3, answer = 3\nfor n = 4, answer = 5\nfor n = 5, answer = 8\nfor n = 6, answer = 13\n...\nthis is a Fibonacci sequence.\n\nIf you want to reach the nth step in the staircase, what will be your last second\nstep? If would be either the (n-1)th step or the (n-2)th step, because you can\njump only 1 or 2 steps at a time.\n\nTotal number of ways to reach nth stair = total number of ways to reach (n-1)th\nstair + total number of ways to reach (n-2)th stair.\n\nclimbStairs(n) = climbStairs(n-1) + climbStairs(n-2)\nThis is also the relation followed by the Fibonacci sequence.\n\nComplexity Analysis\nTime complexity: O(2^n)\nSpace complexity: O(n), for recursion stack space\n\nRecursion Tree\n                    (0,5)\n                  /        \\\n                (1,5)      (2,5)\n                /  \\        /  \\\n              (2,5) (3,5) (3,5) (4,5)\n               /  \\  /  \\\n      (3,5)(4,5) (4,5) (5,5) ...\nnumber of nodes 2^n\n\nCritical ideas to think\n- Are you able to notice the overlapping subproblems?\n- hwo would you modify this recursion if you could take upto k steps at a time?\n- think about the top-down approach to solve this problem\n*/\n/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairsBruteForce = function(n) {\n  if (n < 2) return 1;\n  else {\n    return climbStairsBruteForce(n-1) + climbStairsBruteForce(n-2)\n  }\n}\n\nconsole.log('climbStairsBruteForce', climbStairsBruteForce(3))\n\n/*\nApproach Bottom-up approach of DP\n...\n\n\n...\nComplexity Analysis\nTime complexity : O(n). Single loop upto n.\n\nSpace complexity : O(n). dp array of size nn is used.\n*/\nvar climbStairsDP = function(n) {\n  if (n === 1) return 1;\n  let solution = new Array(n+1).fill(0);\n  solution[0] = 1;\n  solution[1] = 1;\n  solution[2] = 2;\n\n  for (let i = 3; i <= n; i++) {\n    solution[i] = solution[i-1] + solution[i-2]\n  }\n  return solution[n]\n}\n\nexport {\n  climbStairsBruteForce,\n  climbStairsDP\n}\n","import React from 'react';\nimport Details from '../Details';\n\n// problems\nimport { change } from '../../leetcode/dp/518-coin-change-2';\nimport { numTrees } from '../../leetcode/dp/96-unique-binary-search-trees';\nimport { uniquePaths } from '../../leetcode/dp/62-unique-paths';\nimport { maxProfit } from '../../leetcode/dp/121-best-time-to-buy-sell-stock';\nimport { climbStairsBruteForce } from '../../leetcode/dp/70-climbing-stairs';\n\nexport default function DP() {\n  return (\n    <div className=\"dp\">\n      <h2 id=\"dp\">Dynamic Programming</h2>\n\n      <Details\n        id=\"test\"\n        code={maxProfit.toString()}\n        secondCode={climbStairsBruteForce.toString()}\n      />\n      <ul>\n        <li>\n          <Details\n            id=\"db-coin-change-2\"\n            question=\"Coin change 2: DP and use as outer loop coins array\"\n            solution={`\n            Any DP problem should start from explanation of sub problems.\n            The idea is in order to know how many combinations there were for 5,\n            we needed to know how many combinations the previous numbers had.\n            `}\n            time=\"O(n*m), where n - coins, m - amount(combinations)\"\n            space=\"Create an arr of O(amount+1)\"\n            code={change.toString()}\n            secondCode={uniquePaths.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"db-num-trees\"\n            question=\"Unique Binary Search Trees\"\n            time=\"O(n^2)\"\n            space=\"O(n)\"\n            code={numTrees.toString()}\n          />\n        </li>\n\n      </ul>\n\n  </div>\n  );\n}\n","/**\n  *   Looping a triangle\n  *   Write a loop that makes seven calls to console.log to output the following triangle:\n  *   #\n  *   ##\n  *   ###\n  *   ####\n  *   #####\n  *   ######\n  *   #######\n*/\nfunction loopingTriangle(len, symbol='#') {\n  for (let line = symbol; line.length < len + 1; line += symbol) {\n    console.log('line', line);\n  }\n}\n\nfunction drawPyramid(h) {\n  let line = '#';\n  for (let i = 0; i <= h; i++) {\n    for (let j = 1; j < i; j++) {\n      line += '#';\n\n    }\n    console.log('line', line)\n  }\n}\n\n/**\n * Draw a pyramid by recursion means\n * draw pyramid of size n-1 + additional row, for example\n * if h = 4, draw(4-1) + one additional loop\n */\nfunction drawPyramidUsingRecursion(h) {\n  let line = '#';\n  // exclude for negative numbers\n  if (h === 0) {\n    return\n  }\n\n  drawPyramid(h-1)\n  for (let i = 0; i < h; i++) {\n    line += '#';\n  }\n  console.log('line recursion', line)\n}\n\n export { loopingTriangle, drawPyramid, drawPyramidUsingRecursion }\n","/**\n * Create a for loop that iterates up to 100 while outputting \"fizz\" at multiples of 3, \"buzz\" at multiples of 5 and \"fizzbuzz\" at multiples of 3 and 5\n *\n * 1\n * 2\n * 'Fizz'\n * 4\n * 'Buzz'\n * ..\n * @param {for loop numbers}\n * @return {or number or string}\n */\n\nconst fizzBuzz = () => {\n  for (let n = 1; n <= 100; n++) {\n    let output = \"\";\n    if (n % 3 === 0)\n      output += \"Fizz\";\n    if (n % 5 === 0)\n      output += \"Buzz\";\n\n    console.log(output || n);\n  }\n};\n\nexport { fizzBuzz }\n","/**\n *\n * Write a program that creates a string that represents an 88 grid,\n * using newline characters to separate lines.\n * At each position of the grid there is either a space or a \"#\" character.\n * The characters should form a chessboard.\n * Passing this string to console.log should show something like this:\n *\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *\n*/\nexport function chessboard(size=8) {\n  let board = '';\n\n  // lines\n  for (let y = 0; y < size; y++) {\n    // characters\n    for (let x = 0; x < size; x++) {\n      if ( (x+y) % 2 === 0) {\n        board += ' ';\n      } else {\n        board += '#'\n      }\n    }\n    board += '\\n';\n  }\n\n  console.log(board)\n}\n","function isEven(n) {\n  if ( n % 2 === 0) {\n    return true\n  } else if (n === 1 ) {\n    return false\n  } else if (n < 0) {\n    return isEven(-n)\n  } else return isEven(n-2)\n}\n\n/**\n * Chapter 3 functions\n * Bean Counting\n*/\nfunction countChar(str, letter) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === letter) {\n      count++\n    }\n  }\n\n  return count;\n}\n\nfunction countBs(str) {\n  return countChar(str, 'B')\n}\n\nexport { isEven, countBs, countChar}\n","/**\n * Eloquent Reversing an array\n * Arrays have a reverse method that changes the array by inverting the order in which its elements appear.\n * For this exercise, write two functions, reverseArray and reverseArrayInPlace.\n *\n * The first, reverseArray, takes an array as argument and produces a new array\n * that has the same elements in the inverse order.\n *\n * The second, reverseArrayInPlace, does what the reverse method does:\n * it modifies the array given as argument by reversing its elements.\n *\n * Neither may use the standard reverse method.\n *\n * Thinking back to the notes about side effects and pure functions in the previous chapter,\n * which variant do you expect to be useful in more situations? Which one runs faster\n *\n */\n\nconst reverseArray = function(arr) {\n  const len = arr.length;\n  let reverse = [];\n\n  for (let i = len - 1; i >=0; i--) {\n    reverse.push(arr[i]);\n  }\n\n  return reverse;\n}\n\nconst reverseArrayUsePop = function(arr) {\n  const len = arr.length;\n  let reverse = [];\n\n  for (let i = 0; i < len; i++) {\n    let last = arr.pop();\n    reverse.push(last)\n  }\n\n\n  return reverse;\n}\n\nfunction reverseArrayInPlace(arr) {\n  const len = arr.length;\n\n  for (let i = 0; i < Math.floor(len / 2); i++) {\n    let old = arr[i];\n    arr[i] = arr[len - 1 - i];\n    arr[len - 1 - i] = old\n  }\n\n  return arr;\n}\n\n/*\n  Write a function that takes an array\n  and uses recursion to return its contents in reverse.\n\n  Closure it happens when you have function inside other function.\n\n  Solution:\n    base case is an empty array\n*/\n/**\n * @param {[]} arr\n * @param {[]} reversed arr\n */\nfunction reverseUseRecursion(arr) {\n  let reversedArr = [];\n\n  let addItems = function(orderedArr) {\n    // if array is empty return\n    if (orderedArr.length > 0) {\n      reversedArr.push(orderedArr.pop());\n      addItems(orderedArr)\n    }\n    return;\n  };\n  addItems(arr);\n\n  return reversedArr;\n}\n\nfunction multiplierUseRecursion(arr, num) {\n  if (arr.length === 0) {\n    return arr\n  }\n\n  let last = arr.pop();\n  multiplierUseRecursion(arr, num);\n  arr.push(last * num);\n\n  return arr\n}\n\n\nexport {\n  reverseArray, reverseArrayInPlace, reverseArrayUsePop,\n  reverseUseRecursion,\n  multiplierUseRecursion\n}\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nimport Details from '../components/Details';\nimport { loopingTriangle } from './tasks/looping-triangle';\nimport { fizzBuzz } from './tasks/fizz-buzz';\nimport { chessboard } from './tasks/chessboard';\nimport { isEven } from './tasks/3-chapter-functions/is-even';\nimport { reverseArray, reverseArrayInPlace, reverseUseRecursion } from './tasks/4-chapter-data-structures/reverse-array';\n\nexport default function StringManipulation() {\n  return (\n    <div className=\"sorting\">\n      <h2>\n        Code Sandbox <br />\n        <a href=\"https://eloquentjavascript.net/\">Eloquent JavaScript</a>\n      </h2>\n\n      <ul>\n        <li>\n          <Details\n            id=\"eloquent-looping-triangle\"\n            question=\"Looping triangle\"\n            solution=\"Write a loop that makes seven calls to console.log to output the triangle\"\n            code={loopingTriangle.toString()}\n          />\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"eloquent-fizz-buzz\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n            <summary role=\"button\" aria-controls=\"content\">\n              <span className=\"question\">\n                Question:&nbsp;\n                <strong>\n                  fizzbuzz\n                </strong>\n                <p>\n                  Create a for loop that iterates up to 100 while outputting \"fizz\" at multiples of 3,\n                  \"buzz\" at multiples of 5 and \"fizzbuzz\" at multiples of 3 and 5\n                </p>\n              </span>\n            </summary>\n\n            <div aria-hidden=\"true\">\n              <h3 className=\"title\">Solution:</h3>\n              <span className=\"complexity\">\n                runtime - O(n)\n              </span>\n\n              <SyntaxHighlighter\n                language=\"javascript\"\n                style={docco}\n              >\n                {fizzBuzz.toString()}\n              </SyntaxHighlighter>\n            </div>\n          </details>\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"eloquent-fizz-buzz\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n            <summary role=\"button\" aria-controls=\"content\">\n              <span className=\"question\">\n                Question:&nbsp;\n                <strong>\n                  Chessboard\n                </strong>\n                <p>\n                  Write a program that creates a string that represents an 88 grid, using newline characters\n                  to separate lines. At each position of the grid there is either a space or a \"#\" character.\n                  The characters should form a chessboard.\n                </p>\n              </span>\n            </summary>\n\n            <div aria-hidden=\"true\">\n              <h3 className=\"title\">Solution:</h3>\n              <span className=\"complexity\">complexity - n2</span>\n              <SyntaxHighlighter\n                language=\"javascript\"\n                style={docco}\n              >\n                { chessboard.toString() }\n              </SyntaxHighlighter>\n            </div>\n          </details>\n        </li>\n\n        <li>\n          <Details\n            id=\"eloquent-is-even\"\n            question=\"Define whether a positive whole number is even or odd (using recursion): Zero is even, One is odd, for any other number N, its evenness is the same as N - 2.\"\n            code={isEven.toString()}\n          />\n        </li>\n\n        {/* chapter 4 */}\n        <li>\n          <Details\n            id=\"eloquent-4-reverse-array\"\n            question=\"Reverse an array\"\n            solution=\"\"\n            code={reverseArray.toString()}\n            secondCode={reverseArrayInPlace.toString()}\n            thirdSolution={reverseUseRecursion.toString()}\n          />\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","import React from 'react';\n\nimport BitManipulation from './concepts/Bitwise';\nimport Number from './concepts/Number';\n\nimport StringManipulation from './concepts/StringManipulation';\nimport ArrayAlgorithms from './concepts/ArrayAlgorithms';\n\nimport Stack from './concepts/Stack';\nimport Queue from './concepts/Queue';\nimport LinkedLists from './concepts/LinkedLists';\n\nimport Hash from './concepts/Hash';\n\nimport Graph from './concepts/Graph';\nimport Tree from './concepts/Tree';\nimport Heap from './concepts/Heap';\nimport Trie from './concepts/Trie';\n\n\nimport Sorting from './concepts/Sorting';\nimport Searching from './concepts/Searching';\n\nimport Recursion from './concepts/Recursion';\nimport GreedyAlgorithms from './concepts/GreedyAlgorithms';\nimport DP from './concepts/DP';\n\nimport CodeSandboxTasks from '../eloquent-tasks/CodeSandboxTasks';\n\nimport './main.css';\n\nfunction Main() {\n  return (\n    <div className=\"main\">\n      <div className=\"wrapper\">\n        <BitManipulation />\n        <Number />\n\n        <StringManipulation />\n        <ArrayAlgorithms />\n\n        <LinkedLists />\n        <Stack />\n        <Queue />\n\n        <Hash />\n\n        <Graph />\n        <Tree />\n        <Heap />\n        <Trie />\n\n        <Sorting />\n        <Searching />\n\n        <Recursion />\n        <GreedyAlgorithms />\n        <DP />\n\n        <CodeSandboxTasks />\n      </div>\n  </div>\n  );\n}\n\nexport default Main;\n","import React from 'react';\nimport { Component } from 'react';\n//import { boundMethod } from 'autobind-decorator';\nimport SplitPane from 'react-split-pane';\nimport PropTypes from 'prop-types';\nimport { MOBILE_DEVICE, MINSIZE, EXPANDEDSIZE, THRESHOLDSIZE } from './../config/constants';\n\nimport './resizer.css';\n\nconst propTypes = {\n  children: PropTypes.any\n};\n\nexport default class SplitSidebarView extends Component {\n  constructor (props) {\n    super(props);\n\n    const width = window.innerWidth;\n    this.state = {\n      sideBarSize: this.getSize(width),\n      sideBarGrowing: false\n    };\n\n    this.handleDrag = this.handleDrag.bind(this);\n    this.onDragFinished = this.onDragFinished.bind(this);\n    this.onResizerDoubleClick = this.onResizerDoubleClick.bind(this);\n  }\n\n  getSize(windowWidth) {\n    const minCollapsedWidth = MOBILE_DEVICE; // tablet/mobile devices\n    return windowWidth >= minCollapsedWidth ? EXPANDEDSIZE : MINSIZE;\n  }\n\n  handleDrag(size) {\n    if (size !== this.state.sideBarSize) {\n      this.setState({\n        sideBarSize: size,\n        sideBarGrowing: this.state.sideBarSize < size\n      });\n    }\n  }\n\n  onDragFinished() {\n    this.setState({\n      sideBarSize: this.state.sideBarGrowing ? EXPANDEDSIZE : MINSIZE\n    });\n  }\n\n  onResizerDoubleClick(event) {\n    this.setState({\n      sideBarSize: this.state.sideBarSize === MINSIZE ? EXPANDEDSIZE : MINSIZE\n    });\n  }\n\n  render() {\n    const { sideBarSize } = this.state;\n    const { children } = this.props;\n\n    return (\n      <SplitPane\n        className={sideBarSize < THRESHOLDSIZE ? 'sidebarShortVersion' : null}\n        onChange={this.handleDrag}\n        onDragFinished={this.onDragFinished}\n        onResizerDoubleClick={this.onResizerDoubleClick}\n        resizerStyle={{ width: '0' }}\n        split=\"vertical\"\n        minSize={MINSIZE}\n        maxSize={EXPANDEDSIZE}\n        size={sideBarSize}>\n        { children }\n      </SplitPane>\n    );\n  }\n}\n\nSplitSidebarView.propTypes = propTypes;\n","// screen width\nexport const DESKTOP_DEVICE = 1440; // mac 13 inches\nexport const TABLET_DEVICE = 1024;\nexport const MOBILE_DEVICE = 767;\n\n\n// sidebar\nexport const MINSIZE = 67;\nexport const EXPANDEDSIZE = 250;\nexport const THRESHOLDSIZE = (MINSIZE + EXPANDEDSIZE) / 2;\n","import React, { Component } from 'react';\nimport Sidebar from './components/Sidebar';\nimport Main from './components/Main';\nimport SplitSidebarView from './components/SplitSidebarView';\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport './App.css';\n\nfunction openTarget() {\n  let hash = location.hash.substring(1);  // eslint-disable-line\n\n  if (hash) {\n    var detail = document.getElementById(hash);\n  }\n\n  if (detail && detail.tagName.toLowerCase() === 'details') {\n    detail.open === true ?  detail.open = false : detail.open = true\n  }\n}\n\nclass App extends Component {\n  state = {\n\n  }\n\n  componentDidMount() {\n    window.addEventListener('hashchange', openTarget);\n  }\n\n\n  render() {\n    return (\n      <div className=\"App\">\n        <SplitSidebarView>\n          <Sidebar className=\"sidebar\" />\n          <div className=\"rightPart\">\n              <header className=\"App-header\">\n                Computer Science Algorithms in JavaScript\n              </header>\n              <Main />\n          </div>\n        </SplitSidebarView>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}